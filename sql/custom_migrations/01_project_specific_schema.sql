-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- ============================================================================
-- BuffrSign Database Schema - Complete Table Definitions
-- ============================================================================
-- This file contains all table definitions for the BuffrSign platform
-- Generated from Supabase project: inqoltqqfneqfltcqlmx
-- Date: 2025-01-21
-- ============================================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================================================
-- CUSTOM TYPES AND ENUMS
-- ============================================================================

-- User roles enum
CREATE TYPE user_role AS ENUM ('user', 'admin', 'super_admin');

-- AI method enum for tracking different AI processing methods
CREATE TYPE ai_method AS ENUM (
    'gpt4_vision',
    'google_vision', 
    'azure_vision',
    'pytesseract_fallback',
    'pydantic_ai_agent',
    'openai_structured',
    'ai_agent_manager',
    'regex_fallback'
);

-- KYC workflow states
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'completed',
    'failed'
);

-- KYC decision types
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected', 
    'pending',
    'requires_review'
);

-- ============================================================================
-- CORE USER MANAGEMENT TABLES
-- ============================================================================

-- User profiles table (extends auth.users)
CREATE TABLE IF NOT EXISTS profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    phone TEXT,
    namibian_id TEXT,
    company_name TEXT,
    account_type TEXT DEFAULT 'individual' CHECK (account_type = ANY (ARRAY['individual', 'business', 'enterprise', 'government'])),
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    first_name TEXT DEFAULT '',
    last_name TEXT DEFAULT '',
    role user_role DEFAULT 'user',
    avatar_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMPTZ,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    language TEXT DEFAULT 'en',
    timezone TEXT DEFAULT 'UTC',
    theme TEXT DEFAULT 'system' CHECK (theme = ANY (ARRAY['light', 'dark', 'system'])),
    can_view_dashboard BOOLEAN DEFAULT TRUE,
    can_manage_users BOOLEAN DEFAULT FALSE,
    can_manage_documents BOOLEAN DEFAULT FALSE,
    can_manage_compliance BOOLEAN DEFAULT FALSE,
    can_view_analytics BOOLEAN DEFAULT FALSE,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_access_admin_panel BOOLEAN DEFAULT FALSE,
    can_manage_super_admins BOOLEAN DEFAULT FALSE,
    can_manage_kyc BOOLEAN DEFAULT FALSE,
    can_manage_templates BOOLEAN DEFAULT FALSE,
    email TEXT UNIQUE,
    email_provider VARCHAR DEFAULT 'sendgrid',
    email_preferences JSONB DEFAULT '{}'
);

-- ============================================================================
-- DOCUMENT MANAGEMENT TABLES
-- ============================================================================

-- Main documents table
CREATE TABLE IF NOT EXISTS documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR NOT NULL,
    file_path VARCHAR NOT NULL,
    file_hash VARCHAR NOT NULL,
    file_size INTEGER NOT NULL,
    mime_type VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'draft',
    created_by UUID REFERENCES auth.users(id),
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ai_analysis_enabled BOOLEAN DEFAULT FALSE,
    ai_analysis_status VARCHAR DEFAULT 'not_analyzed',
    ai_analysis_id UUID,
    compliance_analysis_id UUID,
    document_type VARCHAR,
    industry VARCHAR,
    jurisdiction VARCHAR DEFAULT 'namibia',
    kyc_workflow_id UUID,
    is_kyc_document BOOLEAN DEFAULT FALSE,
    kyc_document_type VARCHAR
);

-- Document recipients
CREATE TABLE IF NOT EXISTS recipients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    email VARCHAR NOT NULL,
    full_name VARCHAR NOT NULL,
    role VARCHAR DEFAULT 'signer',
    signing_order INTEGER DEFAULT 1,
    status VARCHAR DEFAULT 'pending',
    signed_at TIMESTAMP,
    viewed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Document signatures
CREATE TABLE IF NOT EXISTS signatures (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    recipient_id UUID REFERENCES recipients(id) ON DELETE CASCADE,
    signature_type VARCHAR NOT NULL,
    signature_data TEXT NOT NULL,
    certificate_id VARCHAR,
    ip_address INET,
    user_agent TEXT,
    timestamp_token TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ai_detected BOOLEAN DEFAULT FALSE,
    signature_field_id UUID,
    compliance_verified BOOLEAN DEFAULT FALSE,
    eta_compliance_status VARCHAR DEFAULT 'pending',
    ai_confidence_score NUMERIC,
    ai_analysis_method ai_method,
    ai_quality_assessment JSONB DEFAULT '{}'
);

-- Document fields (for signature placement)
CREATE TABLE IF NOT EXISTS document_fields (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    field_type VARCHAR NOT NULL,
    field_name VARCHAR NOT NULL,
    x_position NUMERIC NOT NULL,
    y_position NUMERIC NOT NULL,
    width NUMERIC NOT NULL,
    height NUMERIC NOT NULL,
    page_number INTEGER NOT NULL,
    is_required BOOLEAN DEFAULT TRUE,
    field_data JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Document versions
CREATE TABLE IF NOT EXISTS document_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path VARCHAR NOT NULL,
    file_hash VARCHAR NOT NULL,
    changes_description TEXT,
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- AI ANALYSIS TABLES
-- ============================================================================

-- AI analysis results
CREATE TABLE IF NOT EXISTS ai_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    analysis_type VARCHAR DEFAULT 'comprehensive',
    document_summary TEXT,
    key_clauses JSONB,
    signature_fields JSONB,
    compliance_score INTEGER CHECK (compliance_score >= 0 AND compliance_score <= 100),
    eta_compliance JSONB,
    recommendations JSONB,
    risk_assessment JSONB,
    confidence_scores JSONB,
    analysis_metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    kyc_workflow_id UUID,
    primary_ocr_method ai_method,
    fallback_methods ai_method[] DEFAULT '{}',
    extracted_fields JSONB DEFAULT '{}',
    field_confidences JSONB DEFAULT '{}',
    image_quality_score NUMERIC,
    text_clarity_score NUMERIC,
    overall_quality_score NUMERIC,
    processing_time_ms INTEGER
);

-- AI workflows
CREATE TABLE IF NOT EXISTS ai_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    workflow_type VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'pending',
    workflow_config JSONB,
    ai_recommendations JSONB,
    compliance_checklist JSONB,
    user_guidance JSONB,
    execution_log JSONB,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI insights
CREATE TABLE IF NOT EXISTS ai_insights (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    insight_type VARCHAR NOT NULL,
    key_points JSONB,
    risk_factors JSONB,
    optimization_suggestions JSONB,
    compliance_gaps JSONB,
    signature_recommendations JSONB,
    confidence_scores JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI templates
CREATE TABLE IF NOT EXISTS ai_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR NOT NULL,
    description TEXT,
    template_type VARCHAR NOT NULL,
    industry VARCHAR,
    jurisdiction VARCHAR DEFAULT 'namibia',
    template_content TEXT NOT NULL,
    signature_fields JSONB,
    compliance_status JSONB,
    customization_options JSONB,
    legal_notes JSONB,
    is_ai_generated BOOLEAN DEFAULT TRUE,
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- COMPLIANCE TABLES
-- ============================================================================

-- Compliance analysis
CREATE TABLE IF NOT EXISTS compliance_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    frameworks JSONB DEFAULT '["eta_2019", "cran"]',
    jurisdiction VARCHAR DEFAULT 'namibia',
    compliance_analysis TEXT,
    compliance_score INTEGER CHECK (compliance_score >= 0 AND compliance_score <= 100),
    eta_sections JSONB,
    cran_compliance JSONB,
    recommendations JSONB,
    risk_assessment JSONB,
    remediation_plan JSONB,
    analysis_metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ETA compliance tracking
CREATE TABLE IF NOT EXISTS eta_compliance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    signature_id UUID REFERENCES signatures(id) ON DELETE CASCADE,
    compliance_type VARCHAR NOT NULL,
    compliance_status VARCHAR DEFAULT 'pending',
    verification_data JSONB,
    verified_at TIMESTAMP,
    verified_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ai_analysis_id UUID REFERENCES ai_analysis(id),
    compliance_score INTEGER CHECK (compliance_score >= 0 AND compliance_score <= 100),
    risk_level VARCHAR DEFAULT 'low',
    recommendations JSONB,
    remediation_required BOOLEAN DEFAULT FALSE
);

-- ============================================================================
-- KYC WORKFLOW TABLES
-- ============================================================================

-- SADC countries reference
CREATE TABLE IF NOT EXISTS sadc_countries (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    country_code CHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR NOT NULL,
    id_format VARCHAR NOT NULL,
    id_patterns TEXT[] NOT NULL,
    date_format VARCHAR NOT NULL,
    keywords TEXT[] NOT NULL,
    validation_rules JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- KYC workflows
CREATE TABLE IF NOT EXISTS kyc_workflows (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    workflow_state kyc_workflow_state DEFAULT 'initialized',
    detected_country CHAR(2) REFERENCES sadc_countries(country_code),
    country_confidence NUMERIC,
    country_detection_method ai_method,
    ocr_extraction JSONB DEFAULT '{}',
    ai_field_extraction JSONB DEFAULT '{}',
    sadc_validation JSONB DEFAULT '{}',
    final_decision kyc_decision,
    decision_confidence NUMERIC,
    rejection_reasons TEXT[],
    compliance_status JSONB DEFAULT '{}',
    audit_trail JSONB DEFAULT '[]',
    processing_time_ms INTEGER,
    total_confidence NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);

-- KYC analysis steps
CREATE TABLE IF NOT EXISTS kyc_analysis_steps (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR DEFAULT 'pending',
    ai_method ai_method,
    confidence_score NUMERIC,
    processing_time_ms INTEGER,
    input_data JSONB DEFAULT '{}',
    output_data JSONB DEFAULT '{}',
    error_details JSONB DEFAULT '{}',
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- User KYC status
CREATE TABLE IF NOT EXISTS user_kyc_status (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    user_id UUID UNIQUE NOT NULL REFERENCES auth.users(id),
    kyc_status VARCHAR DEFAULT 'pending',
    kyc_level INTEGER DEFAULT 1,
    latest_workflow_id UUID REFERENCES kyc_workflows(id),
    verification_date TIMESTAMPTZ,
    expiry_date TIMESTAMPTZ,
    compliance_level VARCHAR,
    risk_score NUMERIC,
    verified_documents JSONB DEFAULT '{}',
    verification_history JSONB DEFAULT '[]',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- TEMPLATES AND SUBSCRIPTIONS
-- ============================================================================

-- Document templates
CREATE TABLE IF NOT EXISTS templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR NOT NULL,
    description TEXT,
    category VARCHAR,
    file_path VARCHAR NOT NULL,
    fields JSONB NOT NULL,
    is_public BOOLEAN DEFAULT FALSE,
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_ai_generated BOOLEAN DEFAULT FALSE,
    ai_template_id UUID REFERENCES ai_templates(id),
    template_type VARCHAR,
    industry VARCHAR,
    jurisdiction VARCHAR DEFAULT 'namibia',
    compliance_metadata JSONB,
    signature_field_specs JSONB
);

-- Subscription plans
CREATE TABLE IF NOT EXISTS subscription_plans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR NOT NULL,
    description TEXT,
    price_monthly NUMERIC NOT NULL,
    price_yearly NUMERIC NOT NULL,
    document_limit INTEGER NOT NULL,
    user_limit INTEGER NOT NULL,
    features JSONB NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User subscriptions
CREATE TABLE IF NOT EXISTS user_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    plan_id UUID REFERENCES subscription_plans(id),
    status VARCHAR DEFAULT 'active',
    start_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_date TIMESTAMP,
    auto_renew BOOLEAN DEFAULT TRUE,
    payment_method VARCHAR,
    stripe_subscription_id VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- AUDIT AND SECURITY TABLES
-- ============================================================================

-- Audit trail
CREATE TABLE IF NOT EXISTS audit_trail (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id),
    action VARCHAR NOT NULL,
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ai_related BOOLEAN DEFAULT FALSE,
    ai_workflow_id UUID REFERENCES ai_workflows(id),
    ai_insight_id UUID REFERENCES ai_insights(id)
);

-- Security events
CREATE TABLE IF NOT EXISTS security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    event_type VARCHAR NOT NULL,
    event_data JSONB NOT NULL,
    ip_address INET,
    user_agent TEXT,
    risk_score INTEGER DEFAULT 0,
    is_suspicious BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- API keys
CREATE TABLE IF NOT EXISTS api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    name VARCHAR NOT NULL,
    key_hash VARCHAR NOT NULL,
    permissions JSONB NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    last_used_at TIMESTAMP,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- NOTIFICATION AND EMAIL TABLES
-- ============================================================================

-- Notifications
CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    type VARCHAR NOT NULL,
    title VARCHAR NOT NULL,
    message TEXT NOT NULL,
    data JSONB,
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Email notifications
CREATE TABLE IF NOT EXISTS email_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    recipient_id UUID REFERENCES recipients(id) ON DELETE CASCADE,
    email_type VARCHAR NOT NULL CHECK (email_type = ANY (ARRAY['document_invitation', 'signature_reminder', 'document_signed', 'document_completed', 'document_expired', 'document_rejected', 'document_viewed'])),
    email_address VARCHAR NOT NULL,
    subject VARCHAR NOT NULL,
    html_content TEXT,
    text_content TEXT,
    sent_at TIMESTAMPTZ DEFAULT NOW(),
    delivered_at TIMESTAMPTZ,
    opened_at TIMESTAMPTZ,
    clicked_at TIMESTAMPTZ,
    status VARCHAR DEFAULT 'sent' CHECK (status = ANY (ARRAY['sent', 'delivered', 'opened', 'clicked', 'bounced', 'failed'])),
    external_message_id VARCHAR,
    provider VARCHAR DEFAULT 'sendgrid' CHECK (provider = ANY (ARRAY['sendgrid', 'resend', 'ses'])),
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email templates
CREATE TABLE IF NOT EXISTS email_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR UNIQUE NOT NULL,
    template_type VARCHAR NOT NULL CHECK (template_type = ANY (ARRAY['document_invitation', 'signature_reminder', 'document_signed', 'document_completed', 'document_expired', 'document_rejected', 'document_viewed', 'welcome_email', 'password_reset'])),
    subject_template TEXT NOT NULL,
    html_template TEXT NOT NULL,
    text_template TEXT NOT NULL,
    variables JSONB DEFAULT '[]',
    branding_options JSONB DEFAULT '{}',
    locale VARCHAR DEFAULT 'en-NA',
    is_active BOOLEAN DEFAULT TRUE,
    is_default BOOLEAN DEFAULT FALSE,
    created_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- User email preferences
CREATE TABLE IF NOT EXISTS user_email_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    receive_invitations BOOLEAN DEFAULT TRUE,
    receive_reminders BOOLEAN DEFAULT TRUE,
    receive_status_updates BOOLEAN DEFAULT TRUE,
    receive_marketing BOOLEAN DEFAULT FALSE,
    reminder_frequency INTEGER DEFAULT 2 CHECK (reminder_frequency > 0),
    preferred_language VARCHAR DEFAULT 'en-NA',
    timezone VARCHAR DEFAULT 'Africa/Windhoek',
    email_format VARCHAR DEFAULT 'html' CHECK (email_format = ANY (ARRAY['html', 'text'])),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Scheduled reminders
CREATE TABLE IF NOT EXISTS scheduled_reminders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    recipient_id UUID REFERENCES recipients(id) ON DELETE CASCADE,
    reminder_type VARCHAR NOT NULL CHECK (reminder_type = ANY (ARRAY['signature_reminder', 'expiration_warning', 'final_notice'])),
    scheduled_for TIMESTAMPTZ NOT NULL,
    status VARCHAR DEFAULT 'pending' CHECK (status = ANY (ARRAY['pending', 'sent', 'failed', 'cancelled'])),
    attempts INTEGER DEFAULT 0,
    last_attempt_at TIMESTAMPTZ,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email analytics
CREATE TABLE IF NOT EXISTS email_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    date DATE NOT NULL,
    email_type VARCHAR NOT NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    delivery_rate NUMERIC DEFAULT 0.00,
    open_rate NUMERIC DEFAULT 0.00,
    click_rate NUMERIC DEFAULT 0.00,
    bounce_rate NUMERIC DEFAULT 0.00,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email blacklist
CREATE TABLE IF NOT EXISTS email_blacklist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_address VARCHAR UNIQUE NOT NULL,
    reason VARCHAR NOT NULL CHECK (reason = ANY (ARRAY['bounced', 'complained', 'unsubscribed', 'invalid', 'blocked'])),
    blacklisted_at TIMESTAMPTZ DEFAULT NOW(),
    blacklisted_by UUID REFERENCES auth.users(id),
    notes TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email queue
CREATE TABLE IF NOT EXISTS email_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),
    email_data JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ DEFAULT NOW(),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    status VARCHAR DEFAULT 'queued' CHECK (status = ANY (ARRAY['queued', 'processing', 'sent', 'failed', 'cancelled'])),
    error_message TEXT,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    is_manual BOOLEAN DEFAULT FALSE,
    manual_request_id UUID,
    admin_id VARCHAR,
    document_id UUID REFERENCES documents(id),
    recipient_email VARCHAR,
    subject TEXT,
    content JSONB,
    email_type VARCHAR
);

-- Email system configuration
CREATE TABLE IF NOT EXISTS email_system_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_key VARCHAR UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Email providers
CREATE TABLE IF NOT EXISTS email_providers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    provider_name VARCHAR UNIQUE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    configuration JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- PERFORMANCE AND MONITORING TABLES
-- ============================================================================

-- Performance metrics
CREATE TABLE IF NOT EXISTS performance_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    metric_name VARCHAR NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_type VARCHAR DEFAULT 'counter',
    tags JSONB DEFAULT '{}',
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_id UUID REFERENCES auth.users(id),
    document_id UUID REFERENCES documents(id),
    workflow_id UUID REFERENCES kyc_workflows(id),
    ai_method ai_method,
    processing_context JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI model metrics
CREATE TABLE IF NOT EXISTS ai_model_metrics (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    model_name VARCHAR NOT NULL,
    model_version VARCHAR NOT NULL,
    accuracy NUMERIC,
    precision_score NUMERIC,
    recall NUMERIC,
    f1_score NUMERIC,
    avg_confidence NUMERIC,
    avg_processing_time_ms NUMERIC,
    throughput_per_hour INTEGER,
    error_rate NUMERIC,
    total_predictions INTEGER DEFAULT 0,
    successful_predictions INTEGER DEFAULT 0,
    failed_predictions INTEGER DEFAULT 0,
    period_start TIMESTAMPTZ NOT NULL,
    period_end TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- AI confidence metrics
CREATE TABLE IF NOT EXISTS ai_confidence_metrics (
    id UUID PRIMARY KEY DEFAULT extensions.uuid_generate_v4(),
    workflow_id UUID REFERENCES kyc_workflows(id),
    analysis_id UUID REFERENCES ai_analysis(id),
    metric_name VARCHAR NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_weight NUMERIC NOT NULL,
    metric_description TEXT,
    metric_quality VARCHAR,
    ai_method ai_method,
    processing_time_ms INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- User activities
CREATE TABLE IF NOT EXISTS user_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    activity_type VARCHAR NOT NULL,
    activity_data JSONB,
    ip_address INET,
    user_agent TEXT,
    session_id VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Document processing status
CREATE TABLE IF NOT EXISTS document_processing_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    processing_type VARCHAR NOT NULL,
    status VARCHAR NOT NULL,
    progress INTEGER DEFAULT 0,
    metadata JSONB,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- REDIS AND SESSION MANAGEMENT
-- ============================================================================

-- Redis sessions
CREATE TABLE IF NOT EXISTS redis_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id VARCHAR UNIQUE NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    session_data JSONB NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- JWT blacklist
CREATE TABLE IF NOT EXISTS jwt_blacklist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    token_hash VARCHAR UNIQUE NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    expires_at TIMESTAMP NOT NULL,
    blacklisted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason VARCHAR DEFAULT 'logout'
);

-- Background tasks
CREATE TABLE IF NOT EXISTS background_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    queue_name VARCHAR NOT NULL,
    task_type VARCHAR NOT NULL,
    task_data JSONB NOT NULL,
    status VARCHAR DEFAULT 'pending',
    priority INTEGER DEFAULT 0,
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    scheduled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Realtime events
CREATE TABLE IF NOT EXISTS realtime_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR NOT NULL,
    channel VARCHAR,
    user_id UUID REFERENCES auth.users(id),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    event_data JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Rate limit logs
CREATE TABLE IF NOT EXISTS rate_limit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    identifier VARCHAR NOT NULL,
    limit_type VARCHAR NOT NULL,
    request_count INTEGER DEFAULT 1,
    window_start TIMESTAMP NOT NULL,
    window_end TIMESTAMP NOT NULL,
    is_blocked BOOLEAN DEFAULT FALSE,
    ip_address INET,
    user_id UUID REFERENCES auth.users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Redis cache metadata
CREATE TABLE IF NOT EXISTS redis_cache_metadata (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    cache_key VARCHAR NOT NULL,
    cache_type VARCHAR NOT NULL,
    entity_id UUID,
    entity_type VARCHAR,
    ttl_seconds INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,
    last_accessed TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    access_count INTEGER DEFAULT 0
);

-- ============================================================================
-- GOVERNMENT INTEGRATION
-- ============================================================================

-- Government integration
CREATE TABLE IF NOT EXISTS government_integration (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    government_system VARCHAR NOT NULL,
    integration_type VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'active',
    configuration JSONB,
    last_sync_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CRAN accreditation
CREATE TABLE IF NOT EXISTS cran_accreditation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    accreditation_type VARCHAR NOT NULL,
    status VARCHAR DEFAULT 'pending',
    application_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    approval_date TIMESTAMP,
    expiry_date TIMESTAMP,
    certificate_number VARCHAR,
    compliance_score INTEGER,
    audit_results JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Digital certificates
CREATE TABLE IF NOT EXISTS digital_certificates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    certificate_type VARCHAR NOT NULL,
    public_key TEXT NOT NULL,
    private_key_encrypted TEXT NOT NULL,
    certificate_data JSONB NOT NULL,
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    is_revoked BOOLEAN DEFAULT FALSE,
    revocation_reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- MANUAL EMAIL MANAGEMENT
-- ============================================================================

-- Manual email requests
CREATE TABLE IF NOT EXISTS manual_email_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    admin_id VARCHAR NOT NULL,
    admin_name VARCHAR NOT NULL,
    email_type VARCHAR NOT NULL,
    recipients JSONB NOT NULL,
    subject TEXT NOT NULL,
    content JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ,
    priority VARCHAR DEFAULT 'normal',
    reason TEXT NOT NULL,
    status VARCHAR DEFAULT 'pending',
    conflicts JSONB DEFAULT '[]',
    approver_id VARCHAR,
    approver_name VARCHAR,
    approved_at TIMESTAMPTZ,
    rejected_at TIMESTAMPTZ,
    rejection_reason TEXT,
    cancelled_at TIMESTAMPTZ,
    cancellation_reason TEXT,
    cancelled_by VARCHAR,
    sent_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Admin email activity
CREATE TABLE IF NOT EXISTS admin_email_activity (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    admin_id VARCHAR NOT NULL,
    action VARCHAR NOT NULL,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- VALIDATION AND RATE LIMITING TABLES
-- ============================================================================

-- Validation rules table
CREATE TABLE IF NOT EXISTS validation_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name VARCHAR(255) NOT NULL UNIQUE,
    rule_type VARCHAR(50) NOT NULL CHECK (rule_type IN ('email', 'password', 'document', 'signature', 'user_profile')),
    rule_definition JSONB NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Validation results table
CREATE TABLE IF NOT EXISTS validation_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_id UUID NOT NULL REFERENCES validation_rules(id),
    entity_id TEXT NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    is_valid BOOLEAN NOT NULL,
    error_message TEXT,
    validation_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting rules table
CREATE TABLE IF NOT EXISTS rate_limiting_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name VARCHAR(255) NOT NULL UNIQUE,
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting violations table
CREATE TABLE IF NOT EXISTS rate_limiting_violations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES rate_limiting_rules(id),
    violation_count INTEGER DEFAULT 1,
    first_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_blocked BOOLEAN DEFAULT FALSE,
    block_until TIMESTAMP WITH TIME ZONE
);

-- Rate limiting counters table
CREATE TABLE IF NOT EXISTS rate_limiting_counters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES rate_limiting_rules(id),
    counter_value INTEGER DEFAULT 0,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting exemptions table
CREATE TABLE IF NOT EXISTS rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES rate_limiting_rules(id),
    is_active BOOLEAN DEFAULT TRUE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- AUDIT LOGGING TABLES
-- ============================================================================

-- Audit log table
CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(255) NOT NULL,
    record_id TEXT NOT NULL,
    operation VARCHAR(20) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT', 'LOGIN', 'LOGOUT', 'API_CALL', 'EMAIL_SENT', 'DOCUMENT_SIGNED')),
    old_values JSONB,
    new_values JSONB,
    changed_fields TEXT[],
    user_id UUID REFERENCES auth.users(id),
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    event_type VARCHAR(100),
    severity VARCHAR(50) DEFAULT 'INFO' CHECK (severity IN ('INFO', 'WARNING', 'ERROR', 'CRITICAL')),
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Audit config table
CREATE TABLE IF NOT EXISTS audit_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(255) NOT NULL UNIQUE,
    is_enabled BOOLEAN DEFAULT TRUE,
    track_inserts BOOLEAN DEFAULT TRUE,
    track_updates BOOLEAN DEFAULT TRUE,
    track_deletes BOOLEAN DEFAULT TRUE,
    track_selects BOOLEAN DEFAULT FALSE,
    sensitive_fields TEXT[],
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- SENDGRID CONFIGURATION TABLES
-- ============================================================================

-- SendGrid configuration table
CREATE TABLE IF NOT EXISTS sendgrid_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    api_key_encrypted TEXT NOT NULL,
    api_key_hash TEXT NOT NULL,
    from_email TEXT NOT NULL,
    from_name TEXT NOT NULL,
    reply_to_email TEXT,
    reply_to_name TEXT,
    webhook_public_key TEXT,
    webhook_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    environment TEXT DEFAULT 'production' CHECK (environment IN ('sandbox', 'production')),
    rate_limit_per_minute INTEGER DEFAULT 100,
    rate_limit_per_hour INTEGER DEFAULT 1000,
    rate_limit_per_day INTEGER DEFAULT 10000,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid templates table
CREATE TABLE IF NOT EXISTS sendgrid_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL UNIQUE,
    template_name VARCHAR(255) NOT NULL,
    template_type VARCHAR(50) NOT NULL CHECK (template_type IN ('transactional', 'marketing', 'system')),
    subject TEXT,
    html_content TEXT,
    text_content TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SendGrid senders table
CREATE TABLE IF NOT EXISTS sendgrid_senders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id TEXT NOT NULL UNIQUE,
    from_email TEXT NOT NULL,
    from_name TEXT NOT NULL,
    reply_to_email TEXT,
    reply_to_name TEXT,
    address TEXT,
    city TEXT,
    country TEXT,
    is_verified BOOLEAN DEFAULT FALSE,
    verification_status VARCHAR(50),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SendGrid domains table
CREATE TABLE IF NOT EXISTS sendgrid_domains (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL UNIQUE,
    is_verified BOOLEAN DEFAULT FALSE,
    verification_status VARCHAR(50),
    dns_records JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SendGrid IP pools table
CREATE TABLE IF NOT EXISTS sendgrid_ip_pools (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pool_name VARCHAR(255) NOT NULL UNIQUE,
    pool_id TEXT NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SendGrid IPs table
CREATE TABLE IF NOT EXISTS sendgrid_ips (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    pool_id TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    warmup_status VARCHAR(50),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- SendGrid settings table
CREATE TABLE IF NOT EXISTS sendgrid_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    setting_name VARCHAR(255) NOT NULL UNIQUE,
    setting_value JSONB NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- GOOGLE OAUTH INTEGRATION TABLES
-- ============================================================================

-- Google OAuth tokens table
CREATE TABLE IF NOT EXISTS google_oauth_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    access_token TEXT NOT NULL,
    refresh_token TEXT,
    token_type VARCHAR(50) DEFAULT 'Bearer',
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    scope TEXT[],
    is_active BOOLEAN DEFAULT TRUE,
    last_used_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Google OAuth profiles table
CREATE TABLE IF NOT EXISTS google_oauth_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    google_id TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL,
    verified_email BOOLEAN DEFAULT FALSE,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    picture_url TEXT,
    locale VARCHAR(10),
    hd TEXT,
    is_plus_user BOOLEAN DEFAULT FALSE,
    verified BOOLEAN DEFAULT FALSE,
    link TEXT,
    gender TEXT,
    birthday TEXT,
    raw_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Google OAuth sessions table
CREATE TABLE IF NOT EXISTS google_oauth_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    session_id TEXT NOT NULL,
    state TEXT NOT NULL,
    code_verifier TEXT,
    redirect_uri TEXT,
    scope TEXT[],
    is_active BOOLEAN DEFAULT TRUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Google OAuth events table
CREATE TABLE IF NOT EXISTS google_oauth_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    event_type VARCHAR(50) NOT NULL CHECK (event_type IN ('login', 'logout', 'token_refresh', 'token_expired', 'scope_change', 'error')),
    event_data JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    success BOOLEAN NOT NULL,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Google OAuth permissions table
CREATE TABLE IF NOT EXISTS google_oauth_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_scope TEXT NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE NOT NULL,
    revoked_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- SENDGRID WEBHOOKS AND EMAIL TRACKING TABLES
-- ============================================================================

-- SendGrid webhook events table
CREATE TABLE IF NOT EXISTS sendgrid_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id TEXT NOT NULL UNIQUE,
    event_type TEXT NOT NULL,
    email TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    sg_message_id TEXT,
    sg_event_id TEXT,
    sg_template_id TEXT,
    sg_template_name TEXT,
    response TEXT,
    attempt INTEGER,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    reason TEXT,
    status TEXT,
    category TEXT[],
    unique_args JSONB,
    marketing_campaign_id TEXT,
    marketing_campaign_name TEXT,
    raw_data JSONB NOT NULL,
    processed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email delivery status table
CREATE TABLE IF NOT EXISTS email_delivery_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_queue_id UUID,
    sendgrid_message_id TEXT,
    recipient_email TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'dropped', 'spam', 'unsubscribed', 'processed', 'deferred', 'blocked')),
    event_type TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    reason TEXT,
    response TEXT,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    category TEXT[],
    unique_args JSONB,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email bounces table
CREATE TABLE IF NOT EXISTS email_bounces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    bounce_type TEXT NOT NULL CHECK (bounce_type IN ('hard', 'soft', 'block', 'spam', 'invalid')),
    bounce_reason TEXT,
    bounce_code TEXT,
    bounce_description TEXT,
    first_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    last_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    bounce_count INTEGER DEFAULT 1,
    is_suppressed BOOLEAN DEFAULT FALSE,
    suppression_reason TEXT,
    suppressed_at TIMESTAMP WITH TIME ZONE,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email suppressions table
CREATE TABLE IF NOT EXISTS email_suppressions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    suppression_type TEXT NOT NULL CHECK (suppression_type IN ('bounce', 'block', 'spam', 'unsubscribe', 'group_unsubscribe', 'manual')),
    reason TEXT,
    source TEXT DEFAULT 'sendgrid',
    is_active BOOLEAN DEFAULT TRUE,
    suppressed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    unsuppressed_at TIMESTAMP WITH TIME ZONE,
    unsuppressed_by UUID REFERENCES auth.users(id),
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email unsubscribes table
CREATE TABLE IF NOT EXISTS email_unsubscribes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    unsubscribe_type TEXT NOT NULL CHECK (unsubscribe_type IN ('one_click', 'group', 'manual')),
    unsubscribe_source TEXT,
    user_id UUID REFERENCES auth.users(id),
    campaign_id TEXT,
    template_id TEXT,
    unsubscribed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email link tracking table
CREATE TABLE IF NOT EXISTS email_link_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    link_url TEXT NOT NULL,
    link_id TEXT NOT NULL,
    email_id TEXT,
    campaign_id TEXT,
    template_id TEXT,
    click_count INTEGER DEFAULT 0,
    unique_click_count INTEGER DEFAULT 0,
    first_clicked_at TIMESTAMP WITH TIME ZONE,
    last_clicked_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email open tracking table
CREATE TABLE IF NOT EXISTS email_open_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    opened_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email click tracking table
CREATE TABLE IF NOT EXISTS email_click_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    link_url TEXT NOT NULL,
    clicked_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- EMAIL ANALYTICS TABLES
-- ============================================================================

-- Email analytics table
CREATE TABLE IF NOT EXISTS email_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    date DATE NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_type TEXT NOT NULL CHECK (metric_type IN ('count', 'rate', 'percentage', 'duration', 'amount')),
    category TEXT NOT NULL,
    subcategory TEXT,
    dimensions JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email campaign analytics table
CREATE TABLE IF NOT EXISTS email_campaign_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id TEXT NOT NULL,
    campaign_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    emails_spam_reported INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email template analytics table
CREATE TABLE IF NOT EXISTS email_template_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    template_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email domain analytics table
CREATE TABLE IF NOT EXISTS email_domain_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email IP analytics table
CREATE TABLE IF NOT EXISTS email_ip_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email link analytics table
CREATE TABLE IF NOT EXISTS email_link_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    link_url TEXT NOT NULL,
    link_id TEXT NOT NULL,
    date DATE NOT NULL,
    click_count INTEGER DEFAULT 0,
    unique_click_count INTEGER DEFAULT 0,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    first_clicked_at TIMESTAMP WITH TIME ZONE,
    last_clicked_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email geographic analytics table
CREATE TABLE IF NOT EXISTS email_geographic_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    country TEXT NOT NULL,
    region TEXT,
    city TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Email device analytics table
CREATE TABLE IF NOT EXISTS email_device_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    device_type TEXT NOT NULL,
    browser_type TEXT,
    os_type TEXT,
    date DATE NOT NULL,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- NOTIFICATION SYSTEM TABLES
-- ============================================================================

-- Notification templates table
CREATE TABLE IF NOT EXISTS notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) NOT NULL UNIQUE,
    template_type VARCHAR(50) NOT NULL CHECK (template_type IN ('email', 'sms', 'push', 'in_app')),
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification queue table
CREATE TABLE IF NOT EXISTS notification_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('email', 'sms', 'push', 'in_app')),
    template_id UUID REFERENCES notification_templates(id) ON DELETE CASCADE,
    recipient VARCHAR(255) NOT NULL,
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),
    scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'sent', 'delivered', 'failed', 'cancelled')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    error_message TEXT,
    sent_at TIMESTAMP WITH TIME ZONE,
    delivered_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification preferences table
CREATE TABLE IF NOT EXISTS notification_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL UNIQUE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT TRUE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    email_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (email_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    sms_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (sms_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    push_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (push_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    in_app_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (in_app_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    timezone VARCHAR(50) DEFAULT 'Africa/Windhoek',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification delivery logs table
CREATE TABLE IF NOT EXISTS notification_delivery_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    notification_id UUID NOT NULL REFERENCES notification_queue(id) ON DELETE CASCADE,
    delivery_status VARCHAR(20) NOT NULL CHECK (delivery_status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'failed')),
    delivery_provider VARCHAR(100),
    provider_message_id VARCHAR(255),
    delivery_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    error_code VARCHAR(50),
    error_message TEXT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification campaigns table
CREATE TABLE IF NOT EXISTS notification_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_name VARCHAR(255) NOT NULL,
    campaign_type VARCHAR(50) NOT NULL CHECK (campaign_type IN ('marketing', 'transactional', 'promotional', 'system')),
    template_id UUID NOT NULL REFERENCES notification_templates(id) ON DELETE CASCADE,
    target_audience JSONB,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'running', 'completed', 'cancelled')),
    total_recipients INTEGER DEFAULT 0,
    sent_count INTEGER DEFAULT 0,
    delivered_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- In-app notifications table
CREATE TABLE IF NOT EXISTS in_app_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('info', 'success', 'warning', 'error', 'system')),
    action_url TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- TEAM MANAGEMENT TABLES
-- ============================================================================

-- Teams table
CREATE TABLE IF NOT EXISTS teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team members table
CREATE TABLE IF NOT EXISTS team_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL,
    role VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
    permissions JSONB DEFAULT '{}',
    invited_by TEXT,
    invited_at TIMESTAMP WITH TIME ZONE,
    joined_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(team_id, user_id)
);

-- Team invitations table
CREATE TABLE IF NOT EXISTS team_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    role VARCHAR(50) NOT NULL CHECK (role IN ('admin', 'member', 'viewer')),
    invited_by TEXT NOT NULL,
    invitation_token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
    accepted_at TIMESTAMP WITH TIME ZONE,
    declined_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team activity logs table
CREATE TABLE IF NOT EXISTS team_activity_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL,
    activity_type VARCHAR(50) NOT NULL CHECK (activity_type IN ('member_added', 'member_removed', 'member_role_changed', 'team_updated', 'document_shared', 'document_signed', 'workflow_created', 'workflow_completed')),
    activity_description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team document permissions table
CREATE TABLE IF NOT EXISTS team_document_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    permission_type VARCHAR(50) NOT NULL CHECK (permission_type IN ('view', 'edit', 'sign', 'admin')),
    granted_by TEXT NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- WORKFLOW MANAGEMENT TABLES
-- ============================================================================

-- Workflows table
CREATE TABLE IF NOT EXISTS workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    workflow_type VARCHAR(50) NOT NULL CHECK (workflow_type IN ('document_approval', 'signature_sequence', 'compliance_review', 'automated_processing', 'custom')),
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'completed', 'cancelled')),
    created_by TEXT NOT NULL,
    team_id UUID REFERENCES teams(id),
    settings JSONB DEFAULT '{}',
    is_template BOOLEAN DEFAULT FALSE,
    template_name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow steps table
CREATE TABLE IF NOT EXISTS workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(255) NOT NULL,
    step_type VARCHAR(50) NOT NULL CHECK (step_type IN ('approval', 'signature', 'review', 'notification', 'automated_action', 'conditional', 'parallel', 'sequential')),
    step_order INTEGER NOT NULL,
    assigned_to TEXT,
    assigned_role VARCHAR(50),
    assigned_team_id UUID REFERENCES teams(id),
    conditions JSONB DEFAULT '{}',
    actions JSONB DEFAULT '{}',
    timeout_hours INTEGER,
    is_required BOOLEAN DEFAULT TRUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow instances table
CREATE TABLE IF NOT EXISTS workflow_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflows(id),
    document_id UUID REFERENCES documents(id),
    name VARCHAR(255) NOT NULL,
    status VARCHAR(20) DEFAULT 'running' CHECK (status IN ('running', 'paused', 'completed', 'cancelled', 'failed')),
    started_by TEXT NOT NULL,
    started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE,
    current_step_id UUID REFERENCES workflow_steps(id),
    context_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow step executions table
CREATE TABLE IF NOT EXISTS workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_instance_id UUID NOT NULL REFERENCES workflow_instances(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped', 'failed', 'cancelled')),
    assigned_to TEXT,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    result_data JSONB DEFAULT '{}',
    comments TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow templates table
CREATE TABLE IF NOT EXISTS workflow_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) NOT NULL,
    description TEXT,
    workflow_type VARCHAR(50) NOT NULL,
    template_data JSONB NOT NULL,
    is_public BOOLEAN DEFAULT FALSE,
    created_by TEXT NOT NULL,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- INDEXES FOR PERFORMANCE
-- ============================================================================

-- Document indexes
CREATE INDEX IF NOT EXISTS idx_documents_created_by ON documents(created_by);
CREATE INDEX IF NOT EXISTS idx_documents_status ON documents(status);
CREATE INDEX IF NOT EXISTS idx_documents_created_at ON documents(created_at);

-- Signature indexes
CREATE INDEX IF NOT EXISTS idx_signatures_document_id ON signatures(document_id);
CREATE INDEX IF NOT EXISTS idx_signatures_recipient_id ON signatures(recipient_id);
CREATE INDEX IF NOT EXISTS idx_signatures_created_at ON signatures(created_at);

-- User activity indexes
CREATE INDEX IF NOT EXISTS idx_user_activities_user_id ON user_activities(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activities_activity_type ON user_activities(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activities_created_at ON user_activities(created_at);

-- Email indexes
CREATE INDEX IF NOT EXISTS idx_email_notifications_document_id ON email_notifications(document_id);
CREATE INDEX IF NOT EXISTS idx_email_notifications_email_type ON email_notifications(email_type);
CREATE INDEX IF NOT EXISTS idx_email_notifications_sent_at ON email_notifications(sent_at);

-- KYC workflow indexes
CREATE INDEX IF NOT EXISTS idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX IF NOT EXISTS idx_kyc_workflows_workflow_state ON kyc_workflows(workflow_state);
CREATE INDEX IF NOT EXISTS idx_kyc_workflows_detected_country ON kyc_workflows(detected_country);

-- Performance metrics indexes
CREATE INDEX IF NOT EXISTS idx_performance_metrics_metric_name ON performance_metrics(metric_name);
CREATE INDEX IF NOT EXISTS idx_performance_metrics_timestamp ON performance_metrics(timestamp);
CREATE INDEX IF NOT EXISTS idx_performance_metrics_user_id ON performance_metrics(user_id);

-- Audit trail indexes
CREATE INDEX IF NOT EXISTS idx_audit_trail_document_id ON audit_trail(document_id);
CREATE INDEX IF NOT EXISTS idx_audit_trail_user_id ON audit_trail(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_trail_created_at ON audit_trail(created_at);

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE profiles IS 'User profiles extending auth.users with BuffrSign-specific fields';
COMMENT ON TABLE documents IS 'Main documents table for document management and signing';
COMMENT ON TABLE signatures IS 'Digital signatures with AI analysis and compliance tracking';
COMMENT ON TABLE ai_analysis IS 'AI-powered document analysis results';
COMMENT ON TABLE kyc_workflows IS 'KYC workflow tracking with SADC country support';
COMMENT ON TABLE email_notifications IS 'Email notification tracking and analytics';
COMMENT ON TABLE performance_metrics IS 'AI and system performance metrics for monitoring';
COMMENT ON TABLE audit_trail IS 'Comprehensive audit trail for compliance and security';
COMMENT ON TABLE validation_rules IS 'Data validation rules and integrity constraints';
COMMENT ON TABLE rate_limiting_rules IS 'Rate limiting rules for API and user actions';
COMMENT ON TABLE audit_log IS 'Comprehensive audit logging for all system activities';
COMMENT ON TABLE sendgrid_config IS 'SendGrid email service configuration and settings';
COMMENT ON TABLE google_oauth_tokens IS 'Google OAuth token storage and management';
COMMENT ON TABLE sendgrid_webhook_events IS 'SendGrid webhook events and email tracking';
COMMENT ON TABLE email_analytics IS 'Email analytics and performance metrics';
COMMENT ON TABLE notification_templates IS 'Notification templates for different message types';
COMMENT ON TABLE teams IS 'Teams for collaboration and document sharing';
COMMENT ON TABLE workflows IS 'Document workflow definitions and templates';
\n-- End of buffrsign-starter/sql/0-all-tables.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- ============================================================================
-- Row Level Security (RLS) Policies for User Profiles and Authentication
-- ============================================================================
-- This file contains RLS policies for user profile management and authentication
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- ENABLE ROW LEVEL SECURITY
-- ============================================================================

-- Enable RLS on profiles table
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Enable RLS on user_activities table
ALTER TABLE user_activities ENABLE ROW LEVEL SECURITY;

-- Enable RLS on user_email_preferences table
ALTER TABLE user_email_preferences ENABLE ROW LEVEL SECURITY;

-- Enable RLS on notifications table
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Enable RLS on api_keys table
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

-- Enable RLS on security_events table
ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- PROFILES TABLE POLICIES
-- ============================================================================

-- Users can view their own profile
CREATE POLICY "Users can view own profile" ON profiles
    FOR SELECT USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile" ON profiles
    FOR UPDATE USING (auth.uid() = id);

-- Users can insert their own profile (handled by trigger)
CREATE POLICY "Users can insert own profile" ON profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- Admins can view all profiles
CREATE POLICY "Admins can view all profiles" ON profiles
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Admins can update user profiles
CREATE POLICY "Admins can update user profiles" ON profiles
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Super admins can manage all profiles including other admins
CREATE POLICY "Super admins can manage all profiles" ON profiles
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role = 'super_admin'
        )
    );

-- ============================================================================
-- USER ACTIVITIES TABLE POLICIES
-- ============================================================================

-- Users can view their own activities
CREATE POLICY "Users can view own activities" ON user_activities
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own activities
CREATE POLICY "Users can insert own activities" ON user_activities
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Admins can view all user activities
CREATE POLICY "Admins can view all activities" ON user_activities
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- System can insert activities for any user (for automated logging)
CREATE POLICY "System can insert activities" ON user_activities
    FOR INSERT WITH CHECK (true);

-- ============================================================================
-- USER EMAIL PREFERENCES TABLE POLICIES
-- ============================================================================

-- Users can view their own email preferences
CREATE POLICY "Users can view own email preferences" ON user_email_preferences
    FOR SELECT USING (auth.uid() = user_id);

-- Users can update their own email preferences
CREATE POLICY "Users can update own email preferences" ON user_email_preferences
    FOR UPDATE USING (auth.uid() = user_id);

-- Users can insert their own email preferences
CREATE POLICY "Users can insert own email preferences" ON user_email_preferences
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Admins can view all email preferences
CREATE POLICY "Admins can view all email preferences" ON user_email_preferences
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Admins can update email preferences
CREATE POLICY "Admins can update email preferences" ON user_email_preferences
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- NOTIFICATIONS TABLE POLICIES
-- ============================================================================

-- Users can view their own notifications
CREATE POLICY "Users can view own notifications" ON notifications
    FOR SELECT USING (auth.uid() = user_id);

-- Users can update their own notifications (mark as read)
CREATE POLICY "Users can update own notifications" ON notifications
    FOR UPDATE USING (auth.uid() = user_id);

-- System can insert notifications for any user
CREATE POLICY "System can insert notifications" ON notifications
    FOR INSERT WITH CHECK (true);

-- Admins can view all notifications
CREATE POLICY "Admins can view all notifications" ON notifications
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- API KEYS TABLE POLICIES
-- ============================================================================

-- Users can view their own API keys
CREATE POLICY "Users can view own API keys" ON api_keys
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own API keys
CREATE POLICY "Users can insert own API keys" ON api_keys
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own API keys
CREATE POLICY "Users can update own API keys" ON api_keys
    FOR UPDATE USING (auth.uid() = user_id);

-- Users can delete their own API keys
CREATE POLICY "Users can delete own API keys" ON api_keys
    FOR DELETE USING (auth.uid() = user_id);

-- Admins can view all API keys
CREATE POLICY "Admins can view all API keys" ON api_keys
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Admins can manage all API keys
CREATE POLICY "Admins can manage all API keys" ON api_keys
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- SECURITY EVENTS TABLE POLICIES
-- ============================================================================

-- Users can view their own security events
CREATE POLICY "Users can view own security events" ON security_events
    FOR SELECT USING (auth.uid() = user_id);

-- System can insert security events for any user
CREATE POLICY "System can insert security events" ON security_events
    FOR INSERT WITH CHECK (true);

-- Admins can view all security events
CREATE POLICY "Admins can view all security events" ON security_events
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- HELPER FUNCTIONS FOR RLS
-- ============================================================================

-- Function to check if user is admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM profiles 
        WHERE id = auth.uid() 
        AND role IN ('admin', 'super_admin')
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user is super admin
CREATE OR REPLACE FUNCTION is_super_admin()
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM profiles 
        WHERE id = auth.uid() 
        AND role = 'super_admin'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user has specific permission
CREATE OR REPLACE FUNCTION has_permission(permission_name TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM profiles 
        WHERE id = auth.uid() 
        AND (
            CASE permission_name
                WHEN 'can_manage_users' THEN can_manage_users
                WHEN 'can_manage_documents' THEN can_manage_documents
                WHEN 'can_manage_compliance' THEN can_manage_compliance
                WHEN 'can_view_analytics' THEN can_view_analytics
                WHEN 'can_manage_settings' THEN can_manage_settings
                WHEN 'can_access_admin_panel' THEN can_access_admin_panel
                WHEN 'can_manage_super_admins' THEN can_manage_super_admins
                WHEN 'can_manage_kyc' THEN can_manage_kyc
                WHEN 'can_manage_templates' THEN can_manage_templates
                ELSE FALSE
            END
        )
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user role
CREATE OR REPLACE FUNCTION get_user_role()
RETURNS TEXT AS $$
BEGIN
    RETURN (
        SELECT role::TEXT FROM profiles 
        WHERE id = auth.uid()
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- GRANT PERMISSIONS
-- ============================================================================

-- Grant usage on sequences
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- Grant select on profiles for authenticated users
GRANT SELECT ON profiles TO authenticated;

-- Grant select on user_activities for authenticated users
GRANT SELECT ON user_activities TO authenticated;

-- Grant select on user_email_preferences for authenticated users
GRANT SELECT ON user_email_preferences TO authenticated;

-- Grant select on notifications for authenticated users
GRANT SELECT ON notifications TO authenticated;

-- Grant select on api_keys for authenticated users
GRANT SELECT ON api_keys TO authenticated;

-- Grant select on security_events for authenticated users
GRANT SELECT ON security_events TO authenticated;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON POLICY "Users can view own profile" ON profiles IS 'Allows users to view their own profile data';
COMMENT ON POLICY "Users can update own profile" ON profiles IS 'Allows users to update their own profile data';
COMMENT ON POLICY "Admins can view all profiles" ON profiles IS 'Allows admins to view all user profiles';
COMMENT ON POLICY "Users can view own activities" ON user_activities IS 'Allows users to view their own activity logs';
COMMENT ON POLICY "Users can view own email preferences" ON user_email_preferences IS 'Allows users to view their own email preferences';
COMMENT ON POLICY "Users can update own email preferences" ON user_email_preferences IS 'Allows users to update their own email preferences';
COMMENT ON POLICY "Users can view own notifications" ON notifications IS 'Allows users to view their own notifications';
COMMENT ON POLICY "Users can view own API keys" ON api_keys IS 'Allows users to view their own API keys';
COMMENT ON POLICY "Users can view own security events" ON security_events IS 'Allows users to view their own security events';

COMMENT ON FUNCTION is_admin() IS 'Checks if current user is an admin or super admin';
COMMENT ON FUNCTION is_super_admin() IS 'Checks if current user is a super admin';
COMMENT ON FUNCTION has_permission(TEXT) IS 'Checks if current user has specific permission';
COMMENT ON FUNCTION get_user_role() IS 'Returns current user role';
\n-- End of buffrsign-starter/sql/2-user_profiles_requests_rls.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- ============================================================================
-- AI Analysis and KYC Workflow Management
-- ============================================================================
-- This file contains AI analysis functions and KYC workflow management
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- AI ANALYSIS FUNCTIONS
-- ============================================================================

-- Function to create AI analysis record
CREATE OR REPLACE FUNCTION create_ai_analysis(
    p_document_id UUID,
    p_analysis_type VARCHAR DEFAULT 'comprehensive',
    p_kyc_workflow_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    analysis_id UUID;
BEGIN
    INSERT INTO ai_analysis (
        document_id,
        analysis_type,
        kyc_workflow_id,
        primary_ocr_method,
        fallback_methods,
        extracted_fields,
        field_confidences,
        analysis_metadata
    ) VALUES (
        p_document_id,
        p_analysis_type,
        p_kyc_workflow_id,
        'pydantic_ai_agent',
        ARRAY['gpt4_vision', 'google_vision', 'azure_vision']::ai_method[],
        '{}'::JSONB,
        '{}'::JSONB,
        jsonb_build_object(
            'created_at', NOW(),
            'analysis_type', p_analysis_type,
            'workflow_id', p_kyc_workflow_id
        )
    ) RETURNING id INTO analysis_id;
    
    RETURN analysis_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update AI analysis results
CREATE OR REPLACE FUNCTION update_ai_analysis_results(
    p_analysis_id UUID,
    p_document_summary TEXT,
    p_key_clauses JSONB,
    p_signature_fields JSONB,
    p_compliance_score INTEGER,
    p_eta_compliance JSONB,
    p_recommendations JSONB,
    p_risk_assessment JSONB,
    p_confidence_scores JSONB,
    p_processing_time_ms INTEGER
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE ai_analysis
    SET 
        document_summary = p_document_summary,
        key_clauses = p_key_clauses,
        signature_fields = p_signature_fields,
        compliance_score = p_compliance_score,
        eta_compliance = p_eta_compliance,
        recommendations = p_recommendations,
        risk_assessment = p_risk_assessment,
        confidence_scores = p_confidence_scores,
        processing_time_ms = p_processing_time_ms,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_analysis_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get AI analysis results
CREATE OR REPLACE FUNCTION get_ai_analysis_results(p_document_id UUID)
RETURNS TABLE(
    analysis_id UUID,
    analysis_type VARCHAR,
    document_summary TEXT,
    key_clauses JSONB,
    signature_fields JSONB,
    compliance_score INTEGER,
    eta_compliance JSONB,
    recommendations JSONB,
    risk_assessment JSONB,
    confidence_scores JSONB,
    processing_time_ms INTEGER,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        aa.id,
        aa.analysis_type,
        aa.document_summary,
        aa.key_clauses,
        aa.signature_fields,
        aa.compliance_score,
        aa.eta_compliance,
        aa.recommendations,
        aa.risk_assessment,
        aa.confidence_scores,
        aa.processing_time_ms,
        aa.created_at
    FROM ai_analysis aa
    WHERE aa.document_id = p_document_id
    ORDER BY aa.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- KYC WORKFLOW FUNCTIONS
-- ============================================================================

-- Function to create KYC workflow
CREATE OR REPLACE FUNCTION create_kyc_workflow(
    p_user_id UUID,
    p_document_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    workflow_id UUID;
BEGIN
    INSERT INTO kyc_workflows (
        user_id,
        document_id,
        workflow_state,
        ocr_extraction,
        ai_field_extraction,
        sadc_validation,
        compliance_status,
        audit_trail
    ) VALUES (
        p_user_id,
        p_document_id,
        'initialized',
        '{}'::JSONB,
        '{}'::JSONB,
        '{}'::JSONB,
        '{}'::JSONB,
        '[]'::JSONB
    ) RETURNING id INTO workflow_id;
    
    RETURN workflow_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update KYC workflow state
CREATE OR REPLACE FUNCTION update_kyc_workflow_state(
    p_workflow_id UUID,
    p_new_state kyc_workflow_state,
    p_metadata JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
    old_state kyc_workflow_state;
BEGIN
    -- Get current state
    SELECT workflow_state INTO old_state
    FROM kyc_workflows
    WHERE id = p_workflow_id;
    
    -- Update workflow state
    UPDATE kyc_workflows
    SET 
        workflow_state = p_new_state,
        updated_at = NOW(),
        audit_trail = audit_trail || jsonb_build_object(
            'timestamp', NOW(),
            'from_state', old_state,
            'to_state', p_new_state,
            'metadata', COALESCE(p_metadata, '{}'::JSONB)
        )
    WHERE id = p_workflow_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to update KYC workflow results
CREATE OR REPLACE FUNCTION update_kyc_workflow_results(
    p_workflow_id UUID,
    p_detected_country CHAR(2),
    p_country_confidence NUMERIC,
    p_country_detection_method ai_method,
    p_ocr_extraction JSONB,
    p_ai_field_extraction JSONB,
    p_sadc_validation JSONB,
    p_final_decision kyc_decision,
    p_decision_confidence NUMERIC,
    p_rejection_reasons TEXT[],
    p_processing_time_ms INTEGER
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE kyc_workflows
    SET 
        detected_country = p_detected_country,
        country_confidence = p_country_confidence,
        country_detection_method = p_country_detection_method,
        ocr_extraction = p_ocr_extraction,
        ai_field_extraction = p_ai_field_extraction,
        sadc_validation = p_sadc_validation,
        final_decision = p_final_decision,
        decision_confidence = p_decision_confidence,
        rejection_reasons = p_rejection_reasons,
        processing_time_ms = p_processing_time_ms,
        updated_at = NOW()
    WHERE id = p_workflow_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get KYC workflow status
CREATE OR REPLACE FUNCTION get_kyc_workflow_status(p_workflow_id UUID)
RETURNS TABLE(
    workflow_id UUID,
    user_id UUID,
    document_id UUID,
    workflow_state kyc_workflow_state,
    detected_country CHAR(2),
    country_confidence NUMERIC,
    final_decision kyc_decision,
    decision_confidence NUMERIC,
    processing_time_ms INTEGER,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        kw.id,
        kw.user_id,
        kw.document_id,
        kw.workflow_state,
        kw.detected_country,
        kw.country_confidence,
        kw.final_decision,
        kw.decision_confidence,
        kw.processing_time_ms,
        kw.created_at,
        kw.updated_at
    FROM kyc_workflows kw
    WHERE kw.id = p_workflow_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- KYC ANALYSIS STEPS FUNCTIONS
-- ============================================================================

-- Function to create KYC analysis step
CREATE OR REPLACE FUNCTION create_kyc_analysis_step(
    p_workflow_id UUID,
    p_step_name VARCHAR,
    p_step_order INTEGER,
    p_ai_method ai_method DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    step_id UUID;
BEGIN
    INSERT INTO kyc_analysis_steps (
        workflow_id,
        step_name,
        step_order,
        status,
        ai_method,
        input_data,
        output_data
    ) VALUES (
        p_workflow_id,
        p_step_name,
        p_step_order,
        'pending',
        p_ai_method,
        '{}'::JSONB,
        '{}'::JSONB
    ) RETURNING id INTO step_id;
    
    RETURN step_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update KYC analysis step
CREATE OR REPLACE FUNCTION update_kyc_analysis_step(
    p_step_id UUID,
    p_status VARCHAR,
    p_confidence_score NUMERIC DEFAULT NULL,
    p_processing_time_ms INTEGER DEFAULT NULL,
    p_output_data JSONB DEFAULT NULL,
    p_error_details JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE kyc_analysis_steps
    SET 
        status = p_status,
        confidence_score = p_confidence_score,
        processing_time_ms = p_processing_time_ms,
        output_data = COALESCE(p_output_data, output_data),
        error_details = COALESCE(p_error_details, error_details),
        started_at = CASE WHEN p_status = 'processing' AND started_at IS NULL THEN NOW() ELSE started_at END,
        completed_at = CASE WHEN p_status IN ('completed', 'failed') THEN NOW() ELSE completed_at END
    WHERE id = p_step_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get KYC analysis steps
CREATE OR REPLACE FUNCTION get_kyc_analysis_steps(p_workflow_id UUID)
RETURNS TABLE(
    step_id UUID,
    step_name VARCHAR,
    step_order INTEGER,
    status VARCHAR,
    ai_method ai_method,
    confidence_score NUMERIC,
    processing_time_ms INTEGER,
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        kas.id,
        kas.step_name,
        kas.step_order,
        kas.status,
        kas.ai_method,
        kas.confidence_score,
        kas.processing_time_ms,
        kas.started_at,
        kas.completed_at
    FROM kyc_analysis_steps kas
    WHERE kas.workflow_id = p_workflow_id
    ORDER BY kas.step_order;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- USER KYC STATUS FUNCTIONS
-- ============================================================================

-- Function to update user KYC status
CREATE OR REPLACE FUNCTION update_user_kyc_status(
    p_user_id UUID,
    p_kyc_status VARCHAR,
    p_kyc_level INTEGER DEFAULT NULL,
    p_latest_workflow_id UUID DEFAULT NULL,
    p_verification_date TIMESTAMPTZ DEFAULT NULL,
    p_expiry_date TIMESTAMPTZ DEFAULT NULL,
    p_compliance_level VARCHAR DEFAULT NULL,
    p_risk_score NUMERIC DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    INSERT INTO user_kyc_status (
        user_id,
        kyc_status,
        kyc_level,
        latest_workflow_id,
        verification_date,
        expiry_date,
        compliance_level,
        risk_score
    ) VALUES (
        p_user_id,
        p_kyc_status,
        p_kyc_level,
        p_latest_workflow_id,
        p_verification_date,
        p_expiry_date,
        p_compliance_level,
        p_risk_score
    )
    ON CONFLICT (user_id) 
    DO UPDATE SET
        kyc_status = EXCLUDED.kyc_status,
        kyc_level = COALESCE(EXCLUDED.kyc_level, user_kyc_status.kyc_level),
        latest_workflow_id = COALESCE(EXCLUDED.latest_workflow_id, user_kyc_status.latest_workflow_id),
        verification_date = COALESCE(EXCLUDED.verification_date, user_kyc_status.verification_date),
        expiry_date = COALESCE(EXCLUDED.expiry_date, user_kyc_status.expiry_date),
        compliance_level = COALESCE(EXCLUDED.compliance_level, user_kyc_status.compliance_level),
        risk_score = COALESCE(EXCLUDED.risk_score, user_kyc_status.risk_score),
        updated_at = NOW();
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get user KYC status
CREATE OR REPLACE FUNCTION get_user_kyc_status(p_user_id UUID)
RETURNS TABLE(
    user_id UUID,
    kyc_status VARCHAR,
    kyc_level INTEGER,
    verification_date TIMESTAMPTZ,
    expiry_date TIMESTAMPTZ,
    compliance_level VARCHAR,
    risk_score NUMERIC,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        uks.user_id,
        uks.kyc_status,
        uks.kyc_level,
        uks.verification_date,
        uks.expiry_date,
        uks.compliance_level,
        uks.risk_score,
        uks.created_at
    FROM user_kyc_status uks
    WHERE uks.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- AI CONFIDENCE METRICS FUNCTIONS
-- ============================================================================

-- Function to record AI confidence metrics
CREATE OR REPLACE FUNCTION record_ai_confidence_metrics(
    p_workflow_id UUID,
    p_analysis_id UUID,
    p_metric_name VARCHAR,
    p_metric_value NUMERIC,
    p_metric_weight NUMERIC,
    p_metric_description TEXT,
    p_metric_quality VARCHAR,
    p_ai_method ai_method,
    p_processing_time_ms INTEGER
)
RETURNS UUID AS $$
DECLARE
    metric_id UUID;
BEGIN
    INSERT INTO ai_confidence_metrics (
        workflow_id,
        analysis_id,
        metric_name,
        metric_value,
        metric_weight,
        metric_description,
        metric_quality,
        ai_method,
        processing_time_ms
    ) VALUES (
        p_workflow_id,
        p_analysis_id,
        p_metric_name,
        p_metric_value,
        p_metric_weight,
        p_metric_description,
        p_metric_quality,
        p_ai_method,
        p_processing_time_ms
    ) RETURNING id INTO metric_id;
    
    RETURN metric_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get AI confidence metrics
CREATE OR REPLACE FUNCTION get_ai_confidence_metrics(
    p_workflow_id UUID DEFAULT NULL,
    p_analysis_id UUID DEFAULT NULL
)
RETURNS TABLE(
    metric_id UUID,
    metric_name VARCHAR,
    metric_value NUMERIC,
    metric_weight NUMERIC,
    metric_description TEXT,
    metric_quality VARCHAR,
    ai_method ai_method,
    processing_time_ms INTEGER,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        acm.id,
        acm.metric_name,
        acm.metric_value,
        acm.metric_weight,
        acm.metric_description,
        acm.metric_quality,
        acm.ai_method,
        acm.processing_time_ms,
        acm.created_at
    FROM ai_confidence_metrics acm
    WHERE (p_workflow_id IS NULL OR acm.workflow_id = p_workflow_id)
    AND (p_analysis_id IS NULL OR acm.analysis_id = p_analysis_id)
    ORDER BY acm.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION create_ai_analysis(UUID, VARCHAR, UUID) IS 'Creates new AI analysis record for document';
COMMENT ON FUNCTION update_ai_analysis_results(UUID, TEXT, JSONB, JSONB, INTEGER, JSONB, JSONB, JSONB, JSONB, INTEGER) IS 'Updates AI analysis results with findings';
COMMENT ON FUNCTION get_ai_analysis_results(UUID) IS 'Retrieves AI analysis results for document';
COMMENT ON FUNCTION create_kyc_workflow(UUID, UUID) IS 'Creates new KYC workflow for user';
COMMENT ON FUNCTION update_kyc_workflow_state(UUID, kyc_workflow_state, JSONB) IS 'Updates KYC workflow state with audit trail';
COMMENT ON FUNCTION update_kyc_workflow_results(UUID, CHAR, NUMERIC, ai_method, JSONB, JSONB, JSONB, kyc_decision, NUMERIC, TEXT[], INTEGER) IS 'Updates KYC workflow with analysis results';
COMMENT ON FUNCTION get_kyc_workflow_status(UUID) IS 'Retrieves KYC workflow status and results';
COMMENT ON FUNCTION create_kyc_analysis_step(UUID, VARCHAR, INTEGER, ai_method) IS 'Creates new KYC analysis step';
COMMENT ON FUNCTION update_kyc_analysis_step(UUID, VARCHAR, NUMERIC, INTEGER, JSONB, JSONB) IS 'Updates KYC analysis step with results';
COMMENT ON FUNCTION get_kyc_analysis_steps(UUID) IS 'Retrieves all KYC analysis steps for workflow';
COMMENT ON FUNCTION update_user_kyc_status(UUID, VARCHAR, INTEGER, UUID, TIMESTAMPTZ, TIMESTAMPTZ, VARCHAR, NUMERIC) IS 'Updates user KYC verification status';
COMMENT ON FUNCTION get_user_kyc_status(UUID) IS 'Retrieves user KYC status and verification details';
COMMENT ON FUNCTION record_ai_confidence_metrics(UUID, UUID, VARCHAR, NUMERIC, NUMERIC, TEXT, VARCHAR, ai_method, INTEGER) IS 'Records AI confidence metrics for analysis';
COMMENT ON FUNCTION get_ai_confidence_metrics(UUID, UUID) IS 'Retrieves AI confidence metrics for workflow or analysis';
\n-- End of buffrsign-starter/sql/6-ai_analysis_kyc.sql --\n
-- =====================================================
-- BuffrSign Workflow Management System
-- =====================================================
-- Description: Document workflow automation and management
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- WORKFLOW MANAGEMENT TABLES
-- =====================================================

-- Workflows table
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    workflow_type VARCHAR(50) NOT NULL CHECK (workflow_type IN ('document_approval', 'signature_sequence', 'compliance_review', 'automated_processing', 'custom')),
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'paused', 'completed', 'cancelled')),
    created_by TEXT NOT NULL,
    team_id UUID REFERENCES public.teams(id),
    settings JSONB DEFAULT '{}',
    is_template BOOLEAN DEFAULT FALSE,
    template_name VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow steps table
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES public.workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(255) NOT NULL,
    step_type VARCHAR(50) NOT NULL CHECK (step_type IN ('approval', 'signature', 'review', 'notification', 'automated_action', 'conditional', 'parallel', 'sequential')),
    step_order INTEGER NOT NULL,
    assigned_to TEXT,
    assigned_role VARCHAR(50),
    assigned_team_id UUID REFERENCES public.teams(id),
    conditions JSONB DEFAULT '{}',
    actions JSONB DEFAULT '{}',
    timeout_hours INTEGER,
    is_required BOOLEAN DEFAULT TRUE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow instances table
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES public.workflows(id),
    document_id UUID REFERENCES public.documents(id),
    name VARCHAR(255) NOT NULL,
    status VARCHAR(20) DEFAULT 'running' CHECK (status IN ('running', 'paused', 'completed', 'cancelled', 'failed')),
    started_by TEXT NOT NULL,
    started_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE,
    current_step_id UUID REFERENCES public.workflow_steps(id),
    context_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow step executions table
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_instance_id UUID NOT NULL REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES public.workflow_steps(id),
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'skipped', 'failed', 'cancelled')),
    assigned_to TEXT,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    result_data JSONB DEFAULT '{}',
    comments TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Workflow templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) NOT NULL,
    description TEXT,
    workflow_type VARCHAR(50) NOT NULL,
    template_data JSONB NOT NULL,
    is_public BOOLEAN DEFAULT FALSE,
    created_by TEXT NOT NULL,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- WORKFLOW MANAGEMENT FUNCTIONS
-- =====================================================

-- Function to create a workflow
CREATE OR REPLACE FUNCTION public.create_workflow(
    p_name VARCHAR(255),
    p_description TEXT,
    p_workflow_type VARCHAR(50),
    p_created_by TEXT,
    p_team_id UUID DEFAULT NULL,
    p_settings JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    workflow_id UUID;
BEGIN
    INSERT INTO public.workflows (
        name, description, workflow_type, created_by, team_id, settings
    ) VALUES (
        p_name, p_description, p_workflow_type, p_created_by, p_team_id, p_settings
    ) RETURNING id INTO workflow_id;
    
    RETURN workflow_id;
END;
$$ LANGUAGE plpgsql;

-- Function to add workflow step
CREATE OR REPLACE FUNCTION public.add_workflow_step(
    p_workflow_id UUID,
    p_step_name VARCHAR(255),
    p_step_type VARCHAR(50),
    p_step_order INTEGER,
    p_assigned_to TEXT DEFAULT NULL,
    p_assigned_role VARCHAR(50) DEFAULT NULL,
    p_assigned_team_id UUID DEFAULT NULL,
    p_conditions JSONB DEFAULT '{}',
    p_actions JSONB DEFAULT '{}',
    p_timeout_hours INTEGER DEFAULT NULL,
    p_is_required BOOLEAN DEFAULT TRUE
)
RETURNS UUID AS $$
DECLARE
    step_id UUID;
BEGIN
    INSERT INTO public.workflow_steps (
        workflow_id, step_name, step_type, step_order, assigned_to, assigned_role,
        assigned_team_id, conditions, actions, timeout_hours, is_required
    ) VALUES (
        p_workflow_id, p_step_name, p_step_type, p_step_order, p_assigned_to, p_assigned_role,
        p_assigned_team_id, p_conditions, p_actions, p_timeout_hours, p_is_required
    ) RETURNING id INTO step_id;
    
    RETURN step_id;
END;
$$ LANGUAGE plpgsql;

-- Function to start workflow instance
CREATE OR REPLACE FUNCTION public.start_workflow_instance(
    p_workflow_id UUID,
    p_document_id UUID DEFAULT NULL,
    p_name VARCHAR(255),
    p_started_by TEXT,
    p_context_data JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    instance_id UUID;
    first_step_id UUID;
BEGIN
    -- Create workflow instance
    INSERT INTO public.workflow_instances (
        workflow_id, document_id, name, started_by, context_data
    ) VALUES (
        p_workflow_id, p_document_id, p_name, p_started_by, p_context_data
    ) RETURNING id INTO instance_id;
    
    -- Get first step
    SELECT id INTO first_step_id 
    FROM public.workflow_steps 
    WHERE workflow_id = p_workflow_id 
    AND step_order = 1 
    AND is_active = TRUE;
    
    -- Update current step
    UPDATE public.workflow_instances 
    SET current_step_id = first_step_id
    WHERE id = instance_id;
    
    -- Create first step execution
    INSERT INTO public.workflow_step_executions (
        workflow_instance_id, step_id, status, assigned_to
    ) VALUES (
        instance_id, first_step_id, 'pending',
        (SELECT assigned_to FROM public.workflow_steps WHERE id = first_step_id)
    );
    
    RETURN instance_id;
END;
$$ LANGUAGE plpgsql;

-- Function to complete workflow step
CREATE OR REPLACE FUNCTION public.complete_workflow_step(
    p_step_execution_id UUID,
    p_completed_by TEXT,
    p_result_data JSONB DEFAULT '{}',
    p_comments TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
DECLARE
    step_execution RECORD;
    next_step_id UUID;
    workflow_instance_id UUID;
BEGIN
    -- Get step execution details
    SELECT * INTO step_execution 
    FROM public.workflow_step_executions 
    WHERE id = p_step_execution_id;
    
    IF step_execution IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Update step execution
    UPDATE public.workflow_step_executions 
    SET 
        status = 'completed',
        completed_at = CURRENT_TIMESTAMP,
        result_data = p_result_data,
        comments = p_comments
    WHERE id = p_step_execution_id;
    
    -- Get workflow instance
    workflow_instance_id := step_execution.workflow_instance_id;
    
    -- Find next step
    SELECT id INTO next_step_id 
    FROM public.workflow_steps 
    WHERE workflow_id = (
        SELECT workflow_id FROM public.workflow_instances WHERE id = workflow_instance_id
    )
    AND step_order > (
        SELECT step_order FROM public.workflow_steps WHERE id = step_execution.step_id
    )
    AND is_active = TRUE
    ORDER BY step_order ASC
    LIMIT 1;
    
    IF next_step_id IS NOT NULL THEN
        -- Update current step
        UPDATE public.workflow_instances 
        SET current_step_id = next_step_id
        WHERE id = workflow_instance_id;
        
        -- Create next step execution
        INSERT INTO public.workflow_step_executions (
            workflow_instance_id, step_id, status, assigned_to
        ) VALUES (
            workflow_instance_id, next_step_id, 'pending',
            (SELECT assigned_to FROM public.workflow_steps WHERE id = next_step_id)
        );
    ELSE
        -- No more steps, complete workflow
        UPDATE public.workflow_instances 
        SET 
            status = 'completed',
            completed_at = CURRENT_TIMESTAMP,
            current_step_id = NULL
        WHERE id = workflow_instance_id;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to get user workflows
CREATE OR REPLACE FUNCTION public.get_user_workflows(p_user_id TEXT)
RETURNS TABLE (
    workflow_id UUID,
    workflow_name VARCHAR(255),
    workflow_type VARCHAR(50),
    status VARCHAR(20),
    created_by TEXT,
    team_id UUID,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        w.id,
        w.name,
        w.workflow_type,
        w.status,
        w.created_by,
        w.team_id,
        w.created_at
    FROM public.workflows w
    WHERE w.created_by = p_user_id
    OR w.team_id IN (
        SELECT team_id FROM public.team_members 
        WHERE user_id = p_user_id AND is_active = TRUE
    )
    ORDER BY w.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get workflow instances
CREATE OR REPLACE FUNCTION public.get_workflow_instances(
    p_workflow_id UUID DEFAULT NULL,
    p_user_id TEXT DEFAULT NULL
)
RETURNS TABLE (
    instance_id UUID,
    workflow_name VARCHAR(255),
    instance_name VARCHAR(255),
    status VARCHAR(20),
    started_by TEXT,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    current_step_name VARCHAR(255)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        wi.id,
        w.name,
        wi.name,
        wi.status,
        wi.started_by,
        wi.started_at,
        wi.completed_at,
        ws.step_name
    FROM public.workflow_instances wi
    JOIN public.workflows w ON wi.workflow_id = w.id
    LEFT JOIN public.workflow_steps ws ON wi.current_step_id = ws.id
    WHERE (p_workflow_id IS NULL OR wi.workflow_id = p_workflow_id)
    AND (p_user_id IS NULL OR wi.started_by = p_user_id)
    ORDER BY wi.started_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get workflow step executions
CREATE OR REPLACE FUNCTION public.get_workflow_step_executions(
    p_workflow_instance_id UUID
)
RETURNS TABLE (
    execution_id UUID,
    step_name VARCHAR(255),
    step_type VARCHAR(50),
    status VARCHAR(20),
    assigned_to TEXT,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    comments TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        wse.id,
        ws.step_name,
        ws.step_type,
        wse.status,
        wse.assigned_to,
        wse.started_at,
        wse.completed_at,
        wse.comments
    FROM public.workflow_step_executions wse
    JOIN public.workflow_steps ws ON wse.step_id = ws.id
    WHERE wse.workflow_instance_id = p_workflow_instance_id
    ORDER BY ws.step_order ASC;
END;
$$ LANGUAGE plpgsql;

-- Function to create workflow template
CREATE OR REPLACE FUNCTION public.create_workflow_template(
    p_template_name VARCHAR(255),
    p_description TEXT,
    p_workflow_type VARCHAR(50),
    p_template_data JSONB,
    p_created_by TEXT,
    p_is_public BOOLEAN DEFAULT FALSE
)
RETURNS UUID AS $$
DECLARE
    template_id UUID;
BEGIN
    INSERT INTO public.workflow_templates (
        template_name, description, workflow_type, template_data, created_by, is_public
    ) VALUES (
        p_template_name, p_description, p_workflow_type, p_template_data, p_created_by, p_is_public
    ) RETURNING id INTO template_id;
    
    RETURN template_id;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RLS POLICIES FOR WORKFLOW TABLES
-- =====================================================

-- Enable RLS on workflow tables
ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;

-- Workflows policies
CREATE POLICY "Users can view workflows they created or belong to" ON public.workflows
    FOR SELECT USING (
        created_by = auth.uid()::text
        OR team_id IN (
            SELECT team_id FROM public.team_members 
            WHERE user_id = auth.uid()::text AND is_active = TRUE
        )
    );

CREATE POLICY "Users can manage workflows they created" ON public.workflows
    FOR ALL USING (
        created_by = auth.uid()::text
    );

-- Workflow instances policies
CREATE POLICY "Users can view workflow instances they started or are assigned to" ON public.workflow_instances
    FOR SELECT USING (
        started_by = auth.uid()::text
        OR workflow_id IN (
            SELECT id FROM public.workflows 
            WHERE created_by = auth.uid()::text
            OR team_id IN (
                SELECT team_id FROM public.team_members 
                WHERE user_id = auth.uid()::text AND is_active = TRUE
            )
        )
    );

-- Workflow step executions policies
CREATE POLICY "Users can view step executions for their workflows" ON public.workflow_step_executions
    FOR SELECT USING (
        workflow_instance_id IN (
            SELECT id FROM public.workflow_instances 
            WHERE started_by = auth.uid()::text
            OR workflow_id IN (
                SELECT id FROM public.workflows 
                WHERE created_by = auth.uid()::text
                OR team_id IN (
                    SELECT team_id FROM public.team_members 
                    WHERE user_id = auth.uid()::text AND is_active = TRUE
                )
            )
        )
    );

-- =====================================================
-- INDEXES FOR WORKFLOW TABLES
-- =====================================================

-- Workflows indexes
CREATE INDEX IF NOT EXISTS idx_workflows_created_by ON public.workflows(created_by);
CREATE INDEX IF NOT EXISTS idx_workflows_team_id ON public.workflows(team_id);
CREATE INDEX IF NOT EXISTS idx_workflows_workflow_type ON public.workflows(workflow_type);
CREATE INDEX IF NOT EXISTS idx_workflows_status ON public.workflows(status);
CREATE INDEX IF NOT EXISTS idx_workflows_is_template ON public.workflows(is_template);

-- Workflow steps indexes
CREATE INDEX IF NOT EXISTS idx_workflow_steps_workflow_id ON public.workflow_steps(workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_steps_step_order ON public.workflow_steps(step_order);
CREATE INDEX IF NOT EXISTS idx_workflow_steps_assigned_to ON public.workflow_steps(assigned_to);
CREATE INDEX IF NOT EXISTS idx_workflow_steps_is_active ON public.workflow_steps(is_active);

-- Workflow instances indexes
CREATE INDEX IF NOT EXISTS idx_workflow_instances_workflow_id ON public.workflow_instances(workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_instances_document_id ON public.workflow_instances(document_id);
CREATE INDEX IF NOT EXISTS idx_workflow_instances_started_by ON public.workflow_instances(started_by);
CREATE INDEX IF NOT EXISTS idx_workflow_instances_status ON public.workflow_instances(status);
CREATE INDEX IF NOT EXISTS idx_workflow_instances_current_step_id ON public.workflow_instances(current_step_id);

-- Workflow step executions indexes
CREATE INDEX IF NOT EXISTS idx_workflow_step_executions_workflow_instance_id ON public.workflow_step_executions(workflow_instance_id);
CREATE INDEX IF NOT EXISTS idx_workflow_step_executions_step_id ON public.workflow_step_executions(step_id);
CREATE INDEX IF NOT EXISTS idx_workflow_step_executions_status ON public.workflow_step_executions(status);
CREATE INDEX IF NOT EXISTS idx_workflow_step_executions_assigned_to ON public.workflow_step_executions(assigned_to);

-- Workflow templates indexes
CREATE INDEX IF NOT EXISTS idx_workflow_templates_template_name ON public.workflow_templates(template_name);
CREATE INDEX IF NOT EXISTS idx_workflow_templates_workflow_type ON public.workflow_templates(workflow_type);
CREATE INDEX IF NOT EXISTS idx_workflow_templates_is_public ON public.workflow_templates(is_public);
CREATE INDEX IF NOT EXISTS idx_workflow_templates_created_by ON public.workflow_templates(created_by);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.workflows IS 'Document workflow definitions and templates';
COMMENT ON TABLE public.workflow_steps IS 'Individual steps within workflows';
COMMENT ON TABLE public.workflow_instances IS 'Active workflow executions';
COMMENT ON TABLE public.workflow_step_executions IS 'Execution status of workflow steps';
COMMENT ON TABLE public.workflow_templates IS 'Reusable workflow templates';
COMMENT ON FUNCTION public.create_workflow(VARCHAR, TEXT, VARCHAR, TEXT, UUID, JSONB) IS 'Creates a new workflow';
COMMENT ON FUNCTION public.add_workflow_step(UUID, VARCHAR, VARCHAR, INTEGER, TEXT, VARCHAR, UUID, JSONB, JSONB, INTEGER, BOOLEAN) IS 'Adds a step to a workflow';
COMMENT ON FUNCTION public.start_workflow_instance(UUID, UUID, VARCHAR, TEXT, JSONB) IS 'Starts a workflow instance';
COMMENT ON FUNCTION public.complete_workflow_step(UUID, TEXT, JSONB, TEXT) IS 'Completes a workflow step';
COMMENT ON FUNCTION public.get_user_workflows(TEXT) IS 'Gets workflows for a user';
COMMENT ON FUNCTION public.get_workflow_instances(UUID, TEXT) IS 'Gets workflow instances with filtering';
COMMENT ON FUNCTION public.get_workflow_step_executions(UUID) IS 'Gets step executions for a workflow instance';
COMMENT ON FUNCTION public.create_workflow_template(VARCHAR, TEXT, VARCHAR, JSONB, TEXT, BOOLEAN) IS 'Creates a workflow template';
\n-- End of buffrsign-starter/sql/19-workflow_management.sql --\n
-- =====================================================
-- BuffrSign SendGrid Webhooks and Email Tracking
-- =====================================================
-- Description: SendGrid webhook event tracking and email delivery status
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- SENDGRID WEBHOOK TABLES
-- =====================================================

-- SendGrid Webhook Events
CREATE TABLE IF NOT EXISTS public.sendgrid_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id TEXT NOT NULL UNIQUE, -- SendGrid event ID
    event_type TEXT NOT NULL,
    email TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    sg_message_id TEXT,
    sg_event_id TEXT,
    sg_template_id TEXT,
    sg_template_name TEXT,
    response TEXT,
    attempt INTEGER,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    reason TEXT,
    status TEXT,
    category TEXT[],
    unique_args JSONB,
    marketing_campaign_id TEXT,
    marketing_campaign_name TEXT,
    raw_data JSONB NOT NULL,
    processed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Delivery Status Tracking
CREATE TABLE IF NOT EXISTS public.email_delivery_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_queue_id UUID REFERENCES public.email_queue(id),
    sendgrid_message_id TEXT,
    recipient_email TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'dropped', 'spam', 'unsubscribed', 'processed', 'deferred', 'blocked')),
    event_type TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    reason TEXT,
    response TEXT,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    category TEXT[],
    unique_args JSONB,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Bounce Management
CREATE TABLE IF NOT EXISTS public.email_bounces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    bounce_type TEXT NOT NULL CHECK (bounce_type IN ('hard', 'soft', 'block', 'spam', 'invalid')),
    bounce_reason TEXT,
    bounce_code TEXT,
    bounce_description TEXT,
    first_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    last_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    bounce_count INTEGER DEFAULT 1,
    is_suppressed BOOLEAN DEFAULT false,
    suppression_reason TEXT,
    suppressed_at TIMESTAMP WITH TIME ZONE,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Suppression Lists
CREATE TABLE IF NOT EXISTS public.email_suppressions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    suppression_type TEXT NOT NULL CHECK (suppression_type IN ('bounce', 'block', 'spam', 'unsubscribe', 'group_unsubscribe', 'manual')),
    reason TEXT,
    source TEXT DEFAULT 'sendgrid',
    is_active BOOLEAN DEFAULT true,
    suppressed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    unsuppressed_at TIMESTAMP WITH TIME ZONE,
    unsuppressed_by UUID REFERENCES auth.users(id),
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Unsubscribe Tracking
CREATE TABLE IF NOT EXISTS public.email_unsubscribes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    unsubscribe_type TEXT NOT NULL CHECK (unsubscribe_type IN ('one_click', 'group', 'manual')),
    unsubscribe_source TEXT,
    user_id UUID REFERENCES auth.users(id),
    campaign_id TEXT,
    template_id TEXT,
    unsubscribed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Link Tracking
CREATE TABLE IF NOT EXISTS public.email_link_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    link_url TEXT NOT NULL,
    link_id TEXT NOT NULL,
    email_id TEXT,
    campaign_id TEXT,
    template_id TEXT,
    click_count INTEGER DEFAULT 0,
    unique_click_count INTEGER DEFAULT 0,
    first_clicked_at TIMESTAMP WITH TIME ZONE,
    last_clicked_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Open Tracking
CREATE TABLE IF NOT EXISTS public.email_open_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    opened_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Click Tracking
CREATE TABLE IF NOT EXISTS public.email_click_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    link_url TEXT NOT NULL,
    clicked_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- =====================================================
-- SENDGRID WEBHOOK FUNCTIONS
-- =====================================================

-- Function to process SendGrid webhook event
CREATE OR REPLACE FUNCTION public.process_sendgrid_webhook_event(
    p_event_data JSONB
)
RETURNS UUID AS $$
DECLARE
    event_id UUID;
    email_address TEXT;
    event_type TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Extract event data
    email_address := p_event_data->>'email';
    event_type := p_event_data->>'event';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    
    -- Insert webhook event
    INSERT INTO public.sendgrid_webhook_events (
        event_id, event_type, email, timestamp, sg_message_id, sg_event_id,
        sg_template_id, sg_template_name, response, attempt, user_agent,
        ip_address, url, reason, status, category, unique_args,
        marketing_campaign_id, marketing_campaign_name, raw_data
    ) VALUES (
        p_event_data->>'sg_event_id',
        p_event_data->>'event',
        p_event_data->>'email',
        timestamp_value,
        p_event_data->>'sg_message_id',
        p_event_data->>'sg_event_id',
        p_event_data->>'sg_template_id',
        p_event_data->>'sg_template_name',
        p_event_data->>'response',
        (p_event_data->>'attempt')::INTEGER,
        p_event_data->>'user_agent',
        (p_event_data->>'ip')::INET,
        p_event_data->>'url',
        p_event_data->>'reason',
        p_event_data->>'status',
        ARRAY(SELECT jsonb_array_elements_text(p_event_data->'category')),
        p_event_data->'unique_args',
        p_event_data->>'marketing_campaign_id',
        p_event_data->>'marketing_campaign_name',
        p_event_data
    ) RETURNING id INTO event_id;
    
    -- Process specific event types
    CASE event_type
        WHEN 'bounce' THEN
            PERFORM public.process_bounce_event(p_event_data);
        WHEN 'dropped' THEN
            PERFORM public.process_dropped_event(p_event_data);
        WHEN 'spam_report' THEN
            PERFORM public.process_spam_report_event(p_event_data);
        WHEN 'unsubscribe' THEN
            PERFORM public.process_unsubscribe_event(p_event_data);
        WHEN 'click' THEN
            PERFORM public.process_click_event(p_event_data);
        WHEN 'open' THEN
            PERFORM public.process_open_event(p_event_data);
    END CASE;
    
    RETURN event_id;
END;
$$ LANGUAGE plpgsql;

-- Function to process bounce events
CREATE OR REPLACE FUNCTION public.process_bounce_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    bounce_type TEXT;
    bounce_reason TEXT;
    bounce_code TEXT;
    bounce_description TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
BEGIN
    email_address := p_event_data->>'email';
    bounce_type := CASE 
        WHEN p_event_data->>'type' = 'bounce' THEN 'hard'
        WHEN p_event_data->>'type' = 'block' THEN 'block'
        ELSE 'soft'
    END;
    bounce_reason := p_event_data->>'reason';
    bounce_code := p_event_data->>'code';
    bounce_description := p_event_data->>'description';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    
    -- Insert or update bounce record
    INSERT INTO public.email_bounces (
        email, bounce_type, bounce_reason, bounce_code, bounce_description,
        first_bounce_at, last_bounce_at, raw_data
    ) VALUES (
        email_address, bounce_type, bounce_reason, bounce_code, bounce_description,
        timestamp_value, timestamp_value, p_event_data
    ) ON CONFLICT (email) DO UPDATE SET
        bounce_count = email_bounces.bounce_count + 1,
        last_bounce_at = timestamp_value,
        updated_at = now();
    
    -- Add to suppression list if hard bounce
    IF bounce_type = 'hard' THEN
        INSERT INTO public.email_suppressions (
            email, suppression_type, reason, suppressed_at, raw_data
        ) VALUES (
            email_address, 'bounce', bounce_reason, timestamp_value, p_event_data
        ) ON CONFLICT (email, suppression_type) DO NOTHING;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to process dropped events
CREATE OR REPLACE FUNCTION public.process_dropped_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
BEGIN
    email_address := p_event_data->>'email';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    
    -- Add to suppression list
    INSERT INTO public.email_suppressions (
        email, suppression_type, reason, suppressed_at, raw_data
    ) VALUES (
        email_address, 'block', p_event_data->>'reason', timestamp_value, p_event_data
    ) ON CONFLICT (email, suppression_type) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

-- Function to process spam report events
CREATE OR REPLACE FUNCTION public.process_spam_report_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
BEGIN
    email_address := p_event_data->>'email';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    
    -- Add to suppression list
    INSERT INTO public.email_suppressions (
        email, suppression_type, reason, suppressed_at, raw_data
    ) VALUES (
        email_address, 'spam', 'Spam report', timestamp_value, p_event_data
    ) ON CONFLICT (email, suppression_type) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

-- Function to process unsubscribe events
CREATE OR REPLACE FUNCTION public.process_unsubscribe_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
    unsubscribe_type TEXT;
BEGIN
    email_address := p_event_data->>'email';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    unsubscribe_type := CASE 
        WHEN p_event_data->>'type' = 'group_unsubscribe' THEN 'group'
        ELSE 'one_click'
    END;
    
    -- Insert unsubscribe record
    INSERT INTO public.email_unsubscribes (
        email, unsubscribe_type, unsubscribed_at, raw_data
    ) VALUES (
        email_address, unsubscribe_type, timestamp_value, p_event_data
    ) ON CONFLICT (email, unsubscribe_type) DO NOTHING;
    
    -- Add to suppression list
    INSERT INTO public.email_suppressions (
        email, suppression_type, reason, suppressed_at, raw_data
    ) VALUES (
        email_address, 'unsubscribe', 'User unsubscribed', timestamp_value, p_event_data
    ) ON CONFLICT (email, suppression_type) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

-- Function to process click events
CREATE OR REPLACE FUNCTION public.process_click_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    link_url TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
    email_id TEXT;
    campaign_id TEXT;
    template_id TEXT;
BEGIN
    email_address := p_event_data->>'email';
    link_url := p_event_data->>'url';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    email_id := p_event_data->>'sg_message_id';
    campaign_id := p_event_data->>'marketing_campaign_id';
    template_id := p_event_data->>'sg_template_id';
    
    -- Insert click tracking record
    INSERT INTO public.email_click_tracking (
        email_id, recipient_email, link_url, clicked_at, user_agent,
        ip_address, location_data, device_type, browser_type, os_type
    ) VALUES (
        email_id, email_address, link_url, timestamp_value,
        p_event_data->>'user_agent',
        (p_event_data->>'ip')::INET,
        p_event_data->'location_data',
        p_event_data->>'device_type',
        p_event_data->>'browser_type',
        p_event_data->>'os_type'
    );
    
    -- Update link tracking
    INSERT INTO public.email_link_tracking (
        link_url, link_id, email_id, campaign_id, template_id,
        click_count, unique_click_count, first_clicked_at, last_clicked_at
    ) VALUES (
        link_url, p_event_data->>'sg_event_id', email_id, campaign_id, template_id,
        1, 1, timestamp_value, timestamp_value
    ) ON CONFLICT (link_url, link_id) DO UPDATE SET
        click_count = email_link_tracking.click_count + 1,
        last_clicked_at = timestamp_value;
END;
$$ LANGUAGE plpgsql;

-- Function to process open events
CREATE OR REPLACE FUNCTION public.process_open_event(p_event_data JSONB)
RETURNS VOID AS $$
DECLARE
    email_address TEXT;
    timestamp_value TIMESTAMP WITH TIME ZONE;
    email_id TEXT;
BEGIN
    email_address := p_event_data->>'email';
    timestamp_value := (p_event_data->>'timestamp')::TIMESTAMP WITH TIME ZONE;
    email_id := p_event_data->>'sg_message_id';
    
    -- Insert open tracking record
    INSERT INTO public.email_open_tracking (
        email_id, recipient_email, opened_at, user_agent,
        ip_address, location_data, device_type, browser_type, os_type
    ) VALUES (
        email_id, email_address, timestamp_value,
        p_event_data->>'user_agent',
        (p_event_data->>'ip')::INET,
        p_event_data->'location_data',
        p_event_data->>'device_type',
        p_event_data->>'browser_type',
        p_event_data->>'os_type'
    );
END;
$$ LANGUAGE plpgsql;

-- Function to get email delivery statistics
CREATE OR REPLACE FUNCTION public.get_email_delivery_stats(
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_email TEXT DEFAULT NULL
)
RETURNS TABLE (
    total_emails BIGINT,
    delivered_count BIGINT,
    opened_count BIGINT,
    clicked_count BIGINT,
    bounced_count BIGINT,
    dropped_count BIGINT,
    spam_reports BIGINT,
    unsubscribes BIGINT,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    WITH email_stats AS (
        SELECT 
            COUNT(*) as total_emails,
            COUNT(CASE WHEN event_type = 'delivered' THEN 1 END) as delivered_count,
            COUNT(CASE WHEN event_type = 'open' THEN 1 END) as opened_count,
            COUNT(CASE WHEN event_type = 'click' THEN 1 END) as clicked_count,
            COUNT(CASE WHEN event_type = 'bounce' THEN 1 END) as bounced_count,
            COUNT(CASE WHEN event_type = 'dropped' THEN 1 END) as dropped_count,
            COUNT(CASE WHEN event_type = 'spam_report' THEN 1 END) as spam_reports,
            COUNT(CASE WHEN event_type = 'unsubscribe' THEN 1 END) as unsubscribes
        FROM public.sendgrid_webhook_events swe
        WHERE (p_start_date IS NULL OR swe.timestamp >= p_start_date)
          AND (p_end_date IS NULL OR swe.timestamp <= p_end_date)
          AND (p_email IS NULL OR swe.email = p_email)
    )
    SELECT 
        es.total_emails,
        es.delivered_count,
        es.opened_count,
        es.clicked_count,
        es.bounced_count,
        es.dropped_count,
        es.spam_reports,
        es.unsubscribes,
        CASE 
            WHEN es.total_emails > 0 THEN ROUND((es.delivered_count::NUMERIC / es.total_emails::NUMERIC) * 100, 2)
            ELSE 0
        END as delivery_rate,
        CASE 
            WHEN es.delivered_count > 0 THEN ROUND((es.opened_count::NUMERIC / es.delivered_count::NUMERIC) * 100, 2)
            ELSE 0
        END as open_rate,
        CASE 
            WHEN es.delivered_count > 0 THEN ROUND((es.clicked_count::NUMERIC / es.delivered_count::NUMERIC) * 100, 2)
            ELSE 0
        END as click_rate
    FROM email_stats es;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RLS POLICIES FOR SENDGRID WEBHOOK TABLES
-- =====================================================

-- Enable RLS on SendGrid webhook tables
ALTER TABLE public.sendgrid_webhook_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_delivery_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_bounces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_suppressions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_unsubscribes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_link_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_open_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_click_tracking ENABLE ROW LEVEL SECURITY;

-- SendGrid webhook events policies
CREATE POLICY "Admin users can view SendGrid webhook events" ON public.sendgrid_webhook_events
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert SendGrid webhook events" ON public.sendgrid_webhook_events
    FOR INSERT WITH CHECK (true);

-- Email delivery status policies
CREATE POLICY "Users can view own email delivery status" ON public.email_delivery_status
    FOR SELECT USING (
        recipient_email = (
            SELECT email FROM public.profiles WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can view all email delivery status" ON public.email_delivery_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- Email bounces policies
CREATE POLICY "Admin users can view email bounces" ON public.email_bounces
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage email bounces" ON public.email_bounces
    FOR ALL USING (true);

-- Email suppressions policies
CREATE POLICY "Admin users can view email suppressions" ON public.email_suppressions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage email suppressions" ON public.email_suppressions
    FOR ALL USING (true);

-- =====================================================
-- INDEXES FOR SENDGRID WEBHOOK TABLES
-- =====================================================

-- SendGrid webhook events indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_email ON public.sendgrid_webhook_events(email);
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_type ON public.sendgrid_webhook_events(event_type);
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_timestamp ON public.sendgrid_webhook_events(timestamp);
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_message_id ON public.sendgrid_webhook_events(sg_message_id);

-- Email delivery status indexes
CREATE INDEX IF NOT EXISTS idx_email_delivery_status_email ON public.email_delivery_status(recipient_email);
CREATE INDEX IF NOT EXISTS idx_email_delivery_status_status ON public.email_delivery_status(status);
CREATE INDEX IF NOT EXISTS idx_email_delivery_status_timestamp ON public.email_delivery_status(timestamp);

-- Email bounces indexes
CREATE INDEX IF NOT EXISTS idx_email_bounces_email ON public.email_bounces(email);
CREATE INDEX IF NOT EXISTS idx_email_bounces_type ON public.email_bounces(bounce_type);
CREATE INDEX IF NOT EXISTS idx_email_bounces_suppressed ON public.email_bounces(is_suppressed);

-- Email suppressions indexes
CREATE INDEX IF NOT EXISTS idx_email_suppressions_email ON public.email_suppressions(email);
CREATE INDEX IF NOT EXISTS idx_email_suppressions_type ON public.email_suppressions(suppression_type);
CREATE INDEX IF NOT EXISTS idx_email_suppressions_active ON public.email_suppressions(is_active);

-- Email unsubscribes indexes
CREATE INDEX IF NOT EXISTS idx_email_unsubscribes_email ON public.email_unsubscribes(email);
CREATE INDEX IF NOT EXISTS idx_email_unsubscribes_type ON public.email_unsubscribes(unsubscribe_type);

-- Email link tracking indexes
CREATE INDEX IF NOT EXISTS idx_email_link_tracking_url ON public.email_link_tracking(link_url);
CREATE INDEX IF NOT EXISTS idx_email_link_tracking_email_id ON public.email_link_tracking(email_id);

-- Email open tracking indexes
CREATE INDEX IF NOT EXISTS idx_email_open_tracking_email_id ON public.email_open_tracking(email_id);
CREATE INDEX IF NOT EXISTS idx_email_open_tracking_recipient ON public.email_open_tracking(recipient_email);

-- Email click tracking indexes
CREATE INDEX IF NOT EXISTS idx_email_click_tracking_email_id ON public.email_click_tracking(email_id);
CREATE INDEX IF NOT EXISTS idx_email_click_tracking_recipient ON public.email_click_tracking(recipient_email);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.sendgrid_webhook_events IS 'SendGrid webhook events and email tracking';
COMMENT ON TABLE public.email_delivery_status IS 'Email delivery status tracking';
COMMENT ON TABLE public.email_bounces IS 'Email bounce management and tracking';
COMMENT ON TABLE public.email_suppressions IS 'Email suppression lists and management';
COMMENT ON TABLE public.email_unsubscribes IS 'Email unsubscribe tracking';
COMMENT ON TABLE public.email_link_tracking IS 'Email link click tracking';
COMMENT ON TABLE public.email_open_tracking IS 'Email open tracking';
COMMENT ON TABLE public.email_click_tracking IS 'Email click tracking';
COMMENT ON FUNCTION public.process_sendgrid_webhook_event(JSONB) IS 'Processes SendGrid webhook events';
COMMENT ON FUNCTION public.process_bounce_event(JSONB) IS 'Processes email bounce events';
COMMENT ON FUNCTION public.process_dropped_event(JSONB) IS 'Processes email dropped events';
COMMENT ON FUNCTION public.process_spam_report_event(JSONB) IS 'Processes spam report events';
COMMENT ON FUNCTION public.process_unsubscribe_event(JSONB) IS 'Processes unsubscribe events';
COMMENT ON FUNCTION public.process_click_event(JSONB) IS 'Processes email click events';
COMMENT ON FUNCTION public.process_open_event(JSONB) IS 'Processes email open events';
COMMENT ON FUNCTION public.get_email_delivery_stats(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, TEXT) IS 'Gets email delivery statistics';
\n-- End of buffrsign-starter/sql/15-sendgrid_webhooks.sql --\n
-- =====================================================
-- BuffrSign Email Analytics and Performance Tracking
-- =====================================================
-- Description: Comprehensive email analytics and performance tracking
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- EMAIL ANALYTICS TABLES
-- =====================================================

-- Email Analytics Summary
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    date DATE NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_type TEXT NOT NULL CHECK (metric_type IN ('count', 'rate', 'percentage', 'duration', 'amount')),
    category TEXT NOT NULL,
    subcategory TEXT,
    dimensions JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Campaign Analytics
CREATE TABLE IF NOT EXISTS public.email_campaign_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id TEXT NOT NULL,
    campaign_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    emails_spam_reported INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Template Performance
CREATE TABLE IF NOT EXISTS public.email_template_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    template_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Domain Performance
CREATE TABLE IF NOT EXISTS public.email_domain_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email IP Performance
CREATE TABLE IF NOT EXISTS public.email_ip_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Link Performance
CREATE TABLE IF NOT EXISTS public.email_link_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    link_url TEXT NOT NULL,
    link_id TEXT NOT NULL,
    date DATE NOT NULL,
    click_count INTEGER DEFAULT 0,
    unique_click_count INTEGER DEFAULT 0,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    first_clicked_at TIMESTAMP WITH TIME ZONE,
    last_clicked_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Geographic Analytics
CREATE TABLE IF NOT EXISTS public.email_geographic_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    country TEXT NOT NULL,
    region TEXT,
    city TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Device Analytics
CREATE TABLE IF NOT EXISTS public.email_device_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    device_type TEXT NOT NULL,
    browser_type TEXT,
    os_type TEXT,
    date DATE NOT NULL,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- =====================================================
-- EMAIL ANALYTICS FUNCTIONS
-- =====================================================

-- Function to calculate email analytics
CREATE OR REPLACE FUNCTION public.calculate_email_analytics(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS VOID AS $$
DECLARE
    start_date DATE;
    end_date DATE;
    current_date DATE;
BEGIN
    -- Set default date range if not provided
    start_date := COALESCE(p_start_date, CURRENT_DATE - INTERVAL '30 days');
    end_date := COALESCE(p_end_date, CURRENT_DATE);
    current_date := start_date;
    
    -- Loop through each date in the range
    WHILE current_date <= end_date LOOP
        -- Calculate daily analytics
        PERFORM public.calculate_daily_email_analytics(current_date);
        
        -- Move to next date
        current_date := current_date + INTERVAL '1 day';
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate daily email analytics
CREATE OR REPLACE FUNCTION public.calculate_daily_email_analytics(p_date DATE)
RETURNS VOID AS $$
DECLARE
    analytics_date DATE := p_date;
BEGIN
    -- Calculate overall email metrics
    INSERT INTO public.email_analytics (date, metric_name, metric_value, metric_type, category)
    SELECT 
        analytics_date,
        'total_emails_sent',
        COUNT(*),
        'count',
        'overall'
    FROM public.sendgrid_webhook_events
    WHERE DATE(timestamp) = analytics_date
    AND event_type = 'sent'
    ON CONFLICT (date, metric_name, category) DO UPDATE SET
        metric_value = EXCLUDED.metric_value,
        updated_at = now();
    
    -- Calculate delivery rate
    INSERT INTO public.email_analytics (date, metric_name, metric_value, metric_type, category)
    SELECT 
        analytics_date,
        'delivery_rate',
        CASE 
            WHEN COUNT(CASE WHEN event_type = 'sent' THEN 1 END) > 0 
            THEN ROUND((COUNT(CASE WHEN event_type = 'delivered' THEN 1 END)::NUMERIC / COUNT(CASE WHEN event_type = 'sent' THEN 1 END)::NUMERIC) * 100, 2)
            ELSE 0
        END,
        'percentage',
        'overall'
    FROM public.sendgrid_webhook_events
    WHERE DATE(timestamp) = analytics_date
    ON CONFLICT (date, metric_name, category) DO UPDATE SET
        metric_value = EXCLUDED.metric_value,
        updated_at = now();
    
    -- Calculate open rate
    INSERT INTO public.email_analytics (date, metric_name, metric_value, metric_type, category)
    SELECT 
        analytics_date,
        'open_rate',
        CASE 
            WHEN COUNT(CASE WHEN event_type = 'delivered' THEN 1 END) > 0 
            THEN ROUND((COUNT(CASE WHEN event_type = 'open' THEN 1 END)::NUMERIC / COUNT(CASE WHEN event_type = 'delivered' THEN 1 END)::NUMERIC) * 100, 2)
            ELSE 0
        END,
        'percentage',
        'overall'
    FROM public.sendgrid_webhook_events
    WHERE DATE(timestamp) = analytics_date
    ON CONFLICT (date, metric_name, category) DO UPDATE SET
        metric_value = EXCLUDED.metric_value,
        updated_at = now();
    
    -- Calculate click rate
    INSERT INTO public.email_analytics (date, metric_name, metric_value, metric_type, category)
    SELECT 
        analytics_date,
        'click_rate',
        CASE 
            WHEN COUNT(CASE WHEN event_type = 'delivered' THEN 1 END) > 0 
            THEN ROUND((COUNT(CASE WHEN event_type = 'click' THEN 1 END)::NUMERIC / COUNT(CASE WHEN event_type = 'delivered' THEN 1 END)::NUMERIC) * 100, 2)
            ELSE 0
        END,
        'percentage',
        'overall'
    FROM public.sendgrid_webhook_events
    WHERE DATE(timestamp) = analytics_date
    ON CONFLICT (date, metric_name, category) DO UPDATE SET
        metric_value = EXCLUDED.metric_value,
        updated_at = now();
END;
$$ LANGUAGE plpgsql;

-- Function to get email analytics summary
CREATE OR REPLACE FUNCTION public.get_email_analytics_summary(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL,
    p_category TEXT DEFAULT NULL
)
RETURNS TABLE (
    metric_name TEXT,
    metric_value NUMERIC,
    metric_type TEXT,
    category TEXT,
    date DATE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ea.metric_name,
        ea.metric_value,
        ea.metric_type,
        ea.category,
        ea.date
    FROM public.email_analytics ea
    WHERE (p_start_date IS NULL OR ea.date >= p_start_date)
      AND (p_end_date IS NULL OR ea.date <= p_end_date)
      AND (p_category IS NULL OR ea.category = p_category)
    ORDER BY ea.date DESC, ea.metric_name;
END;
$$ LANGUAGE plpgsql;

-- Function to get campaign analytics
CREATE OR REPLACE FUNCTION public.get_campaign_analytics(
    p_campaign_id TEXT DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    campaign_id TEXT,
    campaign_name TEXT,
    date DATE,
    emails_sent INTEGER,
    emails_delivered INTEGER,
    emails_opened INTEGER,
    emails_clicked INTEGER,
    emails_bounced INTEGER,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2),
    bounce_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eca.campaign_id,
        eca.campaign_name,
        eca.date,
        eca.emails_sent,
        eca.emails_delivered,
        eca.emails_opened,
        eca.emails_clicked,
        eca.emails_bounced,
        eca.delivery_rate,
        eca.open_rate,
        eca.click_rate,
        eca.bounce_rate
    FROM public.email_campaign_analytics eca
    WHERE (p_campaign_id IS NULL OR eca.campaign_id = p_campaign_id)
      AND (p_start_date IS NULL OR eca.date >= p_start_date)
      AND (p_end_date IS NULL OR eca.date <= p_end_date)
    ORDER BY eca.date DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get template analytics
CREATE OR REPLACE FUNCTION public.get_template_analytics(
    p_template_id TEXT DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    template_id TEXT,
    template_name TEXT,
    date DATE,
    emails_sent INTEGER,
    emails_delivered INTEGER,
    emails_opened INTEGER,
    emails_clicked INTEGER,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eta.template_id,
        eta.template_name,
        eta.date,
        eta.emails_sent,
        eta.emails_delivered,
        eta.emails_opened,
        eta.emails_clicked,
        eta.delivery_rate,
        eta.open_rate,
        eta.click_rate
    FROM public.email_template_analytics eta
    WHERE (p_template_id IS NULL OR eta.template_id = p_template_id)
      AND (p_start_date IS NULL OR eta.date >= p_start_date)
      AND (p_end_date IS NULL OR eta.date <= p_end_date)
    ORDER BY eta.date DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get domain analytics
CREATE OR REPLACE FUNCTION public.get_domain_analytics(
    p_domain TEXT DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    domain TEXT,
    date DATE,
    emails_sent INTEGER,
    emails_delivered INTEGER,
    emails_opened INTEGER,
    emails_clicked INTEGER,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eda.domain,
        eda.date,
        eda.emails_sent,
        eda.emails_delivered,
        eda.emails_opened,
        eda.emails_clicked,
        eda.delivery_rate,
        eda.open_rate,
        eda.click_rate
    FROM public.email_domain_analytics eda
    WHERE (p_domain IS NULL OR eda.domain = p_domain)
      AND (p_start_date IS NULL OR eda.date >= p_start_date)
      AND (p_end_date IS NULL OR eda.date <= p_end_date)
    ORDER BY eda.date DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get geographic analytics
CREATE OR REPLACE FUNCTION public.get_geographic_analytics(
    p_country TEXT DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    country TEXT,
    region TEXT,
    city TEXT,
    date DATE,
    emails_sent INTEGER,
    emails_delivered INTEGER,
    emails_opened INTEGER,
    emails_clicked INTEGER,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ega.country,
        ega.region,
        ega.city,
        ega.date,
        ega.emails_sent,
        ega.emails_delivered,
        ega.emails_opened,
        ega.emails_clicked,
        ega.delivery_rate,
        ega.open_rate,
        ega.click_rate
    FROM public.email_geographic_analytics ega
    WHERE (p_country IS NULL OR ega.country = p_country)
      AND (p_start_date IS NULL OR ega.date >= p_start_date)
      AND (p_end_date IS NULL OR ega.date <= p_end_date)
    ORDER BY ega.date DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get device analytics
CREATE OR REPLACE FUNCTION public.get_device_analytics(
    p_device_type TEXT DEFAULT NULL,
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
)
RETURNS TABLE (
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    date DATE,
    emails_opened INTEGER,
    emails_clicked INTEGER,
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eda.device_type,
        eda.browser_type,
        eda.os_type,
        eda.date,
        eda.emails_opened,
        eda.emails_clicked,
        eda.open_rate,
        eda.click_rate
    FROM public.email_device_analytics eda
    WHERE (p_device_type IS NULL OR eda.device_type = p_device_type)
      AND (p_start_date IS NULL OR eda.date >= p_start_date)
      AND (p_end_date IS NULL OR eda.date <= p_end_date)
    ORDER BY eda.date DESC;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RLS POLICIES FOR EMAIL ANALYTICS TABLES
-- =====================================================

-- Enable RLS on email analytics tables
ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_campaign_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_template_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_domain_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_ip_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_link_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_geographic_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_device_analytics ENABLE ROW LEVEL SECURITY;

-- Email analytics policies
CREATE POLICY "Admin users can view email analytics" ON public.email_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage email analytics" ON public.email_analytics
    FOR ALL USING (true);

-- Email campaign analytics policies
CREATE POLICY "Admin users can view campaign analytics" ON public.email_campaign_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage campaign analytics" ON public.email_campaign_analytics
    FOR ALL USING (true);

-- Email template analytics policies
CREATE POLICY "Admin users can view template analytics" ON public.email_template_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage template analytics" ON public.email_template_analytics
    FOR ALL USING (true);

-- =====================================================
-- INDEXES FOR EMAIL ANALYTICS TABLES
-- =====================================================

-- Email analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_analytics_date ON public.email_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_analytics_metric ON public.email_analytics(metric_name);
CREATE INDEX IF NOT EXISTS idx_email_analytics_category ON public.email_analytics(category);

-- Email campaign analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_campaign_analytics_campaign ON public.email_campaign_analytics(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_campaign_analytics_date ON public.email_campaign_analytics(date);

-- Email template analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_template_analytics_template ON public.email_template_analytics(template_id);
CREATE INDEX IF NOT EXISTS idx_email_template_analytics_date ON public.email_template_analytics(date);

-- Email domain analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_domain_analytics_domain ON public.email_domain_analytics(domain);
CREATE INDEX IF NOT EXISTS idx_email_domain_analytics_date ON public.email_domain_analytics(date);

-- Email IP analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_ip_analytics_ip ON public.email_ip_analytics(ip_address);
CREATE INDEX IF NOT EXISTS idx_email_ip_analytics_date ON public.email_ip_analytics(date);

-- Email link analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_link_analytics_url ON public.email_link_analytics(link_url);
CREATE INDEX IF NOT EXISTS idx_email_link_analytics_date ON public.email_link_analytics(date);

-- Email geographic analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_geographic_analytics_country ON public.email_geographic_analytics(country);
CREATE INDEX IF NOT EXISTS idx_email_geographic_analytics_date ON public.email_geographic_analytics(date);

-- Email device analytics indexes
CREATE INDEX IF NOT EXISTS idx_email_device_analytics_device ON public.email_device_analytics(device_type);
CREATE INDEX IF NOT EXISTS idx_email_device_analytics_date ON public.email_device_analytics(date);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.email_analytics IS 'Email analytics summary and metrics';
COMMENT ON TABLE public.email_campaign_analytics IS 'Email campaign performance analytics';
COMMENT ON TABLE public.email_template_analytics IS 'Email template performance analytics';
COMMENT ON TABLE public.email_domain_analytics IS 'Email domain performance analytics';
COMMENT ON TABLE public.email_ip_analytics IS 'Email IP performance analytics';
COMMENT ON TABLE public.email_link_analytics IS 'Email link performance analytics';
COMMENT ON TABLE public.email_geographic_analytics IS 'Email geographic performance analytics';
COMMENT ON TABLE public.email_device_analytics IS 'Email device performance analytics';
COMMENT ON FUNCTION public.calculate_email_analytics(DATE, DATE) IS 'Calculates email analytics for a date range';
COMMENT ON FUNCTION public.calculate_daily_email_analytics(DATE) IS 'Calculates daily email analytics';
COMMENT ON FUNCTION public.get_email_analytics_summary(DATE, DATE, TEXT) IS 'Gets email analytics summary with filtering';
COMMENT ON FUNCTION public.get_campaign_analytics(TEXT, DATE, DATE) IS 'Gets campaign analytics with filtering';
COMMENT ON FUNCTION public.get_template_analytics(TEXT, DATE, DATE) IS 'Gets template analytics with filtering';
COMMENT ON FUNCTION public.get_domain_analytics(TEXT, DATE, DATE) IS 'Gets domain analytics with filtering';
COMMENT ON FUNCTION public.get_geographic_analytics(TEXT, DATE, DATE) IS 'Gets geographic analytics with filtering';
COMMENT ON FUNCTION public.get_device_analytics(TEXT, DATE, DATE) IS 'Gets device analytics with filtering';
\n-- End of buffrsign-starter/sql/16-email_analytics.sql --\n
-- =====================================================
-- BuffrSign Rate Limiting and Throttling
-- =====================================================
-- Description: Rate limiting tables and functions for document signing platform
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- RATE LIMITING TABLES
-- =====================================================

-- Rate limiting rules table
CREATE TABLE IF NOT EXISTS public.rate_limiting_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name VARCHAR(255) NOT NULL UNIQUE,
    rule_type VARCHAR(50) NOT NULL CHECK (rule_type IN ('api', 'user_action', 'document_upload', 'signature_request', 'email_sending', 'login_attempt')),
    resource VARCHAR(255) NOT NULL,
    limit_count INTEGER NOT NULL CHECK (limit_count > 0),
    time_window_minutes INTEGER NOT NULL CHECK (time_window_minutes > 0),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting violations table
CREATE TABLE IF NOT EXISTS public.rate_limiting_violations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    violation_count INTEGER NOT NULL DEFAULT 1,
    first_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_blocked BOOLEAN NOT NULL DEFAULT FALSE,
    block_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting counters table (for real-time tracking)
CREATE TABLE IF NOT EXISTS public.rate_limiting_counters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    counter_value INTEGER NOT NULL DEFAULT 0,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, ip_address, rule_id, window_start)
);

-- Rate limiting exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    exemption_reason TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- RATE LIMITING FUNCTIONS
-- =====================================================

-- Function to check rate limit
CREATE OR REPLACE FUNCTION public.check_rate_limit(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS JSONB AS $$
DECLARE
    rule_record RECORD;
    counter_record RECORD;
    current_count INTEGER := 0;
    is_exempted BOOLEAN := FALSE;
    is_blocked BOOLEAN := FALSE;
    block_until TIMESTAMP WITH TIME ZONE;
    result JSONB;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN jsonb_build_object(
            'allowed', TRUE,
            'reason', 'No rate limiting rule found'
        );
    END IF;
    
    -- Check if user/IP is exempted
    SELECT EXISTS(
        SELECT 1 FROM public.rate_limiting_exemptions 
        WHERE rule_id = rule_record.id 
        AND (user_id = p_user_id OR ip_address = p_ip_address)
        AND is_active = TRUE 
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    ) INTO is_exempted;
    
    IF is_exempted THEN
        RETURN jsonb_build_object(
            'allowed', TRUE,
            'reason', 'User/IP is exempted from rate limiting'
        );
    END IF;
    
    -- Check if user/IP is blocked
    SELECT is_blocked, block_until INTO is_blocked, block_until
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND is_blocked = TRUE
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    IF is_blocked AND block_until > CURRENT_TIMESTAMP THEN
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'reason', 'User/IP is blocked until ' || block_until,
            'block_until', block_until
        );
    END IF;
    
    -- Get current counter
    SELECT counter_value INTO current_count
    FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND window_start <= CURRENT_TIMESTAMP 
    AND window_end >= CURRENT_TIMESTAMP
    ORDER BY window_start DESC 
    LIMIT 1;
    
    -- Check if limit is exceeded
    IF current_count >= rule_record.limit_count THEN
        -- Record violation
        INSERT INTO public.rate_limiting_violations (
            user_id, ip_address, rule_id, violation_count, 
            first_violation_at, last_violation_at, is_blocked, block_until
        ) VALUES (
            p_user_id, p_ip_address, rule_record.id, 1,
            CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, TRUE, 
            CURRENT_TIMESTAMP + INTERVAL '1 hour'
        ) ON CONFLICT (user_id, ip_address, rule_id) 
        DO UPDATE SET 
            violation_count = rate_limiting_violations.violation_count + 1,
            last_violation_at = CURRENT_TIMESTAMP,
            is_blocked = TRUE,
            block_until = CURRENT_TIMESTAMP + INTERVAL '1 hour';
        
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'reason', 'Rate limit exceeded',
            'limit', rule_record.limit_count,
            'current_count', current_count,
            'time_window_minutes', rule_record.time_window_minutes
        );
    END IF;
    
    RETURN jsonb_build_object(
        'allowed', TRUE,
        'reason', 'Rate limit not exceeded',
        'limit', rule_record.limit_count,
        'current_count', current_count + 1,
        'time_window_minutes', rule_record.time_window_minutes
    );
END;
$$ LANGUAGE plpgsql;

-- Function to increment rate limit counter
CREATE OR REPLACE FUNCTION public.increment_rate_limit_counter(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS VOID AS $$
DECLARE
    rule_record RECORD;
    window_start TIMESTAMP WITH TIME ZONE;
    window_end TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN;
    END IF;
    
    -- Calculate time window
    window_start := date_trunc('minute', CURRENT_TIMESTAMP);
    window_end := window_start + INTERVAL '1 minute' * rule_record.time_window_minutes;
    
    -- Insert or update counter
    INSERT INTO public.rate_limiting_counters (
        user_id, ip_address, rule_id, counter_value, 
        window_start, window_end
    ) VALUES (
        p_user_id, p_ip_address, rule_record.id, 1,
        window_start, window_end
    ) ON CONFLICT (user_id, ip_address, rule_id, window_start) 
    DO UPDATE SET 
        counter_value = rate_limiting_counters.counter_value + 1,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- Function to reset rate limit counter
CREATE OR REPLACE FUNCTION public.reset_rate_limit_counter(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS VOID AS $$
DECLARE
    rule_record RECORD;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN;
    END IF;
    
    -- Delete counter
    DELETE FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address);
    
    -- Unblock user/IP
    UPDATE public.rate_limiting_violations 
    SET is_blocked = FALSE, block_until = NULL
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address);
END;
$$ LANGUAGE plpgsql;

-- Function to get rate limit status
CREATE OR REPLACE FUNCTION public.get_rate_limit_status(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS JSONB AS $$
DECLARE
    rule_record RECORD;
    counter_record RECORD;
    violation_record RECORD;
    current_count INTEGER := 0;
    is_exempted BOOLEAN := FALSE;
    is_blocked BOOLEAN := FALSE;
    block_until TIMESTAMP WITH TIME ZONE;
    result JSONB;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN jsonb_build_object(
            'rule_exists', FALSE,
            'message', 'No rate limiting rule found'
        );
    END IF;
    
    -- Check if user/IP is exempted
    SELECT EXISTS(
        SELECT 1 FROM public.rate_limiting_exemptions 
        WHERE rule_id = rule_record.id 
        AND (user_id = p_user_id OR ip_address = p_ip_address)
        AND is_active = TRUE 
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    ) INTO is_exempted;
    
    -- Check if user/IP is blocked
    SELECT is_blocked, block_until INTO is_blocked, block_until
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND is_blocked = TRUE
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    -- Get current counter
    SELECT counter_value INTO current_count
    FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND window_start <= CURRENT_TIMESTAMP 
    AND window_end >= CURRENT_TIMESTAMP
    ORDER BY window_start DESC 
    LIMIT 1;
    
    -- Get violation history
    SELECT violation_count, first_violation_at, last_violation_at 
    INTO violation_record
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    result := jsonb_build_object(
        'rule_name', rule_record.rule_name,
        'rule_type', rule_record.rule_type,
        'resource', rule_record.resource,
        'limit_count', rule_record.limit_count,
        'time_window_minutes', rule_record.time_window_minutes,
        'current_count', COALESCE(current_count, 0),
        'remaining_count', GREATEST(0, rule_record.limit_count - COALESCE(current_count, 0)),
        'is_exempted', is_exempted,
        'is_blocked', is_blocked,
        'block_until', block_until,
        'violation_count', COALESCE(violation_record.violation_count, 0),
        'first_violation_at', violation_record.first_violation_at,
        'last_violation_at', violation_record.last_violation_at
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup expired rate limiting data
CREATE OR REPLACE FUNCTION public.cleanup_rate_limiting_data()
RETURNS VOID AS $$
BEGIN
    -- Cleanup expired counters
    DELETE FROM public.rate_limiting_counters 
    WHERE window_end < CURRENT_TIMESTAMP - INTERVAL '1 day';
    
    -- Cleanup expired exemptions
    DELETE FROM public.rate_limiting_exemptions 
    WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP;
    
    -- Cleanup old violations (keep for 30 days)
    DELETE FROM public.rate_limiting_violations 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RATE LIMITING TRIGGERS
-- =====================================================

-- Trigger function for document uploads rate limiting
CREATE OR REPLACE FUNCTION public.rate_limit_document_uploads()
RETURNS TRIGGER AS $$
DECLARE
    rate_limit_result JSONB;
BEGIN
    -- Check rate limit for document uploads
    rate_limit_result := public.check_rate_limit(
        NEW.user_id,
        NULL, -- IP address not available in trigger context
        'document_upload_per_user'
    );
    
    IF NOT (rate_limit_result->>'allowed')::BOOLEAN THEN
        RAISE EXCEPTION 'Rate limit exceeded for document uploads: %', 
            rate_limit_result->>'reason';
    END IF;
    
    -- Increment counter
    PERFORM public.increment_rate_limit_counter(
        NEW.user_id,
        NULL,
        'document_upload_per_user'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit_document_uploads
    BEFORE INSERT ON public.documents
    FOR EACH ROW EXECUTE FUNCTION public.rate_limit_document_uploads();

-- Trigger function for signature requests rate limiting
CREATE OR REPLACE FUNCTION public.rate_limit_signature_requests()
RETURNS TRIGGER AS $$
DECLARE
    rate_limit_result JSONB;
BEGIN
    -- Check rate limit for signature requests
    rate_limit_result := public.check_rate_limit(
        NEW.user_id,
        NULL,
        'signature_request_per_user'
    );
    
    IF NOT (rate_limit_result->>'allowed')::BOOLEAN THEN
        RAISE EXCEPTION 'Rate limit exceeded for signature requests: %', 
            rate_limit_result->>'reason';
    END IF;
    
    -- Increment counter
    PERFORM public.increment_rate_limit_counter(
        NEW.user_id,
        NULL,
        'signature_request_per_user'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit_signature_requests
    BEFORE INSERT ON public.signatures
    FOR EACH ROW EXECUTE FUNCTION public.rate_limit_signature_requests();

-- Trigger function for email sending rate limiting
CREATE OR REPLACE FUNCTION public.rate_limit_email_sending()
RETURNS TRIGGER AS $$
DECLARE
    rate_limit_result JSONB;
BEGIN
    -- Check rate limit for email sending
    rate_limit_result := public.check_rate_limit(
        NEW.user_id,
        NULL,
        'email_sending_per_user'
    );
    
    IF NOT (rate_limit_result->>'allowed')::BOOLEAN THEN
        RAISE EXCEPTION 'Rate limit exceeded for email sending: %', 
            rate_limit_result->>'reason';
    END IF;
    
    -- Increment counter
    PERFORM public.increment_rate_limit_counter(
        NEW.user_id,
        NULL,
        'email_sending_per_user'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit_email_sending
    BEFORE INSERT ON public.email_queue
    FOR EACH ROW EXECUTE FUNCTION public.rate_limit_email_sending();

-- =====================================================
-- DEFAULT RATE LIMITING RULES
-- =====================================================

-- Insert default rate limiting rules for document signing platform
INSERT INTO public.rate_limiting_rules (rule_name, rule_type, resource, limit_count, time_window_minutes, description) VALUES
('api_requests_per_minute', 'api', 'api_endpoints', 100, 1, 'API requests per minute per user/IP'),
('api_requests_per_hour', 'api', 'api_endpoints', 1000, 60, 'API requests per hour per user/IP'),
('document_upload_per_user', 'document_upload', 'documents', 10, 60, 'Document uploads per user per hour'),
('signature_request_per_user', 'signature_request', 'signatures', 20, 60, 'Signature requests per user per hour'),
('email_sending_per_user', 'email_sending', 'email_queue', 50, 60, 'Email sending per user per hour'),
('login_attempt_per_ip', 'login_attempt', 'auth_login', 5, 15, 'Login attempts per IP per 15 minutes'),
('login_attempt_per_user', 'login_attempt', 'auth_login', 3, 15, 'Login attempts per user per 15 minutes'),
('password_reset_per_user', 'user_action', 'password_reset', 3, 60, 'Password reset requests per user per hour'),
('email_verification_per_user', 'user_action', 'email_verification', 5, 60, 'Email verification requests per user per hour'),
('document_analysis_per_user', 'user_action', 'ai_analysis', 100, 60, 'AI document analysis requests per user per hour'),
('bulk_operations_per_user', 'user_action', 'bulk_operations', 5, 60, 'Bulk operations per user per hour')
ON CONFLICT (rule_name) DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR RATE LIMITING TABLES
-- =====================================================

-- Enable RLS on rate limiting tables
ALTER TABLE public.rate_limiting_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_violations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_counters ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;

-- Rate limiting rules policies
CREATE POLICY "Admin users can view rate limiting rules" ON public.rate_limiting_rules
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "Admin users can modify rate limiting rules" ON public.rate_limiting_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- Rate limiting violations policies
CREATE POLICY "Users can view own rate limiting violations" ON public.rate_limiting_violations
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all rate limiting violations" ON public.rate_limiting_violations
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert rate limiting violations" ON public.rate_limiting_violations
    FOR INSERT WITH CHECK (true);

-- Rate limiting counters policies
CREATE POLICY "Users can view own rate limiting counters" ON public.rate_limiting_counters
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all rate limiting counters" ON public.rate_limiting_counters
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage rate limiting counters" ON public.rate_limiting_counters
    FOR ALL USING (true);

-- Rate limiting exemptions policies
CREATE POLICY "Admin users can view rate limiting exemptions" ON public.rate_limiting_exemptions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "Admin users can modify rate limiting exemptions" ON public.rate_limiting_exemptions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- =====================================================
-- INDEXES FOR RATE LIMITING TABLES
-- =====================================================

-- Rate limiting rules indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_rule_name ON public.rate_limiting_rules(rule_name);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_rule_type ON public.rate_limiting_rules(rule_type);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_is_active ON public.rate_limiting_rules(is_active);

-- Rate limiting violations indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_user_id ON public.rate_limiting_violations(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_ip_address ON public.rate_limiting_violations(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_rule_id ON public.rate_limiting_violations(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_is_blocked ON public.rate_limiting_violations(is_blocked);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_created_at ON public.rate_limiting_violations(created_at);

-- Rate limiting counters indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_user_id ON public.rate_limiting_counters(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_ip_address ON public.rate_limiting_counters(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_rule_id ON public.rate_limiting_counters(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_window_start ON public.rate_limiting_counters(window_start);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_window_end ON public.rate_limiting_counters(window_end);

-- Rate limiting exemptions indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_user_id ON public.rate_limiting_exemptions(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_ip_address ON public.rate_limiting_exemptions(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_rule_id ON public.rate_limiting_exemptions(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_is_active ON public.rate_limiting_exemptions(is_active);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_expires_at ON public.rate_limiting_exemptions(expires_at);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.rate_limiting_rules IS 'Rate limiting rules configuration for document signing platform';
COMMENT ON TABLE public.rate_limiting_violations IS 'Rate limiting violations tracking and blocking';
COMMENT ON TABLE public.rate_limiting_counters IS 'Real-time rate limiting counters for tracking usage';
COMMENT ON TABLE public.rate_limiting_exemptions IS 'Rate limiting exemptions for specific users/IPs';
COMMENT ON FUNCTION public.check_rate_limit(TEXT, INET, VARCHAR) IS 'Checks if a request is within rate limits';
COMMENT ON FUNCTION public.increment_rate_limit_counter(TEXT, INET, VARCHAR) IS 'Increments rate limit counter for a request';
COMMENT ON FUNCTION public.reset_rate_limit_counter(TEXT, INET, VARCHAR) IS 'Resets rate limit counter for a user/IP';
COMMENT ON FUNCTION public.get_rate_limit_status(TEXT, INET, VARCHAR) IS 'Gets current rate limit status for a user/IP';
COMMENT ON FUNCTION public.cleanup_rate_limiting_data() IS 'Cleans up expired rate limiting data';
\n-- End of buffrsign-starter/sql/11-rate_limiting.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- ============================================================================
-- Execute SQL RPC Functions
-- ============================================================================
-- This file contains RPC functions for executing SQL queries and database operations
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- SECURE SQL EXECUTION FUNCTIONS
-- ============================================================================

-- Function to execute SQL with security checks
CREATE OR REPLACE FUNCTION execute_sql_rpc(
    sql_query TEXT,
    parameters JSONB DEFAULT '{}'::JSONB
)
RETURNS TABLE(
    success BOOLEAN,
    result JSONB,
    error_message TEXT,
    execution_time_ms INTEGER
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    execution_time INTEGER;
    result_data JSONB;
    error_msg TEXT;
    is_success BOOLEAN := FALSE;
BEGIN
    start_time := clock_timestamp();
    
    -- Security checks
    IF NOT is_admin() THEN
        RETURN QUERY SELECT 
            FALSE,
            '{}'::JSONB,
            'Access denied: Admin privileges required'::TEXT,
            0;
        RETURN;
    END IF;
    
    -- Check for dangerous SQL patterns
    IF sql_query ~* '(DROP|DELETE|TRUNCATE|ALTER|CREATE|GRANT|REVOKE)' THEN
        RETURN QUERY SELECT 
            FALSE,
            '{}'::JSONB,
            'Access denied: Dangerous SQL operations not allowed'::TEXT,
            0;
        RETURN;
    END IF;
    
    -- Check for system table access
    IF sql_query ~* '(pg_|information_schema|system)' THEN
        RETURN QUERY SELECT 
            FALSE,
            '{}'::JSONB,
            'Access denied: System table access not allowed'::TEXT,
            0;
        RETURN;
    END IF;
    
    BEGIN
        -- Execute the query (this is a simplified example)
        -- In production, you would need more sophisticated query parsing and execution
        EXECUTE sql_query INTO result_data;
        
        is_success := TRUE;
        error_msg := NULL;
        
    EXCEPTION
        WHEN OTHERS THEN
            is_success := FALSE;
            error_msg := SQLERRM;
            result_data := '{}'::JSONB;
    END;
    
    end_time := clock_timestamp();
    execution_time := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    
    RETURN QUERY SELECT 
        is_success,
        result_data,
        error_msg,
        execution_time;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to execute read-only SQL queries
CREATE OR REPLACE FUNCTION execute_readonly_sql(
    sql_query TEXT,
    parameters JSONB DEFAULT '{}'::JSONB
)
RETURNS TABLE(
    success BOOLEAN,
    result JSONB,
    error_message TEXT,
    execution_time_ms INTEGER
) AS $$
DECLARE
    start_time TIMESTAMP;
    end_time TIMESTAMP;
    execution_time INTEGER;
    result_data JSONB;
    error_msg TEXT;
    is_success BOOLEAN := FALSE;
BEGIN
    start_time := clock_timestamp();
    
    -- Security checks
    IF NOT is_admin() THEN
        RETURN QUERY SELECT 
            FALSE,
            '{}'::JSONB,
            'Access denied: Admin privileges required'::TEXT,
            0;
        RETURN;
    END IF;
    
    -- Ensure query is read-only
    IF sql_query ~* '(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|GRANT|REVOKE)' THEN
        RETURN QUERY SELECT 
            FALSE,
            '{}'::JSONB,
            'Access denied: Only read-only queries allowed'::TEXT,
            0;
        RETURN;
    END IF;
    
    BEGIN
        -- Execute the query
        EXECUTE sql_query INTO result_data;
        
        is_success := TRUE;
        error_msg := NULL;
        
    EXCEPTION
        WHEN OTHERS THEN
            is_success := FALSE;
            error_msg := SQLERRM;
            result_data := '{}'::JSONB;
    END;
    
    end_time := clock_timestamp();
    execution_time := EXTRACT(EPOCH FROM (end_time - start_time)) * 1000;
    
    RETURN QUERY SELECT 
        is_success,
        result_data,
        error_msg,
        execution_time;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- DATABASE MAINTENANCE FUNCTIONS
-- ============================================================================

-- Function to get database statistics
CREATE OR REPLACE FUNCTION get_database_stats()
RETURNS TABLE(
    table_name VARCHAR,
    row_count BIGINT,
    table_size TEXT,
    index_size TEXT,
    total_size TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        schemaname||'.'||tablename as table_name,
        n_tup_ins - n_tup_del as row_count,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as table_size,
        pg_size_pretty(pg_indexes_size(schemaname||'.'||tablename)) as index_size,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size
    FROM pg_stat_user_tables
    WHERE schemaname = 'public'
    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get table information
CREATE OR REPLACE FUNCTION get_table_info(table_name_param VARCHAR)
RETURNS TABLE(
    column_name VARCHAR,
    data_type VARCHAR,
    is_nullable VARCHAR,
    column_default TEXT,
    character_maximum_length INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.column_name::VARCHAR,
        c.data_type::VARCHAR,
        c.is_nullable::VARCHAR,
        c.column_default::TEXT,
        c.character_maximum_length
    FROM information_schema.columns c
    WHERE c.table_name = table_name_param
    AND c.table_schema = 'public'
    ORDER BY c.ordinal_position;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get index information
CREATE OR REPLACE FUNCTION get_index_info(table_name_param VARCHAR)
RETURNS TABLE(
    index_name VARCHAR,
    index_type VARCHAR,
    is_unique BOOLEAN,
    column_names TEXT,
    index_size TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        i.indexname::VARCHAR,
        i.indextype::VARCHAR,
        i.indexdef LIKE '%UNIQUE%' as is_unique,
        pg_get_indexdef(i.indexrelid) as column_names,
        pg_size_pretty(pg_relation_size(i.indexrelid)) as index_size
    FROM pg_indexes i
    WHERE i.tablename = table_name_param
    AND i.schemaname = 'public'
    ORDER BY pg_relation_size(i.indexrelid) DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- PERFORMANCE MONITORING FUNCTIONS
-- ============================================================================

-- Function to get slow queries
CREATE OR REPLACE FUNCTION get_slow_queries(limit_count INTEGER DEFAULT 10)
RETURNS TABLE(
    query TEXT,
    calls BIGINT,
    total_time DOUBLE PRECISION,
    mean_time DOUBLE PRECISION,
    rows BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        query,
        calls,
        total_time,
        mean_time,
        rows
    FROM pg_stat_statements
    ORDER BY mean_time DESC
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get table access statistics
CREATE OR REPLACE FUNCTION get_table_access_stats()
RETURNS TABLE(
    table_name VARCHAR,
    seq_scan BIGINT,
    seq_tup_read BIGINT,
    idx_scan BIGINT,
    idx_tup_fetch BIGINT,
    n_tup_ins BIGINT,
    n_tup_upd BIGINT,
    n_tup_del BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        schemaname||'.'||tablename as table_name,
        seq_scan,
        seq_tup_read,
        idx_scan,
        idx_tup_fetch,
        n_tup_ins,
        n_tup_upd,
        n_tup_del
    FROM pg_stat_user_tables
    WHERE schemaname = 'public'
    ORDER BY seq_scan + idx_scan DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- SECURITY AUDIT FUNCTIONS
-- ============================================================================

-- Function to get user permissions audit
CREATE OR REPLACE FUNCTION get_user_permissions_audit()
RETURNS TABLE(
    user_id UUID,
    email TEXT,
    role user_role,
    permissions JSONB,
    last_login TIMESTAMPTZ,
    is_active BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.email,
        p.role,
        jsonb_build_object(
            'can_view_dashboard', p.can_view_dashboard,
            'can_manage_users', p.can_manage_users,
            'can_manage_documents', p.can_manage_documents,
            'can_manage_compliance', p.can_manage_compliance,
            'can_view_analytics', p.can_view_analytics,
            'can_manage_settings', p.can_manage_settings,
            'can_access_admin_panel', p.can_access_admin_panel,
            'can_manage_super_admins', p.can_manage_super_admins,
            'can_manage_kyc', p.can_manage_kyc,
            'can_manage_templates', p.can_manage_templates
        ) as permissions,
        p.last_login_at,
        p.is_active
    FROM profiles p
    ORDER BY p.last_login_at DESC NULLS LAST;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get security events summary
CREATE OR REPLACE FUNCTION get_security_events_summary(days_back INTEGER DEFAULT 7)
RETURNS TABLE(
    event_type VARCHAR,
    event_count BIGINT,
    suspicious_count BIGINT,
    unique_users BIGINT,
    unique_ips BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        se.event_type,
        COUNT(*) as event_count,
        COUNT(*) FILTER (WHERE se.is_suspicious = true) as suspicious_count,
        COUNT(DISTINCT se.user_id) as unique_users,
        COUNT(DISTINCT se.ip_address) as unique_ips
    FROM security_events se
    WHERE se.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * days_back
    GROUP BY se.event_type
    ORDER BY event_count DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- DATA EXPORT FUNCTIONS
-- ============================================================================

-- Function to export user data
CREATE OR REPLACE FUNCTION export_user_data(user_id_param UUID)
RETURNS TABLE(
    data_type VARCHAR,
    data_json JSONB
) AS $$
BEGIN
    -- User profile data
    RETURN QUERY
    SELECT 
        'profile'::VARCHAR,
        to_jsonb(p.*)
    FROM profiles p
    WHERE p.id = user_id_param;
    
    -- User activities
    RETURN QUERY
    SELECT 
        'activities'::VARCHAR,
        jsonb_agg(to_jsonb(ua.*))
    FROM user_activities ua
    WHERE ua.user_id = user_id_param;
    
    -- User documents
    RETURN QUERY
    SELECT 
        'documents'::VARCHAR,
        jsonb_agg(to_jsonb(d.*))
    FROM documents d
    WHERE d.created_by = user_id_param;
    
    -- User signatures
    RETURN QUERY
    SELECT 
        'signatures'::VARCHAR,
        jsonb_agg(to_jsonb(s.*))
    FROM signatures s
    JOIN recipients r ON r.id = s.recipient_id
    JOIN documents d ON d.id = r.document_id
    WHERE d.created_by = user_id_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION execute_sql_rpc(TEXT, JSONB) IS 'Executes SQL queries with security checks (admin only)';
COMMENT ON FUNCTION execute_readonly_sql(TEXT, JSONB) IS 'Executes read-only SQL queries with security checks';
COMMENT ON FUNCTION get_database_stats() IS 'Gets database statistics and table sizes';
COMMENT ON FUNCTION get_table_info(VARCHAR) IS 'Gets detailed table column information';
COMMENT ON FUNCTION get_index_info(VARCHAR) IS 'Gets table index information and sizes';
COMMENT ON FUNCTION get_slow_queries(INTEGER) IS 'Gets slowest queries from pg_stat_statements';
COMMENT ON FUNCTION get_table_access_stats() IS 'Gets table access statistics and usage patterns';
COMMENT ON FUNCTION get_user_permissions_audit() IS 'Gets user permissions audit for security review';
COMMENT ON FUNCTION get_security_events_summary(INTEGER) IS 'Gets security events summary for monitoring';
COMMENT ON FUNCTION export_user_data(UUID) IS 'Exports all user data for GDPR compliance';\n-- End of buffrsign-starter/sql/8-execute_sql_rpc.sql --\n
-- =====================================================
-- BuffrSign Validation Rules and Data Integrity
-- =====================================================
-- Description: Comprehensive validation rules for document signing platform
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- VALIDATION RULES TABLES
-- =====================================================

-- Validation rules configuration table
CREATE TABLE IF NOT EXISTS public.validation_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name VARCHAR(255) NOT NULL UNIQUE,
    rule_type VARCHAR(50) NOT NULL CHECK (rule_type IN ('email', 'password', 'document', 'signature', 'user_profile', 'business_rule')),
    target_table VARCHAR(255),
    target_column VARCHAR(255),
    validation_pattern TEXT,
    validation_function TEXT,
    error_message TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    severity VARCHAR(20) NOT NULL DEFAULT 'error' CHECK (severity IN ('error', 'warning', 'info')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Validation results table
CREATE TABLE IF NOT EXISTS public.validation_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_id UUID NOT NULL REFERENCES public.validation_rules(id) ON DELETE CASCADE,
    target_id TEXT NOT NULL, -- ID of the record being validated
    target_table VARCHAR(255) NOT NULL,
    is_valid BOOLEAN NOT NULL,
    error_message TEXT,
    validation_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Document validation rules table
CREATE TABLE IF NOT EXISTS public.document_validation_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_type VARCHAR(50) NOT NULL,
    required_fields JSONB NOT NULL DEFAULT '[]',
    optional_fields JSONB NOT NULL DEFAULT '[]',
    field_validation_rules JSONB NOT NULL DEFAULT '{}',
    file_size_limit_mb INTEGER DEFAULT 10,
    allowed_file_types TEXT[] DEFAULT ARRAY['pdf', 'doc', 'docx'],
    signature_requirements JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- VALIDATION FUNCTIONS
-- =====================================================

-- Function to validate email format
CREATE OR REPLACE FUNCTION public.validate_email_format(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate password strength
CREATE OR REPLACE FUNCTION public.validate_password_strength(password TEXT)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
    has_upper BOOLEAN;
    has_lower BOOLEAN;
    has_digit BOOLEAN;
    has_special BOOLEAN;
    is_valid BOOLEAN;
BEGIN
    -- Check password requirements
    has_upper := password ~ '[A-Z]';
    has_lower := password ~ '[a-z]';
    has_digit := password ~ '[0-9]';
    has_special := password ~ '[^A-Za-z0-9]';
    
    is_valid := LENGTH(password) >= 8 AND has_upper AND has_lower AND has_digit AND has_special;
    
    result := jsonb_build_object(
        'is_valid', is_valid,
        'length_ok', LENGTH(password) >= 8,
        'has_uppercase', has_upper,
        'has_lowercase', has_lower,
        'has_digit', has_digit,
        'has_special', has_special,
        'requirements', jsonb_build_object(
            'min_length', 8,
            'require_uppercase', true,
            'require_lowercase', true,
            'require_digit', true,
            'require_special', true
        )
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to validate document file
CREATE OR REPLACE FUNCTION public.validate_document_file(
    file_name TEXT,
    file_size_bytes BIGINT,
    file_type TEXT
)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
    is_valid BOOLEAN := TRUE;
    errors TEXT[] := ARRAY[]::TEXT[];
    warnings TEXT[] := ARRAY[]::TEXT[];
    allowed_types TEXT[] := ARRAY['pdf', 'doc', 'docx', 'txt', 'rtf'];
    max_size_mb INTEGER := 10;
    max_size_bytes BIGINT := max_size_mb * 1024 * 1024;
BEGIN
    -- Check file extension
    IF LOWER(SPLIT_PART(file_name, '.', -1)) != LOWER(file_type) THEN
        is_valid := FALSE;
        errors := array_append(errors, 'File extension does not match file type');
    END IF;
    
    -- Check if file type is allowed
    IF NOT (LOWER(file_type) = ANY(allowed_types)) THEN
        is_valid := FALSE;
        errors := array_append(errors, 'File type not allowed. Allowed types: ' || array_to_string(allowed_types, ', '));
    END IF;
    
    -- Check file size
    IF file_size_bytes > max_size_bytes THEN
        is_valid := FALSE;
        errors := array_append(errors, 'File size exceeds limit of ' || max_size_mb || 'MB');
    ELSIF file_size_bytes > (max_size_bytes * 0.8) THEN
        warnings := array_append(warnings, 'File size is close to limit');
    END IF;
    
    -- Check if file is empty
    IF file_size_bytes = 0 THEN
        is_valid := FALSE;
        errors := array_append(errors, 'File is empty');
    END IF;
    
    result := jsonb_build_object(
        'is_valid', is_valid,
        'file_name', file_name,
        'file_size_bytes', file_size_bytes,
        'file_size_mb', ROUND(file_size_bytes::DECIMAL / (1024 * 1024), 2),
        'file_type', file_type,
        'errors', errors,
        'warnings', warnings,
        'max_size_mb', max_size_mb,
        'allowed_types', allowed_types
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to validate signature requirements
CREATE OR REPLACE FUNCTION public.validate_signature_requirements(
    document_id UUID,
    signer_email TEXT,
    signature_type VARCHAR(50)
)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
    is_valid BOOLEAN := TRUE;
    errors TEXT[] := ARRAY[]::TEXT[];
    warnings TEXT[] := ARRAY[]::TEXT[];
    doc_record RECORD;
    signer_record RECORD;
BEGIN
    -- Get document information
    SELECT * INTO doc_record 
    FROM public.documents 
    WHERE id = document_id;
    
    IF doc_record IS NULL THEN
        RETURN jsonb_build_object(
            'is_valid', FALSE,
            'errors', ARRAY['Document not found'],
            'warnings', ARRAY[]::TEXT[]
        );
    END IF;
    
    -- Get signer information
    SELECT * INTO signer_record 
    FROM public.profiles 
    WHERE email = signer_email;
    
    -- Validate signer email format
    IF NOT public.validate_email_format(signer_email) THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Invalid signer email format');
    END IF;
    
    -- Check if signer exists
    IF signer_record IS NULL THEN
        warnings := array_append(warnings, 'Signer not found in system - will be invited');
    END IF;
    
    -- Validate signature type
    IF signature_type NOT IN ('electronic', 'digital', 'wet_signature') THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Invalid signature type');
    END IF;
    
    -- Check document status
    IF doc_record.status NOT IN ('pending_signature', 'draft') THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Document is not available for signing');
    END IF;
    
    result := jsonb_build_object(
        'is_valid', is_valid,
        'document_id', document_id,
        'signer_email', signer_email,
        'signature_type', signature_type,
        'errors', errors,
        'warnings', warnings,
        'document_status', doc_record.status,
        'signer_exists', signer_record IS NOT NULL
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to validate user profile data
CREATE OR REPLACE FUNCTION public.validate_user_profile(
    profile_data JSONB
)
RETURNS JSONB AS $$
DECLARE
    result JSONB;
    is_valid BOOLEAN := TRUE;
    errors TEXT[] := ARRAY[]::TEXT[];
    warnings TEXT[] := ARRAY[]::TEXT[];
    email TEXT;
    first_name TEXT;
    last_name TEXT;
    phone TEXT;
BEGIN
    -- Extract data
    email := profile_data->>'email';
    first_name := profile_data->>'first_name';
    last_name := profile_data->>'last_name';
    phone := profile_data->>'phone';
    
    -- Validate email
    IF email IS NULL OR email = '' THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Email is required');
    ELSIF NOT public.validate_email_format(email) THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Invalid email format');
    END IF;
    
    -- Validate first name
    IF first_name IS NULL OR first_name = '' THEN
        is_valid := FALSE;
        errors := array_append(errors, 'First name is required');
    ELSIF LENGTH(first_name) < 2 THEN
        is_valid := FALSE;
        errors := array_append(errors, 'First name must be at least 2 characters');
    ELSIF LENGTH(first_name) > 50 THEN
        is_valid := FALSE;
        errors := array_append(errors, 'First name must be less than 50 characters');
    END IF;
    
    -- Validate last name
    IF last_name IS NULL OR last_name = '' THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Last name is required');
    ELSIF LENGTH(last_name) < 2 THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Last name must be at least 2 characters');
    ELSIF LENGTH(last_name) > 50 THEN
        is_valid := FALSE;
        errors := array_append(errors, 'Last name must be less than 50 characters');
    END IF;
    
    -- Validate phone (optional)
    IF phone IS NOT NULL AND phone != '' THEN
        IF NOT phone ~ '^\+?[1-9]\d{1,14}$' THEN
            warnings := array_append(warnings, 'Phone number format may be invalid');
        END IF;
    END IF;
    
    result := jsonb_build_object(
        'is_valid', is_valid,
        'errors', errors,
        'warnings', warnings,
        'validated_data', jsonb_build_object(
            'email', email,
            'first_name', first_name,
            'last_name', last_name,
            'phone', phone
        )
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to run validation rules
CREATE OR REPLACE FUNCTION public.run_validation_rules(
    target_table VARCHAR(255),
    target_id TEXT,
    validation_data JSONB
)
RETURNS JSONB AS $$
DECLARE
    rule_record RECORD;
    validation_result JSONB;
    all_results JSONB := '[]'::JSONB;
    is_valid BOOLEAN := TRUE;
    errors TEXT[] := ARRAY[]::TEXT[];
    warnings TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- Get all active validation rules for the target table
    FOR rule_record IN 
        SELECT * FROM public.validation_rules 
        WHERE target_table = run_validation_rules.target_table 
        AND is_active = TRUE
    LOOP
        -- Run validation based on rule type
        CASE rule_record.rule_type
            WHEN 'email' THEN
                IF NOT public.validate_email_format(validation_data->>'email') THEN
                    is_valid := FALSE;
                    errors := array_append(errors, rule_record.error_message);
                END IF;
            WHEN 'password' THEN
                validation_result := public.validate_password_strength(validation_data->>'password');
                IF NOT (validation_result->>'is_valid')::BOOLEAN THEN
                    is_valid := FALSE;
                    errors := array_append(errors, rule_record.error_message);
                END IF;
            WHEN 'user_profile' THEN
                validation_result := public.validate_user_profile(validation_data);
                IF NOT (validation_result->>'is_valid')::BOOLEAN THEN
                    is_valid := FALSE;
                    errors := array_append(errors, rule_record.error_message);
                END IF;
        END CASE;
        
        -- Store validation result
        INSERT INTO public.validation_results (
            rule_id, target_id, target_table, is_valid, 
            error_message, validation_data
        ) VALUES (
            rule_record.id, target_id, target_table, is_valid,
            rule_record.error_message, validation_data
        );
        
        -- Add to results array
        all_results := all_results || jsonb_build_object(
            'rule_name', rule_record.rule_name,
            'rule_type', rule_record.rule_type,
            'is_valid', is_valid,
            'error_message', rule_record.error_message
        );
    END LOOP;
    
    RETURN jsonb_build_object(
        'overall_valid', is_valid,
        'errors', errors,
        'warnings', warnings,
        'validation_results', all_results
    );
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- VALIDATION TRIGGERS
-- =====================================================

-- Trigger function for user profile validation
CREATE OR REPLACE FUNCTION public.validate_user_profile_trigger()
RETURNS TRIGGER AS $$
DECLARE
    validation_result JSONB;
    profile_data JSONB;
BEGIN
    -- Prepare profile data for validation
    profile_data := jsonb_build_object(
        'email', NEW.email,
        'first_name', NEW.first_name,
        'last_name', NEW.last_name,
        'phone', NEW.phone
    );
    
    -- Run validation
    validation_result := public.validate_user_profile(profile_data);
    
    -- Check if validation passed
    IF NOT (validation_result->>'is_valid')::BOOLEAN THEN
        RAISE EXCEPTION 'Profile validation failed: %', 
            array_to_string((validation_result->'errors')::TEXT[], ', ');
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_user_profile
    BEFORE INSERT OR UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.validate_user_profile_trigger();

-- Trigger function for document validation
CREATE OR REPLACE FUNCTION public.validate_document_trigger()
RETURNS TRIGGER AS $$
DECLARE
    validation_result JSONB;
BEGIN
    -- Validate document file if file_path is provided
    IF NEW.file_path IS NOT NULL AND NEW.file_path != '' THEN
        validation_result := public.validate_document_file(
            NEW.file_name,
            NEW.file_size_bytes,
            NEW.file_type
        );
        
        -- Check if validation passed
        IF NOT (validation_result->>'is_valid')::BOOLEAN THEN
            RAISE EXCEPTION 'Document validation failed: %', 
                array_to_string((validation_result->'errors')::TEXT[], ', ');
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_document
    BEFORE INSERT OR UPDATE ON public.documents
    FOR EACH ROW EXECUTE FUNCTION public.validate_document_trigger();

-- =====================================================
-- DEFAULT VALIDATION RULES
-- =====================================================

-- Insert default validation rules
INSERT INTO public.validation_rules (rule_name, rule_type, target_table, target_column, error_message, description) VALUES
('email_format_validation', 'email', 'profiles', 'email', 'Invalid email format', 'Validates email format for user profiles'),
('password_strength_validation', 'password', 'profiles', 'password', 'Password does not meet strength requirements', 'Validates password strength'),
('first_name_required', 'user_profile', 'profiles', 'first_name', 'First name is required', 'Validates that first name is provided'),
('last_name_required', 'user_profile', 'profiles', 'last_name', 'Last name is required', 'Validates that last name is provided'),
('document_file_validation', 'document', 'documents', 'file_path', 'Document file validation failed', 'Validates document file format and size'),
('signature_requirements_validation', 'signature', 'signatures', 'signer_email', 'Signature requirements not met', 'Validates signature requirements')
ON CONFLICT (rule_name) DO NOTHING;

-- Insert default document validation rules
INSERT INTO public.document_validation_rules (document_type, required_fields, optional_fields, field_validation_rules, file_size_limit_mb, allowed_file_types, signature_requirements) VALUES
('contract', '["title", "parties", "terms"]', '["attachments", "notes"]', '{"title": {"min_length": 5, "max_length": 200}}', 10, ARRAY['pdf', 'doc', 'docx'], '{"min_signatures": 2, "require_witness": false}'),
('agreement', '["title", "parties"]', '["terms", "conditions"]', '{"title": {"min_length": 3, "max_length": 100}}', 5, ARRAY['pdf', 'doc', 'docx'], '{"min_signatures": 1, "require_witness": false}'),
('nda', '["title", "parties", "confidentiality_terms"]', '["duration", "scope"]', '{"title": {"min_length": 3, "max_length": 150}}', 5, ARRAY['pdf', 'doc', 'docx'], '{"min_signatures": 2, "require_witness": true}')
ON CONFLICT DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR VALIDATION TABLES
-- =====================================================

-- Enable RLS on validation tables
ALTER TABLE public.validation_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.validation_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_validation_rules ENABLE ROW LEVEL SECURITY;

-- Validation rules policies
CREATE POLICY "Admin users can view validation rules" ON public.validation_rules
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "Admin users can modify validation rules" ON public.validation_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- Validation results policies
CREATE POLICY "Users can view own validation results" ON public.validation_results
    FOR SELECT USING (
        target_id = auth.uid()::text
    );

CREATE POLICY "Admin users can view all validation results" ON public.validation_results
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- Document validation rules policies
CREATE POLICY "All users can view document validation rules" ON public.document_validation_rules
    FOR SELECT USING (true);

CREATE POLICY "Admin users can modify document validation rules" ON public.document_validation_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- =====================================================
-- INDEXES FOR VALIDATION TABLES
-- =====================================================

-- Validation rules indexes
CREATE INDEX IF NOT EXISTS idx_validation_rules_rule_name ON public.validation_rules(rule_name);
CREATE INDEX IF NOT EXISTS idx_validation_rules_rule_type ON public.validation_rules(rule_type);
CREATE INDEX IF NOT EXISTS idx_validation_rules_target_table ON public.validation_rules(target_table);
CREATE INDEX IF NOT EXISTS idx_validation_rules_is_active ON public.validation_rules(is_active);

-- Validation results indexes
CREATE INDEX IF NOT EXISTS idx_validation_results_rule_id ON public.validation_results(rule_id);
CREATE INDEX IF NOT EXISTS idx_validation_results_target_id ON public.validation_results(target_id);
CREATE INDEX IF NOT EXISTS idx_validation_results_target_table ON public.validation_results(target_table);
CREATE INDEX IF NOT EXISTS idx_validation_results_is_valid ON public.validation_results(is_valid);
CREATE INDEX IF NOT EXISTS idx_validation_results_created_at ON public.validation_results(created_at);

-- Document validation rules indexes
CREATE INDEX IF NOT EXISTS idx_document_validation_rules_document_type ON public.document_validation_rules(document_type);
CREATE INDEX IF NOT EXISTS idx_document_validation_rules_is_active ON public.document_validation_rules(is_active);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.validation_rules IS 'Validation rules configuration for data integrity';
COMMENT ON TABLE public.validation_results IS 'Validation results tracking and history';
COMMENT ON TABLE public.document_validation_rules IS 'Document-specific validation rules and requirements';
COMMENT ON FUNCTION public.validate_email_format(TEXT) IS 'Validates email format using regex pattern';
COMMENT ON FUNCTION public.validate_password_strength(TEXT) IS 'Validates password strength requirements';
COMMENT ON FUNCTION public.validate_document_file(TEXT, BIGINT, TEXT) IS 'Validates document file format, size, and type';
COMMENT ON FUNCTION public.validate_signature_requirements(UUID, TEXT, VARCHAR) IS 'Validates signature requirements for documents';
COMMENT ON FUNCTION public.validate_user_profile(JSONB) IS 'Validates user profile data completeness and format';
COMMENT ON FUNCTION public.run_validation_rules(VARCHAR, TEXT, JSONB) IS 'Runs all validation rules for a specific target';
\n-- End of buffrsign-starter/sql/10-validation_rules.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- ============================================================================
-- Background Tasks and Redis Session Management
-- ============================================================================
-- This file contains background task processing and Redis session management
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- BACKGROUND TASK FUNCTIONS
-- ============================================================================

-- Function to add background task
CREATE OR REPLACE FUNCTION add_background_task(
    p_queue_name VARCHAR,
    p_task_type VARCHAR,
    p_task_data JSONB,
    p_priority INTEGER DEFAULT 0,
    p_scheduled_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    p_max_attempts INTEGER DEFAULT 3
)
RETURNS UUID AS $$
DECLARE
    task_id UUID;
BEGIN
    INSERT INTO background_tasks (
        queue_name,
        task_type,
        task_data,
        priority,
        scheduled_at,
        max_attempts
    ) VALUES (
        p_queue_name,
        p_task_type,
        p_task_data,
        p_priority,
        p_scheduled_at,
        p_max_attempts
    ) RETURNING id INTO task_id;
    
    RETURN task_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get next background task
CREATE OR REPLACE FUNCTION get_next_background_task(p_queue_name VARCHAR)
RETURNS TABLE(
    id UUID,
    task_type VARCHAR,
    task_data JSONB,
    priority INTEGER,
    attempts INTEGER,
    max_attempts INTEGER
) AS $$
BEGIN
    RETURN QUERY
    UPDATE background_tasks
    SET 
        status = 'processing',
        started_at = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = (
        SELECT bt.id
        FROM background_tasks bt
        WHERE bt.queue_name = p_queue_name
        AND bt.status = 'pending'
        AND bt.scheduled_at <= CURRENT_TIMESTAMP
        AND bt.attempts < bt.max_attempts
        ORDER BY bt.priority DESC, bt.scheduled_at ASC
        LIMIT 1
        FOR UPDATE SKIP LOCKED
    )
    RETURNING 
        background_tasks.id,
        background_tasks.task_type,
        background_tasks.task_data,
        background_tasks.priority,
        background_tasks.attempts,
        background_tasks.max_attempts;
END;
$$ LANGUAGE plpgsql;

-- Function to complete background task
CREATE OR REPLACE FUNCTION complete_background_task(
    p_task_id UUID,
    p_status VARCHAR DEFAULT 'completed',
    p_error_message TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE background_tasks
    SET 
        status = p_status,
        completed_at = CASE WHEN p_status = 'completed' THEN CURRENT_TIMESTAMP ELSE NULL END,
        error_message = p_error_message,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_task_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to retry background task
CREATE OR REPLACE FUNCTION retry_background_task(p_task_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE background_tasks
    SET 
        status = 'pending',
        attempts = attempts + 1,
        started_at = NULL,
        completed_at = NULL,
        error_message = NULL,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_task_id
    AND attempts < max_attempts;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- REDIS SESSION FUNCTIONS
-- ============================================================================

-- Function to create Redis session
CREATE OR REPLACE FUNCTION create_redis_session(
    p_session_id VARCHAR,
    p_user_id UUID,
    p_session_data JSONB,
    p_expires_at TIMESTAMP
)
RETURNS UUID AS $$
DECLARE
    session_uuid UUID;
BEGIN
    INSERT INTO redis_sessions (
        session_id,
        user_id,
        session_data,
        expires_at
    ) VALUES (
        p_session_id,
        p_user_id,
        p_session_data,
        p_expires_at
    ) RETURNING id INTO session_uuid;
    
    RETURN session_uuid;
END;
$$ LANGUAGE plpgsql;

-- Function to get Redis session
CREATE OR REPLACE FUNCTION get_redis_session(p_session_id VARCHAR)
RETURNS TABLE(
    id UUID,
    user_id UUID,
    session_data JSONB,
    expires_at TIMESTAMP,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rs.id,
        rs.user_id,
        rs.session_data,
        rs.expires_at,
        rs.created_at
    FROM redis_sessions rs
    WHERE rs.session_id = p_session_id
    AND rs.expires_at > CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- Function to update Redis session
CREATE OR REPLACE FUNCTION update_redis_session(
    p_session_id VARCHAR,
    p_session_data JSONB,
    p_expires_at TIMESTAMP DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE redis_sessions
    SET 
        session_data = p_session_data,
        expires_at = COALESCE(p_expires_at, redis_sessions.expires_at),
        updated_at = CURRENT_TIMESTAMP
    WHERE session_id = p_session_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to delete Redis session
CREATE OR REPLACE FUNCTION delete_redis_session(p_session_id VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    DELETE FROM redis_sessions
    WHERE session_id = p_session_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup expired sessions
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM redis_sessions WHERE expires_at < CURRENT_TIMESTAMP;
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- JWT BLACKLIST FUNCTIONS
-- ============================================================================

-- Function to add JWT to blacklist
CREATE OR REPLACE FUNCTION add_jwt_to_blacklist(
    p_token_hash VARCHAR,
    p_user_id UUID,
    p_expires_at TIMESTAMP,
    p_reason VARCHAR DEFAULT 'logout'
)
RETURNS UUID AS $$
DECLARE
    blacklist_id UUID;
BEGIN
    INSERT INTO jwt_blacklist (
        token_hash,
        user_id,
        expires_at,
        reason
    ) VALUES (
        p_token_hash,
        p_user_id,
        p_expires_at,
        p_reason
    ) RETURNING id INTO blacklist_id;
    
    RETURN blacklist_id;
END;
$$ LANGUAGE plpgsql;

-- Function to check if JWT is blacklisted
CREATE OR REPLACE FUNCTION is_jwt_blacklisted(p_token_hash VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM jwt_blacklist
        WHERE token_hash = p_token_hash
        AND expires_at > CURRENT_TIMESTAMP
    );
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup expired JWT blacklist
CREATE OR REPLACE FUNCTION cleanup_expired_jwt_blacklist()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM jwt_blacklist WHERE expires_at < CURRENT_TIMESTAMP;
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- REALTIME EVENTS FUNCTIONS
-- ============================================================================

-- Function to log realtime event
CREATE OR REPLACE FUNCTION log_realtime_event(
    p_event_type VARCHAR,
    p_channel VARCHAR DEFAULT NULL,
    p_user_id UUID DEFAULT NULL,
    p_document_id UUID DEFAULT NULL,
    p_event_data JSONB DEFAULT NULL,
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    event_id UUID;
BEGIN
    INSERT INTO realtime_events (
        event_type,
        channel,
        user_id,
        document_id,
        event_data,
        ip_address,
        user_agent
    ) VALUES (
        p_event_type,
        p_channel,
        p_user_id,
        p_document_id,
        p_event_data,
        p_ip_address,
        p_user_agent
    ) RETURNING id INTO event_id;
    
    RETURN event_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get realtime events
CREATE OR REPLACE FUNCTION get_realtime_events(
    p_user_id UUID DEFAULT NULL,
    p_document_id UUID DEFAULT NULL,
    p_event_type VARCHAR DEFAULT NULL,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE(
    id UUID,
    event_type VARCHAR,
    channel VARCHAR,
    user_id UUID,
    document_id UUID,
    event_data JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        re.id,
        re.event_type,
        re.channel,
        re.user_id,
        re.document_id,
        re.event_data,
        re.ip_address,
        re.user_agent,
        re.created_at
    FROM realtime_events re
    WHERE (p_user_id IS NULL OR re.user_id = p_user_id)
    AND (p_document_id IS NULL OR re.document_id = p_document_id)
    AND (p_event_type IS NULL OR re.event_type = p_event_type)
    ORDER BY re.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- RATE LIMITING FUNCTIONS
-- ============================================================================

-- Function to log rate limit event
CREATE OR REPLACE FUNCTION log_rate_limit_event(
    p_identifier VARCHAR,
    p_limit_type VARCHAR,
    p_request_count INTEGER,
    p_window_start TIMESTAMP,
    p_window_end TIMESTAMP,
    p_is_blocked BOOLEAN,
    p_ip_address INET DEFAULT NULL,
    p_user_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    log_id UUID;
BEGIN
    INSERT INTO rate_limit_logs (
        identifier,
        limit_type,
        request_count,
        window_start,
        window_end,
        is_blocked,
        ip_address,
        user_id
    ) VALUES (
        p_identifier,
        p_limit_type,
        p_request_count,
        p_window_start,
        p_window_end,
        p_is_blocked,
        p_ip_address,
        p_user_id
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get rate limit statistics
CREATE OR REPLACE FUNCTION get_rate_limit_stats(
    p_identifier VARCHAR DEFAULT NULL,
    p_limit_type VARCHAR DEFAULT NULL,
    p_hours_back INTEGER DEFAULT 24
)
RETURNS TABLE(
    identifier VARCHAR,
    limit_type VARCHAR,
    total_requests BIGINT,
    blocked_requests BIGINT,
    unique_ips BIGINT,
    unique_users BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rl.identifier,
        rl.limit_type,
        COUNT(*) as total_requests,
        COUNT(*) FILTER (WHERE rl.is_blocked = true) as blocked_requests,
        COUNT(DISTINCT rl.ip_address) as unique_ips,
        COUNT(DISTINCT rl.user_id) as unique_users
    FROM rate_limit_logs rl
    WHERE (p_identifier IS NULL OR rl.identifier = p_identifier)
    AND (p_limit_type IS NULL OR rl.limit_type = p_limit_type)
    AND rl.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour' * p_hours_back
    GROUP BY rl.identifier, rl.limit_type
    ORDER BY total_requests DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- REDIS CACHE METADATA FUNCTIONS
-- ============================================================================

-- Function to create cache metadata
CREATE OR REPLACE FUNCTION create_cache_metadata(
    p_cache_key VARCHAR,
    p_cache_type VARCHAR,
    p_entity_id UUID DEFAULT NULL,
    p_entity_type VARCHAR DEFAULT NULL,
    p_ttl_seconds INTEGER DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    metadata_id UUID;
BEGIN
    INSERT INTO redis_cache_metadata (
        cache_key,
        cache_type,
        entity_id,
        entity_type,
        ttl_seconds,
        expires_at
    ) VALUES (
        p_cache_key,
        p_cache_type,
        p_entity_id,
        p_entity_type,
        p_ttl_seconds,
        CASE WHEN p_ttl_seconds IS NOT NULL THEN CURRENT_TIMESTAMP + INTERVAL '1 second' * p_ttl_seconds ELSE NULL END
    ) RETURNING id INTO metadata_id;
    
    RETURN metadata_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update cache access
CREATE OR REPLACE FUNCTION update_cache_access(p_cache_key VARCHAR)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE redis_cache_metadata
    SET 
        last_accessed = CURRENT_TIMESTAMP,
        access_count = access_count + 1
    WHERE cache_key = p_cache_key;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup expired cache metadata
CREATE OR REPLACE FUNCTION cleanup_expired_cache_metadata()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM redis_cache_metadata 
    WHERE expires_at IS NOT NULL 
    AND expires_at < CURRENT_TIMESTAMP;
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SYSTEM HEALTH FUNCTIONS
-- ============================================================================

-- Function to get Redis integration health
CREATE OR REPLACE FUNCTION get_redis_integration_health()
RETURNS TABLE(
    metric_name VARCHAR,
    metric_value BIGINT,
    metric_description TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'active_sessions'::VARCHAR(100),
        COUNT(*)::BIGINT,
        'Number of active Redis sessions'::TEXT
    FROM redis_sessions 
    WHERE expires_at > CURRENT_TIMESTAMP
    
    UNION ALL
    
    SELECT 
        'blacklisted_tokens'::VARCHAR(100),
        COUNT(*)::BIGINT,
        'Number of blacklisted JWT tokens'::TEXT
    FROM jwt_blacklist 
    WHERE expires_at > CURRENT_TIMESTAMP
    
    UNION ALL
    
    SELECT 
        'pending_tasks'::VARCHAR(100),
        COUNT(*)::BIGINT,
        'Number of pending background tasks'::TEXT
    FROM background_tasks 
    WHERE status = 'pending'
    
    UNION ALL
    
    SELECT 
        'failed_tasks'::VARCHAR(100),
        COUNT(*)::BIGINT,
        'Number of failed background tasks'::TEXT
    FROM background_tasks 
    WHERE status = 'failed'
    
    UNION ALL
    
    SELECT 
        'realtime_events_today'::VARCHAR(100),
        COUNT(*)::BIGINT,
        'Number of real-time events today'::TEXT
    FROM realtime_events 
    WHERE created_at >= CURRENT_DATE;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION add_background_task(VARCHAR, VARCHAR, JSONB, INTEGER, TIMESTAMP, INTEGER) IS 'Adds new background task to processing queue';
COMMENT ON FUNCTION get_next_background_task(VARCHAR) IS 'Gets next available background task from queue';
COMMENT ON FUNCTION complete_background_task(UUID, VARCHAR, TEXT) IS 'Marks background task as completed or failed';
COMMENT ON FUNCTION retry_background_task(UUID) IS 'Retries failed background task';
COMMENT ON FUNCTION create_redis_session(VARCHAR, UUID, JSONB, TIMESTAMP) IS 'Creates new Redis session';
COMMENT ON FUNCTION get_redis_session(VARCHAR) IS 'Gets Redis session by session ID';
COMMENT ON FUNCTION update_redis_session(VARCHAR, JSONB, TIMESTAMP) IS 'Updates Redis session data';
COMMENT ON FUNCTION delete_redis_session(VARCHAR) IS 'Deletes Redis session';
COMMENT ON FUNCTION cleanup_expired_sessions() IS 'Cleans up expired Redis sessions';
COMMENT ON FUNCTION add_jwt_to_blacklist(VARCHAR, UUID, TIMESTAMP, VARCHAR) IS 'Adds JWT token to blacklist';
COMMENT ON FUNCTION is_jwt_blacklisted(VARCHAR) IS 'Checks if JWT token is blacklisted';
COMMENT ON FUNCTION cleanup_expired_jwt_blacklist() IS 'Cleans up expired JWT blacklist entries';
COMMENT ON FUNCTION log_realtime_event(VARCHAR, VARCHAR, UUID, UUID, JSONB, INET, TEXT) IS 'Logs realtime event for analytics';
COMMENT ON FUNCTION get_realtime_events(UUID, UUID, VARCHAR, INTEGER) IS 'Gets realtime events with filtering';
COMMENT ON FUNCTION log_rate_limit_event(VARCHAR, VARCHAR, INTEGER, TIMESTAMP, TIMESTAMP, BOOLEAN, INET, UUID) IS 'Logs rate limiting event';
COMMENT ON FUNCTION get_rate_limit_stats(VARCHAR, VARCHAR, INTEGER) IS 'Gets rate limiting statistics';
COMMENT ON FUNCTION create_cache_metadata(VARCHAR, VARCHAR, UUID, VARCHAR, INTEGER) IS 'Creates cache metadata entry';
COMMENT ON FUNCTION update_cache_access(VARCHAR) IS 'Updates cache access statistics';
COMMENT ON FUNCTION cleanup_expired_cache_metadata() IS 'Cleans up expired cache metadata';
COMMENT ON FUNCTION get_redis_integration_health() IS 'Gets Redis integration health metrics';
\n-- End of buffrsign-starter/sql/7-background_tasks_redis.sql --\n
-- ============================================================================
-- Row Level Security (RLS) Policies for Documents and Signatures
-- ============================================================================
-- This file contains RLS policies for document management and signature processing
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- ENABLE ROW LEVEL SECURITY
-- ============================================================================

-- Enable RLS on documents table
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Enable RLS on recipients table
ALTER TABLE recipients ENABLE ROW LEVEL SECURITY;

-- Enable RLS on signatures table
ALTER TABLE signatures ENABLE ROW LEVEL SECURITY;

-- Enable RLS on document_fields table
ALTER TABLE document_fields ENABLE ROW LEVEL SECURITY;

-- Enable RLS on document_versions table
ALTER TABLE document_versions ENABLE ROW LEVEL SECURITY;

-- Enable RLS on audit_trail table
ALTER TABLE audit_trail ENABLE ROW LEVEL SECURITY;

-- Enable RLS on document_processing_status table
ALTER TABLE document_processing_status ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- DOCUMENTS TABLE POLICIES
-- ============================================================================

-- Users can view documents they created
CREATE POLICY "Users can view own documents" ON documents
    FOR SELECT USING (auth.uid() = created_by);

-- Users can insert documents
CREATE POLICY "Users can create documents" ON documents
    FOR INSERT WITH CHECK (auth.uid() = created_by);

-- Users can update their own documents
CREATE POLICY "Users can update own documents" ON documents
    FOR UPDATE USING (auth.uid() = created_by);

-- Users can delete their own documents
CREATE POLICY "Users can delete own documents" ON documents
    FOR DELETE USING (auth.uid() = created_by);

-- Recipients can view documents they are invited to
CREATE POLICY "Recipients can view invited documents" ON documents
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM recipients r
            WHERE r.document_id = documents.id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Admins can view all documents
CREATE POLICY "Admins can view all documents" ON documents
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- Admins can manage all documents
CREATE POLICY "Admins can manage all documents" ON documents
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- RECIPIENTS TABLE POLICIES
-- ============================================================================

-- Document creators can view recipients of their documents
CREATE POLICY "Document creators can view recipients" ON recipients
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = recipients.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Recipients can view their own recipient records
CREATE POLICY "Recipients can view own records" ON recipients
    FOR SELECT USING (
        email = (SELECT email FROM auth.users WHERE id = auth.uid())
    );

-- Document creators can insert recipients
CREATE POLICY "Document creators can add recipients" ON recipients
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = recipients.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Document creators can update recipients
CREATE POLICY "Document creators can update recipients" ON recipients
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = recipients.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Document creators can delete recipients
CREATE POLICY "Document creators can delete recipients" ON recipients
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = recipients.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Admins can manage all recipients
CREATE POLICY "Admins can manage all recipients" ON recipients
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- SIGNATURES TABLE POLICIES
-- ============================================================================

-- Document creators can view signatures for their documents
CREATE POLICY "Document creators can view signatures" ON signatures
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = signatures.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Recipients can view their own signatures
CREATE POLICY "Recipients can view own signatures" ON signatures
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM recipients r
            WHERE r.id = signatures.recipient_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Recipients can insert their own signatures
CREATE POLICY "Recipients can create signatures" ON signatures
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM recipients r
            WHERE r.id = signatures.recipient_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Recipients can update their own signatures (before completion)
CREATE POLICY "Recipients can update own signatures" ON signatures
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM recipients r
            WHERE r.id = signatures.recipient_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
            AND r.status = 'pending'
        )
    );

-- Admins can manage all signatures
CREATE POLICY "Admins can manage all signatures" ON signatures
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- DOCUMENT FIELDS TABLE POLICIES
-- ============================================================================

-- Document creators can manage fields for their documents
CREATE POLICY "Document creators can manage fields" ON document_fields
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = document_fields.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Recipients can view fields for documents they are invited to
CREATE POLICY "Recipients can view fields" ON document_fields
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            JOIN recipients r ON r.document_id = d.id
            WHERE d.id = document_fields.document_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Admins can manage all document fields
CREATE POLICY "Admins can manage all fields" ON document_fields
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- DOCUMENT VERSIONS TABLE POLICIES
-- ============================================================================

-- Document creators can manage versions of their documents
CREATE POLICY "Document creators can manage versions" ON document_versions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = document_versions.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Recipients can view versions of documents they are invited to
CREATE POLICY "Recipients can view versions" ON document_versions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            JOIN recipients r ON r.document_id = d.id
            WHERE d.id = document_versions.document_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Admins can manage all document versions
CREATE POLICY "Admins can manage all versions" ON document_versions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- ============================================================================
-- AUDIT TRAIL TABLE POLICIES
-- ============================================================================

-- Document creators can view audit trail for their documents
CREATE POLICY "Document creators can view audit trail" ON audit_trail
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = audit_trail.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Users can view audit trail for their own actions
CREATE POLICY "Users can view own audit trail" ON audit_trail
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all audit trails
CREATE POLICY "Admins can view all audit trails" ON audit_trail
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- System can insert audit trail entries
CREATE POLICY "System can insert audit trail" ON audit_trail
    FOR INSERT WITH CHECK (true);

-- ============================================================================
-- DOCUMENT PROCESSING STATUS TABLE POLICIES
-- ============================================================================

-- Document creators can view processing status for their documents
CREATE POLICY "Document creators can view processing status" ON document_processing_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            WHERE d.id = document_processing_status.document_id
            AND d.created_by = auth.uid()
        )
    );

-- Recipients can view processing status for documents they are invited to
CREATE POLICY "Recipients can view processing status" ON document_processing_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM documents d
            JOIN recipients r ON r.document_id = d.id
            WHERE d.id = document_processing_status.document_id
            AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
        )
    );

-- Admins can view all processing status
CREATE POLICY "Admins can view all processing status" ON document_processing_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'super_admin')
        )
    );

-- System can insert and update processing status
CREATE POLICY "System can manage processing status" ON document_processing_status
    FOR ALL WITH CHECK (true);

-- ============================================================================
-- HELPER FUNCTIONS FOR RLS
-- ============================================================================

-- Function to check if user is document creator
CREATE OR REPLACE FUNCTION is_document_creator(document_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM documents 
        WHERE id = document_id 
        AND created_by = auth.uid()
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user is document recipient
CREATE OR REPLACE FUNCTION is_document_recipient(document_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM documents d
        JOIN recipients r ON r.document_id = d.id
        WHERE d.id = document_id
        AND r.email = (SELECT email FROM auth.users WHERE id = auth.uid())
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if user can access document
CREATE OR REPLACE FUNCTION can_access_document(document_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_document_creator(document_id) 
        OR is_document_recipient(document_id)
        OR is_admin();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- GRANT PERMISSIONS
-- ============================================================================

-- Grant usage on sequences
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- Grant select on documents for authenticated users
GRANT SELECT ON documents TO authenticated;

-- Grant select on recipients for authenticated users
GRANT SELECT ON recipients TO authenticated;

-- Grant select on signatures for authenticated users
GRANT SELECT ON signatures TO authenticated;

-- Grant select on document_fields for authenticated users
GRANT SELECT ON document_fields TO authenticated;

-- Grant select on document_versions for authenticated users
GRANT SELECT ON document_versions TO authenticated;

-- Grant select on audit_trail for authenticated users
GRANT SELECT ON audit_trail TO authenticated;

-- Grant select on document_processing_status for authenticated users
GRANT SELECT ON document_processing_status TO authenticated;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON POLICY "Users can view own documents" ON documents IS 'Allows users to view documents they created';
COMMENT ON POLICY "Users can create documents" ON documents IS 'Allows users to create new documents';
COMMENT ON POLICY "Recipients can view invited documents" ON documents IS 'Allows recipients to view documents they are invited to';
COMMENT ON POLICY "Document creators can view recipients" ON recipients IS 'Allows document creators to view recipients';
COMMENT ON POLICY "Recipients can view own records" ON recipients IS 'Allows recipients to view their own recipient records';
COMMENT ON POLICY "Document creators can view signatures" ON signatures IS 'Allows document creators to view signatures for their documents';
COMMENT ON POLICY "Recipients can view own signatures" ON signatures IS 'Allows recipients to view their own signatures';
COMMENT ON POLICY "Document creators can manage fields" ON document_fields IS 'Allows document creators to manage document fields';
COMMENT ON POLICY "Document creators can manage versions" ON document_versions IS 'Allows document creators to manage document versions';
COMMENT ON POLICY "Document creators can view audit trail" ON audit_trail IS 'Allows document creators to view audit trail for their documents';
COMMENT ON POLICY "Document creators can view processing status" ON document_processing_status IS 'Allows document creators to view processing status for their documents';

COMMENT ON FUNCTION is_document_creator(UUID) IS 'Checks if current user is the creator of a document';
COMMENT ON FUNCTION is_document_recipient(UUID) IS 'Checks if current user is a recipient of a document';
COMMENT ON FUNCTION can_access_document(UUID) IS 'Checks if current user can access a document';
\n-- End of buffrsign-starter/sql/4-documents_signatures_rls.sql --\n
-- ============================================================================
-- REALPAY INTEGRATION FOR BUFFRSIGN
-- ============================================================================
-- This file contains SQL for RealPay payment gateway integration
-- RealPay is a Namibian payment processor for local and international payments

-- RealPay configuration table
CREATE TABLE IF NOT EXISTS public.realpay_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    merchant_id TEXT NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    api_key_hash TEXT NOT NULL,
    environment TEXT DEFAULT 'sandbox' CHECK (environment IN ('sandbox', 'production')),
    webhook_secret TEXT,
    webhook_url TEXT,
    is_active BOOLEAN DEFAULT true,
    supported_currencies TEXT[] DEFAULT ARRAY['NAD', 'USD', 'ZAR', 'EUR'],
    supported_payment_methods TEXT[] DEFAULT ARRAY['card', 'bank_transfer', 'eft', 'wallet'],
    rate_limit_per_minute INTEGER DEFAULT 60,
    rate_limit_per_hour INTEGER DEFAULT 1000,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- RealPay transactions table
CREATE TABLE IF NOT EXISTS public.realpay_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id TEXT NOT NULL UNIQUE, -- RealPay transaction ID
    merchant_reference TEXT NOT NULL, -- Our internal reference
    user_id UUID NOT NULL REFERENCES auth.users(id),
    amount DECIMAL(15,2) NOT NULL,
    currency VARCHAR(3) NOT NULL DEFAULT 'NAD',
    payment_method VARCHAR(50) NOT NULL,
    status VARCHAR(50) NOT NULL CHECK (status IN (
        'pending', 'processing', 'completed', 'failed', 'cancelled', 'refunded'
    )),
    realpay_status TEXT,
    realpay_response JSONB,
    failure_reason TEXT,
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- RealPay webhook events table
CREATE TABLE IF NOT EXISTS public.realpay_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id TEXT NOT NULL UNIQUE, -- RealPay event ID
    event_type TEXT NOT NULL,
    transaction_id TEXT NOT NULL,
    merchant_reference TEXT,
    event_data JSONB NOT NULL,
    signature TEXT,
    processed BOOLEAN DEFAULT false,
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- RealPay payment methods table
CREATE TABLE IF NOT EXISTS public.realpay_payment_methods (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id),
    realpay_token TEXT NOT NULL, -- RealPay tokenized payment method
    payment_method_type VARCHAR(50) NOT NULL,
    last_four_digits TEXT,
    expiry_month INTEGER,
    expiry_year INTEGER,
    card_brand VARCHAR(50),
    is_default BOOLEAN DEFAULT false,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- RealPay refunds table
CREATE TABLE IF NOT EXISTS public.realpay_refunds (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    refund_id TEXT NOT NULL UNIQUE, -- RealPay refund ID
    transaction_id UUID NOT NULL REFERENCES realpay_transactions(id),
    amount DECIMAL(15,2) NOT NULL,
    reason TEXT,
    status VARCHAR(50) NOT NULL CHECK (status IN (
        'pending', 'processing', 'completed', 'failed'
    )),
    realpay_response JSONB,
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_user_id ON public.realpay_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_status ON public.realpay_transactions(status);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_created_at ON public.realpay_transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_realpay_webhook_events_transaction_id ON public.realpay_webhook_events(transaction_id);
CREATE INDEX IF NOT EXISTS idx_realpay_webhook_events_processed ON public.realpay_webhook_events(processed);
CREATE INDEX IF NOT EXISTS idx_realpay_payment_methods_user_id ON public.realpay_payment_methods(user_id);
CREATE INDEX IF NOT EXISTS idx_realpay_refunds_transaction_id ON public.realpay_refunds(transaction_id);

-- Functions for RealPay integration
CREATE OR REPLACE FUNCTION public.create_realpay_transaction(
    p_user_id UUID,
    p_amount DECIMAL(15,2),
    p_currency VARCHAR(3),
    p_payment_method VARCHAR(50),
    p_merchant_reference TEXT
)
RETURNS UUID AS $$
DECLARE
    transaction_uuid UUID;
    realpay_transaction_id TEXT;
BEGIN
    -- Generate RealPay transaction ID
    realpay_transaction_id := 'TXN_' || extract(epoch from now())::text || '_' || substr(gen_random_uuid()::text, 1, 8);
    
    -- Insert transaction
    INSERT INTO public.realpay_transactions (
        transaction_id,
        merchant_reference,
        user_id,
        amount,
        currency,
        payment_method,
        status
    ) VALUES (
        realpay_transaction_id,
        p_merchant_reference,
        p_user_id,
        p_amount,
        p_currency,
        p_payment_method,
        'pending'
    ) RETURNING id INTO transaction_uuid;
    
    RETURN transaction_uuid;
END;
$$ LANGUAGE plpgsql;

-- Function to update transaction status
CREATE OR REPLACE FUNCTION public.update_realpay_transaction_status(
    p_transaction_id TEXT,
    p_status VARCHAR(50),
    p_realpay_response JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.realpay_transactions 
    SET 
        status = p_status,
        realpay_response = p_realpay_response,
        processed_at = CASE WHEN p_status IN ('completed', 'failed', 'cancelled') THEN now() ELSE processed_at END,
        updated_at = now()
    WHERE transaction_id = p_transaction_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to process webhook events
CREATE OR REPLACE FUNCTION public.process_realpay_webhook(
    p_event_data JSONB,
    p_signature TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    event_id TEXT;
    transaction_id TEXT;
    event_type TEXT;
BEGIN
    -- Extract event details
    event_id := p_event_data->>'event_id';
    transaction_id := p_event_data->>'transaction_id';
    event_type := p_event_data->>'event_type';
    
    -- Insert webhook event
    INSERT INTO public.realpay_webhook_events (
        event_id,
        event_type,
        transaction_id,
        merchant_reference,
        event_data,
        signature
    ) VALUES (
        event_id,
        event_type,
        transaction_id,
        p_event_data->>'merchant_reference',
        p_event_data,
        p_signature
    );
    
    -- Update transaction status based on event type
    IF event_type = 'payment.completed' THEN
        PERFORM public.update_realpay_transaction_status(transaction_id, 'completed', p_event_data);
    ELSIF event_type = 'payment.failed' THEN
        PERFORM public.update_realpay_transaction_status(transaction_id, 'failed', p_event_data);
    ELSIF event_type = 'payment.cancelled' THEN
        PERFORM public.update_realpay_transaction_status(transaction_id, 'cancelled', p_event_data);
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to create refund
CREATE OR REPLACE FUNCTION public.create_realpay_refund(
    p_transaction_id UUID,
    p_amount DECIMAL(15,2),
    p_reason TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    refund_uuid UUID;
    realpay_refund_id TEXT;
BEGIN
    -- Generate RealPay refund ID
    realpay_refund_id := 'REF_' || extract(epoch from now())::text || '_' || substr(gen_random_uuid()::text, 1, 8);
    
    -- Insert refund
    INSERT INTO public.realpay_refunds (
        refund_id,
        transaction_id,
        amount,
        reason,
        status
    ) VALUES (
        realpay_refund_id,
        p_transaction_id,
        p_amount,
        p_reason,
        'pending'
    ) RETURNING id INTO refund_uuid;
    
    RETURN refund_uuid;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at
CREATE OR REPLACE FUNCTION public.update_realpay_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_realpay_config_updated_at
    BEFORE UPDATE ON public.realpay_config
    FOR EACH ROW EXECUTE FUNCTION public.update_realpay_updated_at();

CREATE TRIGGER trigger_realpay_transactions_updated_at
    BEFORE UPDATE ON public.realpay_transactions
    FOR EACH ROW EXECUTE FUNCTION public.update_realpay_updated_at();

CREATE TRIGGER trigger_realpay_payment_methods_updated_at
    BEFORE UPDATE ON public.realpay_payment_methods
    FOR EACH ROW EXECUTE FUNCTION public.update_realpay_updated_at();

CREATE TRIGGER trigger_realpay_refunds_updated_at
    BEFORE UPDATE ON public.realpay_refunds
    FOR EACH ROW EXECUTE FUNCTION public.update_realpay_updated_at();

-- RLS Policies
ALTER TABLE public.realpay_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.realpay_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.realpay_webhook_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.realpay_payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.realpay_refunds ENABLE ROW LEVEL SECURITY;

-- RealPay config policies (admin only)
CREATE POLICY "Only admins can view realpay config" ON public.realpay_config
    FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

CREATE POLICY "Only admins can modify realpay config" ON public.realpay_config
    FOR ALL USING (auth.jwt() ->> 'role' = 'admin');

-- RealPay transactions policies
CREATE POLICY "Users can view their own transactions" ON public.realpay_transactions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own transactions" ON public.realpay_transactions
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- RealPay payment methods policies
CREATE POLICY "Users can view their own payment methods" ON public.realpay_payment_methods
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage their own payment methods" ON public.realpay_payment_methods
    FOR ALL USING (auth.uid() = user_id);

-- RealPay refunds policies
CREATE POLICY "Users can view refunds for their transactions" ON public.realpay_refunds
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.realpay_transactions 
            WHERE id = realpay_refunds.transaction_id 
            AND user_id = auth.uid()
        )
    );

-- Webhook events policies (admin only)
CREATE POLICY "Only admins can view webhook events" ON public.realpay_webhook_events
    FOR SELECT USING (auth.jwt() ->> 'role' = 'admin');

CREATE POLICY "Only admins can modify webhook events" ON public.realpay_webhook_events
    FOR ALL USING (auth.jwt() ->> 'role' = 'admin');

-- Comments
COMMENT ON TABLE public.realpay_config IS 'RealPay payment gateway configuration and settings';
COMMENT ON TABLE public.realpay_transactions IS 'RealPay payment transactions and status tracking';
COMMENT ON TABLE public.realpay_webhook_events IS 'RealPay webhook events for payment status updates';
COMMENT ON TABLE public.realpay_payment_methods IS 'User payment methods stored with RealPay';
COMMENT ON TABLE public.realpay_refunds IS 'RealPay refund transactions and processing';
\n-- End of buffrsign-starter/sql/20-realpay_integration.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- =====================================================
-- BuffrSign Audit Logging System
-- =====================================================
-- Description: Comprehensive audit trail for all database operations
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- AUDIT LOGGING TABLES
-- =====================================================

-- Audit log table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(255) NOT NULL,
    record_id TEXT NOT NULL,
    operation VARCHAR(20) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT')),
    old_values JSONB,
    new_values JSONB,
    changed_fields TEXT[],
    user_id TEXT,
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    document_id UUID REFERENCES public.documents(id),
    signature_id UUID REFERENCES public.signatures(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Audit configuration table
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name VARCHAR(255) NOT NULL UNIQUE,
    is_enabled BOOLEAN NOT NULL DEFAULT TRUE,
    audit_insert BOOLEAN NOT NULL DEFAULT TRUE,
    audit_update BOOLEAN NOT NULL DEFAULT TRUE,
    audit_delete BOOLEAN NOT NULL DEFAULT TRUE,
    audit_select BOOLEAN NOT NULL DEFAULT FALSE,
    sensitive_fields TEXT[],
    excluded_fields TEXT[],
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- System activity logs table
CREATE TABLE IF NOT EXISTS public.system_activity_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_type VARCHAR(50) NOT NULL CHECK (activity_type IN ('user_action', 'system_event', 'security_event', 'api_call', 'email_sent', 'document_processed', 'signature_completed')),
    activity_description TEXT NOT NULL,
    user_id TEXT,
    ip_address INET,
    user_agent TEXT,
    session_id TEXT,
    metadata JSONB DEFAULT '{}',
    severity VARCHAR(20) DEFAULT 'info' CHECK (severity IN ('debug', 'info', 'warning', 'error', 'critical')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- AUDIT LOGGING FUNCTIONS
-- =====================================================

-- Function to create audit trigger
CREATE OR REPLACE FUNCTION public.create_audit_trigger(table_name TEXT)
RETURNS VOID AS $$
DECLARE
    trigger_sql TEXT;
BEGIN
    -- Create trigger function for the table
    trigger_sql := '
    CREATE OR REPLACE FUNCTION audit_trigger_' || table_name || '()
    RETURNS TRIGGER AS $audit$
    BEGIN
        IF TG_OP = ''DELETE'' THEN
            INSERT INTO public.audit_logs (table_name, record_id, operation, old_values, user_id, ip_address, document_id, signature_id)
            VALUES (''' || table_name || ''', OLD.id::TEXT, ''DELETE'', to_jsonb(OLD), 
                   current_setting(''app.current_user_id'', true),
                   inet_client_addr(),
                   COALESCE(OLD.document_id, NULL),
                   COALESCE(OLD.signature_id, NULL));
            RETURN OLD;
        ELSIF TG_OP = ''UPDATE'' THEN
            INSERT INTO public.audit_logs (table_name, record_id, operation, old_values, new_values, changed_fields, user_id, ip_address, document_id, signature_id)
            VALUES (''' || table_name || ''', NEW.id::TEXT, ''UPDATE'', to_jsonb(OLD), to_jsonb(NEW),
                   (SELECT array_agg(key) FROM jsonb_each(to_jsonb(NEW)) WHERE to_jsonb(NEW)->>key != to_jsonb(OLD)->>key),
                   current_setting(''app.current_user_id'', true),
                   inet_client_addr(),
                   COALESCE(NEW.document_id, NULL),
                   COALESCE(NEW.signature_id, NULL));
            RETURN NEW;
        ELSIF TG_OP = ''INSERT'' THEN
            INSERT INTO public.audit_logs (table_name, record_id, operation, new_values, user_id, ip_address, document_id, signature_id)
            VALUES (''' || table_name || ''', NEW.id::TEXT, ''INSERT'', to_jsonb(NEW),
                   current_setting(''app.current_user_id'', true),
                   inet_client_addr(),
                   COALESCE(NEW.document_id, NULL),
                   COALESCE(NEW.signature_id, NULL));
            RETURN NEW;
        END IF;
        RETURN NULL;
    END;
    $audit$ LANGUAGE plpgsql;';
    
    EXECUTE trigger_sql;
    
    -- Create the trigger
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_' || table_name || ' ON ' || table_name || ';';
    EXECUTE 'CREATE TRIGGER audit_trigger_' || table_name || '
        AFTER INSERT OR UPDATE OR DELETE ON ' || table_name || '
        FOR EACH ROW EXECUTE FUNCTION audit_trigger_' || table_name || '();';
END;
$$ LANGUAGE plpgsql;

-- Function to enable audit for a table
CREATE OR REPLACE FUNCTION public.enable_audit_for_table(
    p_table_name TEXT,
    p_audit_insert BOOLEAN DEFAULT TRUE,
    p_audit_update BOOLEAN DEFAULT TRUE,
    p_audit_delete BOOLEAN DEFAULT TRUE,
    p_audit_select BOOLEAN DEFAULT FALSE,
    p_sensitive_fields TEXT[] DEFAULT NULL,
    p_excluded_fields TEXT[] DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    -- Insert audit configuration
    INSERT INTO public.audit_config (table_name, is_enabled, audit_insert, audit_update, audit_delete, audit_select, sensitive_fields, excluded_fields)
    VALUES (p_table_name, TRUE, p_audit_insert, p_audit_update, p_audit_delete, p_audit_select, p_sensitive_fields, p_excluded_fields)
    ON CONFLICT (table_name) DO UPDATE SET
        is_enabled = TRUE,
        audit_insert = p_audit_insert,
        audit_update = p_audit_update,
        audit_delete = p_audit_delete,
        audit_select = p_audit_select,
        sensitive_fields = p_sensitive_fields,
        excluded_fields = p_excluded_fields;
    
    -- Create audit trigger
    PERFORM public.create_audit_trigger(p_table_name);
END;
$$ LANGUAGE plpgsql;

-- Function to disable audit for a table
CREATE OR REPLACE FUNCTION public.disable_audit_for_table(p_table_name TEXT)
RETURNS VOID AS $$
BEGIN
    -- Update audit configuration
    UPDATE public.audit_config SET is_enabled = FALSE WHERE table_name = p_table_name;
    
    -- Drop audit trigger
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_' || p_table_name || ' ON ' || p_table_name || ';';
    EXECUTE 'DROP FUNCTION IF EXISTS audit_trigger_' || p_table_name || '();';
END;
$$ LANGUAGE plpgsql;

-- Function to log system activity
CREATE OR REPLACE FUNCTION public.log_system_activity(
    p_activity_type VARCHAR(50),
    p_description TEXT,
    p_user_id TEXT DEFAULT NULL,
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL,
    p_session_id TEXT DEFAULT NULL,
    p_metadata JSONB DEFAULT '{}',
    p_severity VARCHAR(20) DEFAULT 'info'
)
RETURNS UUID AS $$
DECLARE
    log_id UUID;
BEGIN
    INSERT INTO public.system_activity_logs (
        activity_type, activity_description, user_id, ip_address, 
        user_agent, session_id, metadata, severity
    ) VALUES (
        p_activity_type, p_description, p_user_id, p_ip_address,
        p_user_agent, p_session_id, p_metadata, p_severity
    ) RETURNING id INTO log_id;
    
    RETURN log_id;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up old audit logs
CREATE OR REPLACE FUNCTION public.cleanup_audit_logs(retention_days INTEGER DEFAULT 90)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.audit_logs 
    WHERE created_at < NOW() - INTERVAL '1 day' * retention_days;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up old system activity logs
CREATE OR REPLACE FUNCTION public.cleanup_system_activity_logs(retention_days INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.system_activity_logs 
    WHERE created_at < NOW() - INTERVAL '1 day' * retention_days;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get audit trail for a record
CREATE OR REPLACE FUNCTION public.get_audit_trail(
    p_table_name TEXT,
    p_record_id TEXT,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    id UUID,
    operation VARCHAR(20),
    old_values JSONB,
    new_values JSONB,
    changed_fields TEXT[],
    user_id TEXT,
    ip_address INET,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.id,
        al.operation,
        al.old_values,
        al.new_values,
        al.changed_fields,
        al.user_id,
        al.ip_address,
        al.created_at
    FROM public.audit_logs al
    WHERE al.table_name = p_table_name 
      AND al.record_id = p_record_id
    ORDER BY al.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to get audit trail for a user
CREATE OR REPLACE FUNCTION public.get_user_audit_trail(
    p_user_id TEXT,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    id UUID,
    table_name VARCHAR(255),
    record_id TEXT,
    operation VARCHAR(20),
    old_values JSONB,
    new_values JSONB,
    changed_fields TEXT[],
    ip_address INET,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.id,
        al.table_name,
        al.record_id,
        al.operation,
        al.old_values,
        al.new_values,
        al.changed_fields,
        al.ip_address,
        al.created_at
    FROM public.audit_logs al
    WHERE al.user_id = p_user_id
    ORDER BY al.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to get system activity logs
CREATE OR REPLACE FUNCTION public.get_system_activity_logs(
    p_activity_type VARCHAR(50) DEFAULT NULL,
    p_user_id TEXT DEFAULT NULL,
    p_severity VARCHAR(20) DEFAULT NULL,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    id UUID,
    activity_type VARCHAR(50),
    activity_description TEXT,
    user_id TEXT,
    ip_address INET,
    metadata JSONB,
    severity VARCHAR(20),
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sal.id,
        sal.activity_type,
        sal.activity_description,
        sal.user_id,
        sal.ip_address,
        sal.metadata,
        sal.severity,
        sal.created_at
    FROM public.system_activity_logs sal
    WHERE (p_activity_type IS NULL OR sal.activity_type = p_activity_type)
      AND (p_user_id IS NULL OR sal.user_id = p_user_id)
      AND (p_severity IS NULL OR sal.severity = p_severity)
    ORDER BY sal.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- DEFAULT AUDIT CONFIGURATION
-- =====================================================

-- Enable audit for critical tables
SELECT public.enable_audit_for_table('profiles', TRUE, TRUE, TRUE, FALSE, ARRAY['password', 'phone'], NULL);
SELECT public.enable_audit_for_table('documents', TRUE, TRUE, TRUE, FALSE, ARRAY['file_path', 'file_hash'], NULL);
SELECT public.enable_audit_for_table('signatures', TRUE, TRUE, TRUE, FALSE, ARRAY['signature_data'], NULL);
SELECT public.enable_audit_for_table('email_queue', TRUE, TRUE, TRUE, FALSE, ARRAY['content'], NULL);
SELECT public.enable_audit_for_table('ai_analysis', TRUE, TRUE, TRUE, FALSE, NULL, NULL);
SELECT public.enable_audit_for_table('kyc_verifications', TRUE, TRUE, TRUE, FALSE, ARRAY['document_path'], NULL);
SELECT public.enable_audit_for_table('rate_limiting_violations', TRUE, TRUE, TRUE, FALSE, NULL, NULL);
SELECT public.enable_audit_for_table('validation_results', TRUE, TRUE, TRUE, FALSE, NULL, NULL);

-- =====================================================
-- RLS POLICIES FOR AUDIT TABLES
-- =====================================================

-- Enable RLS on audit tables
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_activity_logs ENABLE ROW LEVEL SECURITY;

-- Audit logs policies
CREATE POLICY "Users can view own audit logs" ON public.audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all audit logs" ON public.audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert audit logs" ON public.audit_logs
    FOR INSERT WITH CHECK (true);

-- Audit config policies
CREATE POLICY "Admin users can view audit config" ON public.audit_config
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "Admin users can modify audit config" ON public.audit_config
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- System activity logs policies
CREATE POLICY "Users can view own system activity logs" ON public.system_activity_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all system activity logs" ON public.system_activity_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert system activity logs" ON public.system_activity_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- INDEXES FOR AUDIT TABLES
-- =====================================================

-- Audit logs indexes
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_record ON public.audit_logs(table_name, record_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user ON public.audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_operation ON public.audit_logs(operation);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_document ON public.audit_logs(document_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_signature ON public.audit_logs(signature_id);

-- System activity logs indexes
CREATE INDEX IF NOT EXISTS idx_system_activity_logs_activity_type ON public.system_activity_logs(activity_type);
CREATE INDEX IF NOT EXISTS idx_system_activity_logs_user ON public.system_activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_system_activity_logs_severity ON public.system_activity_logs(severity);
CREATE INDEX IF NOT EXISTS idx_system_activity_logs_created_at ON public.system_activity_logs(created_at);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.audit_logs IS 'Comprehensive audit trail for all database operations';
COMMENT ON TABLE public.audit_config IS 'Configuration for audit logging on specific tables';
COMMENT ON TABLE public.system_activity_logs IS 'System activity and event logging';
COMMENT ON FUNCTION public.create_audit_trigger(TEXT) IS 'Creates audit trigger for a specific table';
COMMENT ON FUNCTION public.enable_audit_for_table(TEXT, BOOLEAN, BOOLEAN, BOOLEAN, BOOLEAN, TEXT[], TEXT[]) IS 'Enables audit logging for a table with configuration';
COMMENT ON FUNCTION public.disable_audit_for_table(TEXT) IS 'Disables audit logging for a table';
COMMENT ON FUNCTION public.log_system_activity(VARCHAR, TEXT, TEXT, INET, TEXT, TEXT, JSONB, VARCHAR) IS 'Logs system activity and events';
COMMENT ON FUNCTION public.cleanup_audit_logs(INTEGER) IS 'Cleans up old audit logs based on retention period';
COMMENT ON FUNCTION public.cleanup_system_activity_logs(INTEGER) IS 'Cleans up old system activity logs based on retention period';
COMMENT ON FUNCTION public.get_audit_trail(TEXT, TEXT, INTEGER) IS 'Gets audit trail for a specific record';
COMMENT ON FUNCTION public.get_user_audit_trail(TEXT, INTEGER) IS 'Gets audit trail for a specific user';
COMMENT ON FUNCTION public.get_system_activity_logs(VARCHAR, TEXT, VARCHAR, INTEGER) IS 'Gets system activity logs with filtering';
\n-- End of buffrsign-starter/sql/12-audit_logging.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- ============================================================================
-- User Profiles and Authentication Requests
-- ============================================================================
-- This file contains user profile management and authentication-related functions
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- USER PROFILE FUNCTIONS
-- ============================================================================

-- Function to handle new user creation
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (
        id,
        first_name,
        last_name,
        email,
        role,
        company_name,
        phone,
        account_type,
        is_verified,
        is_active,
        email_notifications,
        sms_notifications,
        two_factor_enabled,
        language,
        timezone,
        theme,
        can_view_dashboard,
        can_manage_users,
        can_manage_documents,
        can_manage_compliance,
        can_view_analytics,
        can_manage_settings,
        can_access_admin_panel,
        can_manage_super_admins,
        can_manage_kyc,
        can_manage_templates
    ) VALUES (
        NEW.id,
        COALESCE(NULLIF(NEW.raw_user_meta_data->>'first_name', ''), 'User'),
        COALESCE(NULLIF(NEW.raw_user_meta_data->>'last_name', ''), 'User'),
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'role', 'user')::user_role,
        COALESCE(NEW.raw_user_meta_data->>'company_name', ''),
        COALESCE(NEW.raw_user_meta_data->>'phone', ''),
        COALESCE(NEW.raw_user_meta_data->>'account_type', 'individual'),
        COALESCE((NEW.raw_user_meta_data->>'is_verified')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'is_active')::boolean, true),
        COALESCE((NEW.raw_user_meta_data->>'email_notifications')::boolean, true),
        COALESCE((NEW.raw_user_meta_data->>'sms_notifications')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'two_factor_enabled')::boolean, false),
        COALESCE(NEW.raw_user_meta_data->>'language', 'en'),
        COALESCE(NEW.raw_user_meta_data->>'timezone', 'UTC'),
        COALESCE(NEW.raw_user_meta_data->>'theme', 'system'),
        COALESCE((NEW.raw_user_meta_data->>'can_view_dashboard')::boolean, true),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_users')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_documents')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_compliance')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_view_analytics')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_settings')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_access_admin_panel')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_super_admins')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_kyc')::boolean, false),
        COALESCE((NEW.raw_user_meta_data->>'can_manage_templates')::boolean, false)
    );
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error but don't fail the user creation
        RAISE WARNING 'Failed to create profile for user %: %', NEW.id, SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to set user permissions based on role
CREATE OR REPLACE FUNCTION set_user_permissions()
RETURNS TRIGGER AS $$
BEGIN
    -- Set permissions based on role
    CASE NEW.role
        WHEN 'user' THEN
            NEW.can_view_dashboard = TRUE;
            NEW.can_manage_users = FALSE;
            NEW.can_manage_documents = FALSE;
            NEW.can_manage_compliance = FALSE;
            NEW.can_view_analytics = FALSE;
            NEW.can_manage_settings = FALSE;
            NEW.can_access_admin_panel = FALSE;
            NEW.can_manage_super_admins = FALSE;
            NEW.can_manage_kyc = FALSE;
            NEW.can_manage_templates = FALSE;
        WHEN 'admin' THEN
            NEW.can_view_dashboard = TRUE;
            NEW.can_manage_users = TRUE;
            NEW.can_manage_documents = TRUE;
            NEW.can_manage_compliance = TRUE;
            NEW.can_view_analytics = TRUE;
            NEW.can_manage_settings = TRUE;
            NEW.can_access_admin_panel = TRUE;
            NEW.can_manage_super_admins = FALSE;
            NEW.can_manage_kyc = TRUE;
            NEW.can_manage_templates = TRUE;
        WHEN 'super_admin' THEN
            NEW.can_view_dashboard = TRUE;
            NEW.can_manage_users = TRUE;
            NEW.can_manage_documents = TRUE;
            NEW.can_manage_compliance = TRUE;
            NEW.can_view_analytics = TRUE;
            NEW.can_manage_settings = TRUE;
            NEW.can_access_admin_panel = TRUE;
            NEW.can_manage_super_admins = TRUE;
            NEW.can_manage_kyc = TRUE;
            NEW.can_manage_templates = TRUE;
    END CASE;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to update last login timestamp
CREATE OR REPLACE FUNCTION update_last_login()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.profiles 
    SET last_login_at = NOW() 
    WHERE id = NEW.id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to create default email preferences
CREATE OR REPLACE FUNCTION create_default_email_preferences()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert email preferences for the new user
    INSERT INTO user_email_preferences (
        user_id,
        receive_invitations,
        receive_reminders,
        receive_status_updates,
        receive_marketing,
        reminder_frequency,
        preferred_language,
        timezone,
        email_format
    ) VALUES (
        NEW.id,
        true,
        true,
        true,
        false,
        2,
        'en-NA',
        'Africa/Windhoek',
        'html'
    ) ON CONFLICT (user_id) DO NOTHING;
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error but don't fail the user creation
        RAISE WARNING 'Failed to create email preferences for user %: %', NEW.id, SQLERRM;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- USER ANALYTICS FUNCTIONS
-- ============================================================================

-- Function to get user activity analytics
CREATE OR REPLACE FUNCTION get_user_activity_analytics(
    p_user_id UUID,
    p_days_back INTEGER DEFAULT 30
)
RETURNS TABLE(
    total_activities BIGINT,
    unique_activity_types INTEGER,
    most_active_day DATE,
    most_common_activity VARCHAR,
    last_activity TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_activities,
        COUNT(DISTINCT ua.activity_type) as unique_activity_types,
        DATE(ua.created_at) as most_active_day,
        (SELECT activity_type FROM user_activities 
         WHERE user_id = p_user_id 
         AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_back
         GROUP BY activity_type 
         ORDER BY COUNT(*) DESC 
         LIMIT 1) as most_common_activity,
        MAX(ua.created_at) as last_activity
    FROM user_activities ua
    WHERE ua.user_id = p_user_id
    AND ua.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_back;
END;
$$ LANGUAGE plpgsql;

-- Function to get user activity summary
CREATE OR REPLACE FUNCTION get_user_activity_summary(
    user_uuid UUID,
    days_back INTEGER DEFAULT 30
)
RETURNS TABLE(
    activity_type VARCHAR,
    count BIGINT,
    last_activity TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ua.activity_type,
        COUNT(*) as count,
        MAX(ua.created_at) as last_activity
    FROM user_activities ua
    WHERE ua.user_id = user_uuid
    AND ua.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * days_back
    GROUP BY ua.activity_type
    ORDER BY count DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get user document statistics
CREATE OR REPLACE FUNCTION get_user_document_stats(user_uuid UUID)
RETURNS TABLE(
    total_documents BIGINT,
    pending_documents BIGINT,
    completed_documents BIGINT,
    draft_documents BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_documents,
        COUNT(*) FILTER (WHERE status = 'pending') as pending_documents,
        COUNT(*) FILTER (WHERE status = 'completed') as completed_documents,
        COUNT(*) FILTER (WHERE status = 'draft') as draft_documents
    FROM documents 
    WHERE created_by = user_uuid;
END;
$$ LANGUAGE plpgsql;

-- Function to log user activity
CREATE OR REPLACE FUNCTION log_user_activity(
    p_user_id UUID,
    p_activity_type VARCHAR,
    p_activity_data JSONB DEFAULT NULL,
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL,
    p_session_id VARCHAR DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    activity_id UUID;
BEGIN
    INSERT INTO user_activities (
        user_id,
        activity_type,
        activity_data,
        ip_address,
        user_agent,
        session_id
    ) VALUES (
        p_user_id,
        p_activity_type,
        p_activity_data,
        p_ip_address,
        p_user_agent,
        p_session_id
    ) RETURNING id INTO activity_id;
    
    RETURN activity_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Trigger for new user creation
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION handle_new_user();

-- Trigger for user permission updates
DROP TRIGGER IF EXISTS on_profile_role_change ON profiles;
CREATE TRIGGER on_profile_role_change
    BEFORE INSERT OR UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION set_user_permissions();

-- Trigger for last login updates
DROP TRIGGER IF EXISTS on_auth_user_login ON auth.users;
CREATE TRIGGER on_auth_user_login
    AFTER UPDATE OF last_sign_in_at ON auth.users
    FOR EACH ROW
    EXECUTE FUNCTION update_last_login();

-- Trigger for email preferences creation
DROP TRIGGER IF EXISTS on_profile_created ON profiles;
CREATE TRIGGER on_profile_created
    AFTER INSERT ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION create_default_email_preferences();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION handle_new_user() IS 'Creates user profile when new user signs up';
COMMENT ON FUNCTION set_user_permissions() IS 'Sets user permissions based on role';
COMMENT ON FUNCTION update_last_login() IS 'Updates last login timestamp';
COMMENT ON FUNCTION create_default_email_preferences() IS 'Creates default email preferences for new users';
COMMENT ON FUNCTION get_user_activity_analytics(UUID, INTEGER) IS 'Returns comprehensive user activity analytics';
COMMENT ON FUNCTION get_user_activity_summary(UUID, INTEGER) IS 'Returns user activity summary by type';
COMMENT ON FUNCTION get_user_document_stats(UUID) IS 'Returns user document statistics';
COMMENT ON FUNCTION log_user_activity(UUID, VARCHAR, JSONB, INET, TEXT, VARCHAR) IS 'Logs user activity for analytics';
\n-- End of buffrsign-starter/sql/1-user_profiles_requests.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- =====================================================
-- BuffrSign Notification System
-- =====================================================
-- Description: Comprehensive notification system for email, SMS, and push notifications
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- NOTIFICATION TABLES
-- =====================================================

-- Notification templates table
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) NOT NULL UNIQUE,
    template_type VARCHAR(50) NOT NULL CHECK (template_type IN ('email', 'sms', 'push', 'in_app')),
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification queue table
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('email', 'sms', 'push', 'in_app')),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE CASCADE,
    recipient VARCHAR(255) NOT NULL,
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),
    scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'sent', 'delivered', 'failed', 'cancelled')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    error_message TEXT,
    sent_at TIMESTAMP WITH TIME ZONE,
    delivered_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification preferences table
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL UNIQUE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT TRUE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    email_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (email_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    sms_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (sms_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    push_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (push_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    in_app_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (in_app_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    timezone VARCHAR(50) DEFAULT 'Africa/Windhoek',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification delivery logs table
CREATE TABLE IF NOT EXISTS public.notification_delivery_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    notification_id UUID NOT NULL REFERENCES public.notification_queue(id) ON DELETE CASCADE,
    delivery_status VARCHAR(20) NOT NULL CHECK (delivery_status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'failed')),
    delivery_provider VARCHAR(100),
    provider_message_id VARCHAR(255),
    delivery_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    error_code VARCHAR(50),
    error_message TEXT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification campaigns table
CREATE TABLE IF NOT EXISTS public.notification_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_name VARCHAR(255) NOT NULL,
    campaign_type VARCHAR(50) NOT NULL CHECK (campaign_type IN ('marketing', 'transactional', 'promotional', 'system')),
    template_id UUID NOT NULL REFERENCES public.notification_templates(id) ON DELETE CASCADE,
    target_audience JSONB,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'running', 'completed', 'cancelled')),
    total_recipients INTEGER DEFAULT 0,
    sent_count INTEGER DEFAULT 0,
    delivered_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- In-app notifications table
CREATE TABLE IF NOT EXISTS public.in_app_notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('info', 'success', 'warning', 'error', 'system')),
    action_url TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- NOTIFICATION FUNCTIONS
-- =====================================================

-- Function to send notification
CREATE OR REPLACE FUNCTION public.send_notification(
    p_user_id TEXT,
    p_notification_type VARCHAR(50),
    p_template_name VARCHAR(255),
    p_recipient VARCHAR(255),
    p_variables JSONB DEFAULT '{}',
    p_priority INTEGER DEFAULT 5,
    p_scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
)
RETURNS UUID AS $$
DECLARE
    template_record RECORD;
    notification_id UUID;
    processed_content TEXT;
    processed_subject TEXT;
BEGIN
    -- Get template
    SELECT * INTO template_record 
    FROM public.notification_templates 
    WHERE template_name = p_template_name 
    AND template_type = p_notification_type 
    AND is_active = TRUE;
    
    IF template_record IS NULL THEN
        RAISE EXCEPTION 'Template not found: %', p_template_name;
    END IF;
    
    -- Process content with variables
    processed_content := template_record.content;
    processed_subject := COALESCE(template_record.subject, '');
    
    -- Replace variables in content
    IF p_variables IS NOT NULL THEN
        FOR key, value IN SELECT * FROM jsonb_each_text(p_variables) LOOP
            processed_content := replace(processed_content, '{{' || key || '}}', value);
            processed_subject := replace(processed_subject, '{{' || key || '}}', value);
        END LOOP;
    END IF;
    
    -- Insert notification into queue
    INSERT INTO public.notification_queue (
        user_id, notification_type, template_id, recipient, 
        subject, content, variables, priority, scheduled_at
    ) VALUES (
        p_user_id, p_notification_type, template_record.id, p_recipient,
        processed_subject, processed_content, p_variables, p_priority, p_scheduled_at
    ) RETURNING id INTO notification_id;
    
    RETURN notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to send in-app notification
CREATE OR REPLACE FUNCTION public.send_in_app_notification(
    p_user_id TEXT,
    p_title VARCHAR(255),
    p_message TEXT,
    p_notification_type VARCHAR(50) DEFAULT 'info',
    p_action_url TEXT DEFAULT NULL,
    p_expires_at TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_metadata JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    notification_id UUID;
BEGIN
    INSERT INTO public.in_app_notifications (
        user_id, title, message, notification_type, action_url, expires_at, metadata
    ) VALUES (
        p_user_id, p_title, p_message, p_notification_type, p_action_url, p_expires_at, p_metadata
    ) RETURNING id INTO notification_id;
    
    RETURN notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to process notification queue
CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS VOID AS $$
DECLARE
    notification_record RECORD;
    delivery_status VARCHAR(20);
    error_message TEXT;
BEGIN
    -- Get pending notifications
    FOR notification_record IN 
        SELECT * FROM public.notification_queue 
        WHERE status = 'pending' 
        AND scheduled_at <= CURRENT_TIMESTAMP
        AND attempts < max_attempts
        ORDER BY priority DESC, created_at ASC
        LIMIT 100
    LOOP
        -- Update status to processing
        UPDATE public.notification_queue 
        SET status = 'processing', attempts = attempts + 1
        WHERE id = notification_record.id;
        
        -- Process based on notification type
        CASE notification_record.notification_type
            WHEN 'email' THEN
                -- Email processing logic would go here
                delivery_status := 'sent';
            WHEN 'sms' THEN
                -- SMS processing logic would go here
                delivery_status := 'sent';
            WHEN 'push' THEN
                -- Push notification processing logic would go here
                delivery_status := 'sent';
            WHEN 'in_app' THEN
                -- In-app notification processing logic would go here
                delivery_status := 'sent';
            ELSE
                delivery_status := 'failed';
                error_message := 'Unknown notification type';
        END CASE;
        
        -- Update notification status
        IF delivery_status = 'sent' THEN
            UPDATE public.notification_queue 
            SET status = 'sent', sent_at = CURRENT_TIMESTAMP
            WHERE id = notification_record.id;
            
            -- Log delivery
            INSERT INTO public.notification_delivery_logs (
                notification_id, delivery_status, delivery_timestamp
            ) VALUES (
                notification_record.id, delivery_status, CURRENT_TIMESTAMP
            );
        ELSE
            UPDATE public.notification_queue 
            SET status = 'failed', error_message = error_message
            WHERE id = notification_record.id;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to get user notification preferences
CREATE OR REPLACE FUNCTION public.get_user_notification_preferences(p_user_id TEXT)
RETURNS JSONB AS $$
DECLARE
    preferences_record RECORD;
    result JSONB;
BEGIN
    SELECT * INTO preferences_record 
    FROM public.notification_preferences 
    WHERE user_id = p_user_id;
    
    IF preferences_record IS NULL THEN
        -- Create default preferences
        INSERT INTO public.notification_preferences (user_id) 
        VALUES (p_user_id) 
        RETURNING * INTO preferences_record;
    END IF;
    
    result := jsonb_build_object(
        'email_enabled', preferences_record.email_enabled,
        'sms_enabled', preferences_record.sms_enabled,
        'push_enabled', preferences_record.push_enabled,
        'in_app_enabled', preferences_record.in_app_enabled,
        'email_frequency', preferences_record.email_frequency,
        'sms_frequency', preferences_record.sms_frequency,
        'push_frequency', preferences_record.push_frequency,
        'in_app_frequency', preferences_record.in_app_frequency,
        'quiet_hours_start', preferences_record.quiet_hours_start,
        'quiet_hours_end', preferences_record.quiet_hours_end,
        'timezone', preferences_record.timezone
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to update notification preferences
CREATE OR REPLACE FUNCTION public.update_notification_preferences(
    p_user_id TEXT,
    p_preferences JSONB
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO public.notification_preferences (
        user_id, email_enabled, sms_enabled, push_enabled, in_app_enabled,
        email_frequency, sms_frequency, push_frequency, in_app_frequency,
        quiet_hours_start, quiet_hours_end, timezone
    ) VALUES (
        p_user_id,
        COALESCE((p_preferences->>'email_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'sms_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'push_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'in_app_enabled')::BOOLEAN, TRUE),
        COALESCE(p_preferences->>'email_frequency', 'immediate'),
        COALESCE(p_preferences->>'sms_frequency', 'immediate'),
        COALESCE(p_preferences->>'push_frequency', 'immediate'),
        COALESCE(p_preferences->>'in_app_frequency', 'immediate'),
        (p_preferences->>'quiet_hours_start')::TIME,
        (p_preferences->>'quiet_hours_end')::TIME,
        COALESCE(p_preferences->>'timezone', 'Africa/Windhoek')
    ) ON CONFLICT (user_id) DO UPDATE SET
        email_enabled = EXCLUDED.email_enabled,
        sms_enabled = EXCLUDED.sms_enabled,
        push_enabled = EXCLUDED.push_enabled,
        in_app_enabled = EXCLUDED.in_app_enabled,
        email_frequency = EXCLUDED.email_frequency,
        sms_frequency = EXCLUDED.sms_frequency,
        push_frequency = EXCLUDED.push_frequency,
        in_app_frequency = EXCLUDED.in_app_frequency,
        quiet_hours_start = EXCLUDED.quiet_hours_start,
        quiet_hours_end = EXCLUDED.quiet_hours_end,
        timezone = EXCLUDED.timezone,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- Function to get user in-app notifications
CREATE OR REPLACE FUNCTION public.get_user_in_app_notifications(
    p_user_id TEXT,
    p_limit INTEGER DEFAULT 50,
    p_unread_only BOOLEAN DEFAULT FALSE
)
RETURNS TABLE (
    id UUID,
    title VARCHAR(255),
    message TEXT,
    notification_type VARCHAR(50),
    action_url TEXT,
    is_read BOOLEAN,
    read_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ian.id,
        ian.title,
        ian.message,
        ian.notification_type,
        ian.action_url,
        ian.is_read,
        ian.read_at,
        ian.expires_at,
        ian.metadata,
        ian.created_at
    FROM public.in_app_notifications ian
    WHERE ian.user_id = p_user_id
      AND (p_unread_only = FALSE OR ian.is_read = FALSE)
      AND (ian.expires_at IS NULL OR ian.expires_at > CURRENT_TIMESTAMP)
    ORDER BY ian.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION public.mark_notification_read(p_notification_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.in_app_notifications 
    SET is_read = TRUE, read_at = CURRENT_TIMESTAMP
    WHERE id = p_notification_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup old notifications
CREATE OR REPLACE FUNCTION public.cleanup_old_notifications()
RETURNS VOID AS $$
BEGIN
    -- Cleanup old notification queue (keep for 30 days)
    DELETE FROM public.notification_queue 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days'
    AND status IN ('sent', 'delivered', 'failed', 'cancelled');
    
    -- Cleanup old delivery logs (keep for 90 days)
    DELETE FROM public.notification_delivery_logs 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '90 days';
    
    -- Cleanup old campaigns (keep for 1 year)
    DELETE FROM public.notification_campaigns 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 year'
    AND status = 'completed';
    
    -- Cleanup expired in-app notifications
    DELETE FROM public.in_app_notifications 
    WHERE expires_at IS NOT NULL 
    AND expires_at < CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- NOTIFICATION TRIGGERS
-- =====================================================

-- Trigger function for document signature notifications
CREATE OR REPLACE FUNCTION public.notify_document_signature_status()
RETURNS TRIGGER AS $$
DECLARE
    user_profile RECORD;
    notification_variables JSONB;
BEGIN
    -- Get user profile
    SELECT * INTO user_profile FROM public.profiles WHERE id = NEW.user_id;
    
    IF user_profile IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Prepare notification variables
    notification_variables := jsonb_build_object(
        'user_name', user_profile.first_name || ' ' || user_profile.last_name,
        'document_title', NEW.document_title,
        'signature_id', NEW.id,
        'status', NEW.status
    );
    
    -- Send notification based on status
    CASE NEW.status
        WHEN 'signed' THEN
            PERFORM public.send_notification(
                NEW.user_id, 'email', 'document_signed', user_profile.email,
                notification_variables, 8
            );
            PERFORM public.send_in_app_notification(
                NEW.user_id, 'Document Signed', 
                'Your document "{{document_title}}" has been signed successfully.',
                'success', '/signatures/completed', NULL, notification_variables
            );
        WHEN 'pending' THEN
            PERFORM public.send_notification(
                NEW.user_id, 'email', 'signature_request', user_profile.email,
                notification_variables, 7
            );
            PERFORM public.send_in_app_notification(
                NEW.user_id, 'Signature Request', 
                'You have a new document "{{document_title}}" waiting for your signature.',
                'info', '/signatures/pending', NULL, notification_variables
            );
    END CASE;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notify_document_signature_status
    AFTER INSERT OR UPDATE ON public.signatures
    FOR EACH ROW EXECUTE FUNCTION public.notify_document_signature_status();

-- =====================================================
-- DEFAULT NOTIFICATION TEMPLATES
-- =====================================================

-- Insert default notification templates for BuffrSign
INSERT INTO public.notification_templates (template_name, template_type, subject, content, variables) VALUES
('document_signed', 'email', 'Document Signed Successfully - {{user_name}}', 
 'Dear {{user_name}},\n\nYour document "{{document_title}}" has been signed successfully.\n\nDocument Details:\n- Title: {{document_title}}\n- Signature ID: {{signature_id}}\n- Status: {{status}}\n\nYou can view the completed document in your dashboard.\n\nBest regards,\nBuffrSign Team', 
 '{"user_name": "string", "document_title": "string", "signature_id": "string", "status": "string"}'),
('signature_request', 'email', 'Signature Request - {{user_name}}', 
 'Dear {{user_name}},\n\nYou have a new document "{{document_title}}" waiting for your signature.\n\nDocument Details:\n- Title: {{document_title}}\n- Signature ID: {{signature_id}}\n- Status: {{status}}\n\nPlease log in to your account to review and sign the document.\n\nBest regards,\nBuffrSign Team', 
 '{"user_name": "string", "document_title": "string", "signature_id": "string", "status": "string"}'),
('document_uploaded', 'email', 'Document Uploaded - {{user_name}}', 
 'Dear {{user_name}},\n\nYour document "{{document_title}}" has been uploaded successfully.\n\nDocument Details:\n- Title: {{document_title}}\n- Upload Date: {{upload_date}}\n\nYou can now add signers and send for signature.\n\nBest regards,\nBuffrSign Team', 
 '{"user_name": "string", "document_title": "string", "upload_date": "date"}'),
('signature_reminder', 'email', 'Signature Reminder - {{user_name}}', 
 'Dear {{user_name}},\n\nThis is a reminder that you have a document "{{document_title}}" waiting for your signature.\n\nPlease sign the document to complete the process.\n\nBest regards,\nBuffrSign Team', 
 '{"user_name": "string", "document_title": "string"}'),
('document_signed', 'in_app', 'Document Signed Successfully', 
 'Your document "{{document_title}}" has been signed successfully.', 
 '{"document_title": "string"}'),
('signature_request', 'in_app', 'New Signature Request', 
 'You have a new document "{{document_title}}" waiting for your signature.', 
 '{"document_title": "string"}'),
('document_uploaded', 'in_app', 'Document Uploaded', 
 'Your document "{{document_title}}" has been uploaded successfully.', 
 '{"document_title": "string"}'),
('signature_reminder', 'in_app', 'Signature Reminder', 
 'You have a document "{{document_title}}" waiting for your signature.', 
 '{"document_title": "string"}')
ON CONFLICT (template_name) DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR NOTIFICATION TABLES
-- =====================================================

-- Enable RLS on notification tables
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_delivery_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.in_app_notifications ENABLE ROW LEVEL SECURITY;

-- Notification templates policies
CREATE POLICY "Admin users can manage notification templates" ON public.notification_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- Notification queue policies
CREATE POLICY "Users can view own notifications" ON public.notification_queue
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all notifications" ON public.notification_queue
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can manage notification queue" ON public.notification_queue
    FOR ALL USING (true);

-- Notification preferences policies
CREATE POLICY "Users can manage own notification preferences" ON public.notification_preferences
    FOR ALL USING (
        auth.uid()::text = user_id
    );

-- In-app notifications policies
CREATE POLICY "Users can view own in-app notifications" ON public.in_app_notifications
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Users can update own in-app notifications" ON public.in_app_notifications
    FOR UPDATE USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "System can manage in-app notifications" ON public.in_app_notifications
    FOR ALL USING (true);

-- =====================================================
-- INDEXES FOR NOTIFICATION TABLES
-- =====================================================

-- Notification templates indexes
CREATE INDEX IF NOT EXISTS idx_notification_templates_template_name ON public.notification_templates(template_name);
CREATE INDEX IF NOT EXISTS idx_notification_templates_template_type ON public.notification_templates(template_type);
CREATE INDEX IF NOT EXISTS idx_notification_templates_is_active ON public.notification_templates(is_active);

-- Notification queue indexes
CREATE INDEX IF NOT EXISTS idx_notification_queue_user_id ON public.notification_queue(user_id);
CREATE INDEX IF NOT EXISTS idx_notification_queue_notification_type ON public.notification_queue(notification_type);
CREATE INDEX IF NOT EXISTS idx_notification_queue_status ON public.notification_queue(status);
CREATE INDEX IF NOT EXISTS idx_notification_queue_priority ON public.notification_queue(priority);
CREATE INDEX IF NOT EXISTS idx_notification_queue_scheduled_at ON public.notification_queue(scheduled_at);
CREATE INDEX IF NOT EXISTS idx_notification_queue_created_at ON public.notification_queue(created_at);

-- Notification preferences indexes
CREATE INDEX IF NOT EXISTS idx_notification_preferences_user_id ON public.notification_preferences(user_id);

-- In-app notifications indexes
CREATE INDEX IF NOT EXISTS idx_in_app_notifications_user_id ON public.in_app_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_in_app_notifications_is_read ON public.in_app_notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_in_app_notifications_notification_type ON public.in_app_notifications(notification_type);
CREATE INDEX IF NOT EXISTS idx_in_app_notifications_created_at ON public.in_app_notifications(created_at);
CREATE INDEX IF NOT EXISTS idx_in_app_notifications_expires_at ON public.in_app_notifications(expires_at);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.notification_templates IS 'Notification templates for different message types';
COMMENT ON TABLE public.notification_queue IS 'Queue for pending notifications';
COMMENT ON TABLE public.notification_preferences IS 'User notification preferences and settings';
COMMENT ON TABLE public.notification_delivery_logs IS 'Delivery logs for sent notifications';
COMMENT ON TABLE public.notification_campaigns IS 'Notification campaigns for bulk messaging';
COMMENT ON TABLE public.in_app_notifications IS 'In-app notifications for users';
COMMENT ON FUNCTION public.send_notification(TEXT, VARCHAR, VARCHAR, VARCHAR, JSONB, INTEGER, TIMESTAMP WITH TIME ZONE) IS 'Sends a notification to a user';
COMMENT ON FUNCTION public.send_in_app_notification(TEXT, VARCHAR, TEXT, VARCHAR, TEXT, TIMESTAMP WITH TIME ZONE, JSONB) IS 'Sends an in-app notification to a user';
COMMENT ON FUNCTION public.process_notification_queue() IS 'Processes pending notifications in the queue';
COMMENT ON FUNCTION public.get_user_notification_preferences(TEXT) IS 'Gets user notification preferences';
COMMENT ON FUNCTION public.update_notification_preferences(TEXT, JSONB) IS 'Updates user notification preferences';
COMMENT ON FUNCTION public.get_user_in_app_notifications(TEXT, INTEGER, BOOLEAN) IS 'Gets user in-app notifications';
COMMENT ON FUNCTION public.mark_notification_read(UUID) IS 'Marks a notification as read';
COMMENT ON FUNCTION public.cleanup_old_notifications() IS 'Cleans up old notification data';
\n-- End of buffrsign-starter/sql/17-notification_system.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- =====================================================
-- BuffrSign Team Management System
-- =====================================================
-- Description: Team management, collaboration, and user roles
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- TEAM MANAGEMENT TABLES
-- =====================================================

-- Teams table
CREATE TABLE IF NOT EXISTS public.teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    owner_id TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team members table
CREATE TABLE IF NOT EXISTS public.team_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL,
    role VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'admin', 'member', 'viewer')),
    permissions JSONB DEFAULT '{}',
    invited_by TEXT,
    invited_at TIMESTAMP WITH TIME ZONE,
    joined_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(team_id, user_id)
);

-- Team invitations table
CREATE TABLE IF NOT EXISTS public.team_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    email TEXT NOT NULL,
    role VARCHAR(50) NOT NULL CHECK (role IN ('admin', 'member', 'viewer')),
    invited_by TEXT NOT NULL,
    invitation_token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
    accepted_at TIMESTAMP WITH TIME ZONE,
    declined_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team activity logs table
CREATE TABLE IF NOT EXISTS public.team_activity_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    user_id TEXT NOT NULL,
    activity_type VARCHAR(50) NOT NULL CHECK (activity_type IN ('member_added', 'member_removed', 'member_role_changed', 'team_updated', 'document_shared', 'document_signed', 'workflow_created', 'workflow_completed')),
    activity_description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Team document permissions table
CREATE TABLE IF NOT EXISTS public.team_document_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    permission_type VARCHAR(50) NOT NULL CHECK (permission_type IN ('view', 'edit', 'sign', 'admin')),
    granted_by TEXT NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- TEAM MANAGEMENT FUNCTIONS
-- =====================================================

-- Function to create a team
CREATE OR REPLACE FUNCTION public.create_team(
    p_name VARCHAR(255),
    p_description TEXT,
    p_owner_id TEXT,
    p_settings JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    team_id UUID;
BEGIN
    -- Create team
    INSERT INTO public.teams (name, description, owner_id, settings)
    VALUES (p_name, p_description, p_owner_id, p_settings)
    RETURNING id INTO team_id;
    
    -- Add owner as team member
    INSERT INTO public.team_members (team_id, user_id, role, joined_at)
    VALUES (team_id, p_owner_id, 'owner', CURRENT_TIMESTAMP);
    
    -- Log team creation
    INSERT INTO public.team_activity_logs (team_id, user_id, activity_type, activity_description)
    VALUES (team_id, p_owner_id, 'team_updated', 'Team created: ' || p_name);
    
    RETURN team_id;
END;
$$ LANGUAGE plpgsql;

-- Function to invite user to team
CREATE OR REPLACE FUNCTION public.invite_user_to_team(
    p_team_id UUID,
    p_email TEXT,
    p_role VARCHAR(50),
    p_invited_by TEXT
)
RETURNS UUID AS $$
DECLARE
    invitation_id UUID;
    invitation_token TEXT;
BEGIN
    -- Generate invitation token
    invitation_token := encode(gen_random_bytes(32), 'hex');
    
    -- Create invitation
    INSERT INTO public.team_invitations (
        team_id, email, role, invited_by, invitation_token, expires_at
    ) VALUES (
        p_team_id, p_email, p_role, p_invited_by, invitation_token,
        CURRENT_TIMESTAMP + INTERVAL '7 days'
    ) RETURNING id INTO invitation_id;
    
    -- Log invitation
    INSERT INTO public.team_activity_logs (team_id, user_id, activity_type, activity_description)
    VALUES (p_team_id, p_invited_by, 'member_added', 'Invited ' || p_email || ' to team');
    
    RETURN invitation_id;
END;
$$ LANGUAGE plpgsql;

-- Function to accept team invitation
CREATE OR REPLACE FUNCTION public.accept_team_invitation(
    p_invitation_token TEXT,
    p_user_id TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    invitation_record RECORD;
BEGIN
    -- Get invitation
    SELECT * INTO invitation_record 
    FROM public.team_invitations 
    WHERE invitation_token = p_invitation_token 
    AND status = 'pending' 
    AND expires_at > CURRENT_TIMESTAMP;
    
    IF invitation_record IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Add user to team
    INSERT INTO public.team_members (team_id, user_id, role, invited_by, invited_at, joined_at)
    VALUES (
        invitation_record.team_id, p_user_id, invitation_record.role,
        invitation_record.invited_by, invitation_record.created_at, CURRENT_TIMESTAMP
    ) ON CONFLICT (team_id, user_id) DO UPDATE SET
        role = EXCLUDED.role,
        is_active = TRUE,
        joined_at = CURRENT_TIMESTAMP;
    
    -- Update invitation status
    UPDATE public.team_invitations 
    SET status = 'accepted', accepted_at = CURRENT_TIMESTAMP
    WHERE id = invitation_record.id;
    
    -- Log acceptance
    INSERT INTO public.team_activity_logs (team_id, user_id, activity_type, activity_description)
    VALUES (invitation_record.team_id, p_user_id, 'member_added', 'Joined team via invitation');
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to get user teams
CREATE OR REPLACE FUNCTION public.get_user_teams(p_user_id TEXT)
RETURNS TABLE (
    team_id UUID,
    team_name VARCHAR(255),
    team_description TEXT,
    user_role VARCHAR(50),
    is_owner BOOLEAN,
    member_count BIGINT,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.name,
        t.description,
        tm.role,
        (tm.role = 'owner'),
        (SELECT COUNT(*) FROM public.team_members WHERE team_id = t.id AND is_active = TRUE),
        t.created_at
    FROM public.teams t
    JOIN public.team_members tm ON t.id = tm.team_id
    WHERE tm.user_id = p_user_id 
    AND tm.is_active = TRUE
    AND t.is_active = TRUE
    ORDER BY t.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get team members
CREATE OR REPLACE FUNCTION public.get_team_members(p_team_id UUID)
RETURNS TABLE (
    user_id TEXT,
    role VARCHAR(50),
    permissions JSONB,
    joined_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tm.user_id,
        tm.role,
        tm.permissions,
        tm.joined_at,
        tm.is_active
    FROM public.team_members tm
    WHERE tm.team_id = p_team_id
    ORDER BY tm.joined_at ASC;
END;
$$ LANGUAGE plpgsql;

-- Function to update team member role
CREATE OR REPLACE FUNCTION public.update_team_member_role(
    p_team_id UUID,
    p_user_id TEXT,
    p_new_role VARCHAR(50),
    p_updated_by TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    old_role VARCHAR(50);
BEGIN
    -- Get current role
    SELECT role INTO old_role 
    FROM public.team_members 
    WHERE team_id = p_team_id AND user_id = p_user_id;
    
    IF old_role IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Update role
    UPDATE public.team_members 
    SET role = p_new_role, updated_at = CURRENT_TIMESTAMP
    WHERE team_id = p_team_id AND user_id = p_user_id;
    
    -- Log role change
    INSERT INTO public.team_activity_logs (team_id, user_id, activity_type, activity_description)
    VALUES (p_team_id, p_updated_by, 'member_role_changed', 
            'Changed role from ' || old_role || ' to ' || p_new_role);
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to remove team member
CREATE OR REPLACE FUNCTION public.remove_team_member(
    p_team_id UUID,
    p_user_id TEXT,
    p_removed_by TEXT
)
RETURNS BOOLEAN AS $$
BEGIN
    -- Check if user is team member
    IF NOT EXISTS (
        SELECT 1 FROM public.team_members 
        WHERE team_id = p_team_id AND user_id = p_user_id
    ) THEN
        RETURN FALSE;
    END IF;
    
    -- Remove member
    UPDATE public.team_members 
    SET is_active = FALSE, updated_at = CURRENT_TIMESTAMP
    WHERE team_id = p_team_id AND user_id = p_user_id;
    
    -- Log removal
    INSERT INTO public.team_activity_logs (team_id, user_id, activity_type, activity_description)
    VALUES (p_team_id, p_removed_by, 'member_removed', 'Removed team member');
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to get team activity logs
CREATE OR REPLACE FUNCTION public.get_team_activity_logs(
    p_team_id UUID,
    p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    user_id TEXT,
    activity_type VARCHAR(50),
    activity_description TEXT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tal.id,
        tal.user_id,
        tal.activity_type,
        tal.activity_description,
        tal.metadata,
        tal.created_at
    FROM public.team_activity_logs tal
    WHERE tal.team_id = p_team_id
    ORDER BY tal.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RLS POLICIES FOR TEAM TABLES
-- =====================================================

-- Enable RLS on team tables
ALTER TABLE public.teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.team_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.team_invitations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.team_activity_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.team_document_permissions ENABLE ROW LEVEL SECURITY;

-- Teams policies
CREATE POLICY "Users can view teams they belong to" ON public.teams
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.team_members 
            WHERE team_id = teams.id AND user_id = auth.uid()::text AND is_active = TRUE
        )
    );

CREATE POLICY "Team owners can update their teams" ON public.teams
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.team_members 
            WHERE team_id = teams.id AND user_id = auth.uid()::text AND role = 'owner'
        )
    );

-- Team members policies
CREATE POLICY "Users can view team members of their teams" ON public.team_members
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.team_members tm2
            WHERE tm2.team_id = team_members.team_id AND tm2.user_id = auth.uid()::text AND tm2.is_active = TRUE
        )
    );

CREATE POLICY "Team admins can manage team members" ON public.team_members
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.team_members tm2
            WHERE tm2.team_id = team_members.team_id AND tm2.user_id = auth.uid()::text 
            AND tm2.role IN ('owner', 'admin') AND tm2.is_active = TRUE
        )
    );

-- Team invitations policies
CREATE POLICY "Users can view invitations for their teams" ON public.team_invitations
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.team_members 
            WHERE team_id = team_invitations.team_id AND user_id = auth.uid()::text AND is_active = TRUE
        )
    );

CREATE POLICY "Team admins can manage invitations" ON public.team_invitations
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.team_members 
            WHERE team_id = team_invitations.team_id AND user_id = auth.uid()::text 
            AND role IN ('owner', 'admin') AND is_active = TRUE
        )
    );

-- =====================================================
-- INDEXES FOR TEAM TABLES
-- =====================================================

-- Teams indexes
CREATE INDEX IF NOT EXISTS idx_teams_owner_id ON public.teams(owner_id);
CREATE INDEX IF NOT EXISTS idx_teams_is_active ON public.teams(is_active);

-- Team members indexes
CREATE INDEX IF NOT EXISTS idx_team_members_team_id ON public.team_members(team_id);
CREATE INDEX IF NOT EXISTS idx_team_members_user_id ON public.team_members(user_id);
CREATE INDEX IF NOT EXISTS idx_team_members_role ON public.team_members(role);
CREATE INDEX IF NOT EXISTS idx_team_members_is_active ON public.team_members(is_active);

-- Team invitations indexes
CREATE INDEX IF NOT EXISTS idx_team_invitations_team_id ON public.team_invitations(team_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_email ON public.team_invitations(email);
CREATE INDEX IF NOT EXISTS idx_team_invitations_token ON public.team_invitations(invitation_token);
CREATE INDEX IF NOT EXISTS idx_team_invitations_status ON public.team_invitations(status);
CREATE INDEX IF NOT EXISTS idx_team_invitations_expires_at ON public.team_invitations(expires_at);

-- Team activity logs indexes
CREATE INDEX IF NOT EXISTS idx_team_activity_logs_team_id ON public.team_activity_logs(team_id);
CREATE INDEX IF NOT EXISTS idx_team_activity_logs_user_id ON public.team_activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_team_activity_logs_activity_type ON public.team_activity_logs(activity_type);
CREATE INDEX IF NOT EXISTS idx_team_activity_logs_created_at ON public.team_activity_logs(created_at);

-- Team document permissions indexes
CREATE INDEX IF NOT EXISTS idx_team_document_permissions_team_id ON public.team_document_permissions(team_id);
CREATE INDEX IF NOT EXISTS idx_team_document_permissions_document_id ON public.team_document_permissions(document_id);
CREATE INDEX IF NOT EXISTS idx_team_document_permissions_permission_type ON public.team_document_permissions(permission_type);
CREATE INDEX IF NOT EXISTS idx_team_document_permissions_is_active ON public.team_document_permissions(is_active);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.teams IS 'Teams for collaboration and document sharing';
COMMENT ON TABLE public.team_members IS 'Team members and their roles';
COMMENT ON TABLE public.team_invitations IS 'Team invitation management';
COMMENT ON TABLE public.team_activity_logs IS 'Team activity and collaboration logs';
COMMENT ON TABLE public.team_document_permissions IS 'Document permissions for team members';
COMMENT ON FUNCTION public.create_team(VARCHAR, TEXT, TEXT, JSONB) IS 'Creates a new team';
COMMENT ON FUNCTION public.invite_user_to_team(UUID, TEXT, VARCHAR, TEXT) IS 'Invites a user to join a team';
COMMENT ON FUNCTION public.accept_team_invitation(TEXT, TEXT) IS 'Accepts a team invitation';
COMMENT ON FUNCTION public.get_user_teams(TEXT) IS 'Gets all teams a user belongs to';
COMMENT ON FUNCTION public.get_team_members(UUID) IS 'Gets all members of a team';
COMMENT ON FUNCTION public.update_team_member_role(UUID, TEXT, VARCHAR, TEXT) IS 'Updates a team member role';
COMMENT ON FUNCTION public.remove_team_member(UUID, TEXT, TEXT) IS 'Removes a member from a team';
COMMENT ON FUNCTION public.get_team_activity_logs(UUID, INTEGER) IS 'Gets team activity logs';
\n-- End of buffrsign-starter/sql/18-team_management.sql --\n
-- =====================================================
-- BuffrSign Google OAuth Integration
-- =====================================================
-- Description: Google OAuth integration with user linking and token management
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- GOOGLE OAUTH TABLES
-- =====================================================

-- Google OAuth Tokens
CREATE TABLE IF NOT EXISTS public.google_oauth_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    access_token TEXT NOT NULL,
    refresh_token TEXT,
    token_type VARCHAR(50) DEFAULT 'Bearer',
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    scope TEXT[],
    is_active BOOLEAN DEFAULT true,
    last_used_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Google OAuth User Profiles
CREATE TABLE IF NOT EXISTS public.google_oauth_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    google_id TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL,
    verified_email BOOLEAN DEFAULT false,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    picture_url TEXT,
    locale VARCHAR(10),
    hd TEXT, -- Hosted domain for Google Workspace
    is_plus_user BOOLEAN DEFAULT false,
    verified BOOLEAN DEFAULT false,
    link TEXT,
    gender TEXT,
    birthday TEXT,
    raw_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Google OAuth Sessions
CREATE TABLE IF NOT EXISTS public.google_oauth_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    session_id TEXT NOT NULL,
    state TEXT NOT NULL,
    code_verifier TEXT,
    redirect_uri TEXT,
    scope TEXT[],
    is_active BOOLEAN DEFAULT true,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Google OAuth Events
CREATE TABLE IF NOT EXISTS public.google_oauth_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    event_type VARCHAR(50) NOT NULL CHECK (event_type IN ('login', 'logout', 'token_refresh', 'token_expired', 'scope_change', 'error')),
    event_data JSONB DEFAULT '{}',
    ip_address INET,
    user_agent TEXT,
    success BOOLEAN NOT NULL,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Google OAuth Permissions
CREATE TABLE IF NOT EXISTS public.google_oauth_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_scope TEXT NOT NULL,
    granted_at TIMESTAMP WITH TIME ZONE NOT NULL,
    revoked_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- =====================================================
-- GOOGLE OAUTH FUNCTIONS
-- =====================================================

-- Function to store Google OAuth tokens
CREATE OR REPLACE FUNCTION public.store_google_oauth_tokens(
    p_user_id UUID,
    p_access_token TEXT,
    p_refresh_token TEXT,
    p_expires_at TIMESTAMP WITH TIME ZONE,
    p_scope TEXT[]
)
RETURNS UUID AS $$
DECLARE
    token_id UUID;
BEGIN
    -- Deactivate existing tokens for this user
    UPDATE public.google_oauth_tokens 
    SET is_active = false, updated_at = now()
    WHERE user_id = p_user_id;
    
    -- Insert new token
    INSERT INTO public.google_oauth_tokens (
        user_id, access_token, refresh_token, expires_at, scope
    ) VALUES (
        p_user_id, p_access_token, p_refresh_token, p_expires_at, p_scope
    ) RETURNING id INTO token_id;
    
    RETURN token_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get active Google OAuth token
CREATE OR REPLACE FUNCTION public.get_active_google_token(p_user_id UUID)
RETURNS TABLE (
    id UUID,
    access_token TEXT,
    refresh_token TEXT,
    expires_at TIMESTAMP WITH TIME ZONE,
    scope TEXT[]
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        got.id,
        got.access_token,
        got.refresh_token,
        got.expires_at,
        got.scope
    FROM public.google_oauth_tokens got
    WHERE got.user_id = p_user_id 
      AND got.is_active = true
      AND got.expires_at > now()
    ORDER BY got.created_at DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to refresh Google OAuth token
CREATE OR REPLACE FUNCTION public.refresh_google_oauth_token(
    p_user_id UUID,
    p_new_access_token TEXT,
    p_new_refresh_token TEXT,
    p_new_expires_at TIMESTAMP WITH TIME ZONE
)
RETURNS BOOLEAN AS $$
DECLARE
    token_exists BOOLEAN;
BEGIN
    -- Check if user has existing token
    SELECT EXISTS(
        SELECT 1 FROM public.google_oauth_tokens 
        WHERE user_id = p_user_id AND is_active = true
    ) INTO token_exists;
    
    IF NOT token_exists THEN
        RETURN false;
    END IF;
    
    -- Update existing token
    UPDATE public.google_oauth_tokens 
    SET 
        access_token = p_new_access_token,
        refresh_token = COALESCE(p_new_refresh_token, refresh_token),
        expires_at = p_new_expires_at,
        last_used_at = now(),
        updated_at = now()
    WHERE user_id = p_user_id AND is_active = true;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- Function to revoke Google OAuth tokens
CREATE OR REPLACE FUNCTION public.revoke_google_oauth_tokens(p_user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    -- Deactivate all tokens for this user
    UPDATE public.google_oauth_tokens 
    SET is_active = false, updated_at = now()
    WHERE user_id = p_user_id;
    
    -- Log the revocation event
    INSERT INTO public.google_oauth_events (
        user_id, event_type, success, event_data
    ) VALUES (
        p_user_id, 'logout', true, 
        jsonb_build_object('action', 'token_revocation')
    );
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- Function to store Google OAuth profile
CREATE OR REPLACE FUNCTION public.store_google_oauth_profile(
    p_user_id UUID,
    p_google_id TEXT,
    p_email TEXT,
    p_name TEXT,
    p_given_name TEXT,
    p_family_name TEXT,
    p_picture_url TEXT,
    p_verified_email BOOLEAN,
    p_raw_data JSONB
)
RETURNS UUID AS $$
DECLARE
    profile_id UUID;
BEGIN
    -- Insert or update Google OAuth profile
    INSERT INTO public.google_oauth_profiles (
        user_id, google_id, email, name, given_name, family_name,
        picture_url, verified_email, raw_data
    ) VALUES (
        p_user_id, p_google_id, p_email, p_name, p_given_name, p_family_name,
        p_picture_url, p_verified_email, p_raw_data
    ) ON CONFLICT (google_id) DO UPDATE SET
        user_id = EXCLUDED.user_id,
        email = EXCLUDED.email,
        name = EXCLUDED.name,
        given_name = EXCLUDED.given_name,
        family_name = EXCLUDED.family_name,
        picture_url = EXCLUDED.picture_url,
        verified_email = EXCLUDED.verified_email,
        raw_data = EXCLUDED.raw_data,
        updated_at = now()
    RETURNING id INTO profile_id;
    
    RETURN profile_id;
END;
$$ LANGUAGE plpgsql;

-- Function to log Google OAuth events
CREATE OR REPLACE FUNCTION public.log_google_oauth_event(
    p_user_id UUID,
    p_event_type VARCHAR(50),
    p_success BOOLEAN,
    p_event_data JSONB DEFAULT '{}',
    p_error_message TEXT DEFAULT NULL,
    p_ip_address INET DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    event_id UUID;
BEGIN
    INSERT INTO public.google_oauth_events (
        user_id, event_type, success, event_data, error_message, ip_address, user_agent
    ) VALUES (
        p_user_id, p_event_type, p_success, p_event_data, p_error_message, p_ip_address, p_user_agent
    ) RETURNING id INTO event_id;
    
    RETURN event_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get Google OAuth user profile
CREATE OR REPLACE FUNCTION public.get_google_oauth_profile(p_user_id UUID)
RETURNS TABLE (
    google_id TEXT,
    email TEXT,
    name TEXT,
    given_name TEXT,
    family_name TEXT,
    picture_url TEXT,
    verified_email BOOLEAN,
    locale VARCHAR(10),
    hd TEXT,
    is_plus_user BOOLEAN,
    verified BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        gop.google_id,
        gop.email,
        gop.name,
        gop.given_name,
        gop.family_name,
        gop.picture_url,
        gop.verified_email,
        gop.locale,
        gop.hd,
        gop.is_plus_user,
        gop.verified
    FROM public.google_oauth_profiles gop
    WHERE gop.user_id = p_user_id;
END;
$$ LANGUAGE plpgsql;

-- Function to check Google OAuth permissions
CREATE OR REPLACE FUNCTION public.check_google_oauth_permission(
    p_user_id UUID,
    p_permission_scope TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    has_permission BOOLEAN;
BEGIN
    SELECT EXISTS(
        SELECT 1 FROM public.google_oauth_permissions 
        WHERE user_id = p_user_id 
          AND permission_scope = p_permission_scope 
          AND is_active = true
    ) INTO has_permission;
    
    RETURN has_permission;
END;
$$ LANGUAGE plpgsql;

-- Function to grant Google OAuth permission
CREATE OR REPLACE FUNCTION public.grant_google_oauth_permission(
    p_user_id UUID,
    p_permission_scope TEXT
)
RETURNS UUID AS $$
DECLARE
    permission_id UUID;
BEGIN
    INSERT INTO public.google_oauth_permissions (
        user_id, permission_scope, granted_at
    ) VALUES (
        p_user_id, p_permission_scope, now()
    ) ON CONFLICT (user_id, permission_scope) DO UPDATE SET
        is_active = true,
        granted_at = now(),
        revoked_at = NULL
    RETURNING id INTO permission_id;
    
    RETURN permission_id;
END;
$$ LANGUAGE plpgsql;

-- Function to revoke Google OAuth permission
CREATE OR REPLACE FUNCTION public.revoke_google_oauth_permission(
    p_user_id UUID,
    p_permission_scope TEXT
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE public.google_oauth_permissions 
    SET is_active = false, revoked_at = now()
    WHERE user_id = p_user_id AND permission_scope = p_permission_scope;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- GOOGLE OAUTH TRIGGERS
-- =====================================================

-- Trigger function for updated_at
CREATE OR REPLACE FUNCTION public.update_google_oauth_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
CREATE TRIGGER update_google_oauth_tokens_updated_at 
    BEFORE UPDATE ON public.google_oauth_tokens 
    FOR EACH ROW EXECUTE FUNCTION public.update_google_oauth_updated_at();

CREATE TRIGGER update_google_oauth_profiles_updated_at 
    BEFORE UPDATE ON public.google_oauth_profiles 
    FOR EACH ROW EXECUTE FUNCTION public.update_google_oauth_updated_at();

-- =====================================================
-- RLS POLICIES FOR GOOGLE OAUTH TABLES
-- =====================================================

-- Enable RLS on Google OAuth tables
ALTER TABLE public.google_oauth_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.google_oauth_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.google_oauth_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.google_oauth_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.google_oauth_permissions ENABLE ROW LEVEL SECURITY;

-- Google OAuth tokens policies
CREATE POLICY "Users can view own Google OAuth tokens" ON public.google_oauth_tokens
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own Google OAuth tokens" ON public.google_oauth_tokens
    FOR ALL USING (auth.uid() = user_id);

-- Google OAuth profiles policies
CREATE POLICY "Users can view own Google OAuth profiles" ON public.google_oauth_profiles
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own Google OAuth profiles" ON public.google_oauth_profiles
    FOR ALL USING (auth.uid() = user_id);

-- Google OAuth sessions policies
CREATE POLICY "Users can view own Google OAuth sessions" ON public.google_oauth_sessions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own Google OAuth sessions" ON public.google_oauth_sessions
    FOR ALL USING (auth.uid() = user_id);

-- Google OAuth events policies
CREATE POLICY "Users can view own Google OAuth events" ON public.google_oauth_events
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert Google OAuth events" ON public.google_oauth_events
    FOR INSERT WITH CHECK (true);

-- Google OAuth permissions policies
CREATE POLICY "Users can view own Google OAuth permissions" ON public.google_oauth_permissions
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own Google OAuth permissions" ON public.google_oauth_permissions
    FOR ALL USING (auth.uid() = user_id);

-- =====================================================
-- INDEXES FOR GOOGLE OAUTH TABLES
-- =====================================================

-- Google OAuth tokens indexes
CREATE INDEX IF NOT EXISTS idx_google_oauth_tokens_user_id ON public.google_oauth_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_tokens_active ON public.google_oauth_tokens(is_active);
CREATE INDEX IF NOT EXISTS idx_google_oauth_tokens_expires_at ON public.google_oauth_tokens(expires_at);

-- Google OAuth profiles indexes
CREATE INDEX IF NOT EXISTS idx_google_oauth_profiles_user_id ON public.google_oauth_profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_profiles_google_id ON public.google_oauth_profiles(google_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_profiles_email ON public.google_oauth_profiles(email);

-- Google OAuth sessions indexes
CREATE INDEX IF NOT EXISTS idx_google_oauth_sessions_user_id ON public.google_oauth_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_sessions_session_id ON public.google_oauth_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_sessions_active ON public.google_oauth_sessions(is_active);
CREATE INDEX IF NOT EXISTS idx_google_oauth_sessions_expires_at ON public.google_oauth_sessions(expires_at);

-- Google OAuth events indexes
CREATE INDEX IF NOT EXISTS idx_google_oauth_events_user_id ON public.google_oauth_events(user_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_events_event_type ON public.google_oauth_events(event_type);
CREATE INDEX IF NOT EXISTS idx_google_oauth_events_success ON public.google_oauth_events(success);
CREATE INDEX IF NOT EXISTS idx_google_oauth_events_created_at ON public.google_oauth_events(created_at);

-- Google OAuth permissions indexes
CREATE INDEX IF NOT EXISTS idx_google_oauth_permissions_user_id ON public.google_oauth_permissions(user_id);
CREATE INDEX IF NOT EXISTS idx_google_oauth_permissions_scope ON public.google_oauth_permissions(permission_scope);
CREATE INDEX IF NOT EXISTS idx_google_oauth_permissions_active ON public.google_oauth_permissions(is_active);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.google_oauth_tokens IS 'Google OAuth access and refresh tokens';
COMMENT ON TABLE public.google_oauth_profiles IS 'Google OAuth user profile information';
COMMENT ON TABLE public.google_oauth_sessions IS 'Google OAuth session management';
COMMENT ON TABLE public.google_oauth_events IS 'Google OAuth event logging and tracking';
COMMENT ON TABLE public.google_oauth_permissions IS 'Google OAuth permission scopes';
COMMENT ON FUNCTION public.store_google_oauth_tokens(UUID, TEXT, TEXT, TIMESTAMP WITH TIME ZONE, TEXT[]) IS 'Stores Google OAuth tokens for a user';
COMMENT ON FUNCTION public.get_active_google_token(UUID) IS 'Gets active Google OAuth token for a user';
COMMENT ON FUNCTION public.refresh_google_oauth_token(UUID, TEXT, TEXT, TIMESTAMP WITH TIME ZONE) IS 'Refreshes Google OAuth token for a user';
COMMENT ON FUNCTION public.revoke_google_oauth_tokens(UUID) IS 'Revokes all Google OAuth tokens for a user';
COMMENT ON FUNCTION public.store_google_oauth_profile(UUID, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT, BOOLEAN, JSONB) IS 'Stores Google OAuth user profile information';
COMMENT ON FUNCTION public.log_google_oauth_event(UUID, VARCHAR, BOOLEAN, JSONB, TEXT, INET, TEXT) IS 'Logs Google OAuth events and activities';
COMMENT ON FUNCTION public.get_google_oauth_profile(UUID) IS 'Gets Google OAuth profile for a user';
COMMENT ON FUNCTION public.check_google_oauth_permission(UUID, TEXT) IS 'Checks if user has specific Google OAuth permission';
COMMENT ON FUNCTION public.grant_google_oauth_permission(UUID, TEXT) IS 'Grants Google OAuth permission to a user';
COMMENT ON FUNCTION public.revoke_google_oauth_permission(UUID, TEXT) IS 'Revokes Google OAuth permission from a user';
\n-- End of buffrsign-starter/sql/14-google_oauth_integration.sql --\n
-- ============================================================================
-- Email System Management
-- ============================================================================
-- This file contains email system functions, templates, and queue management
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- EMAIL TEMPLATE FUNCTIONS
-- ============================================================================

-- Function to get email template
CREATE OR REPLACE FUNCTION get_email_template(
    template_type_param VARCHAR,
    locale_param VARCHAR DEFAULT 'en-NA'
)
RETURNS TABLE(
    id UUID,
    name VARCHAR,
    subject_template TEXT,
    html_template TEXT,
    text_template TEXT,
    variables JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        et.id,
        et.name,
        et.subject_template,
        et.html_template,
        et.text_template,
        et.variables
    FROM email_templates et
    WHERE et.template_type = template_type_param
    AND et.locale = locale_param
    AND et.is_active = true
    ORDER BY et.is_default DESC, et.created_at DESC
    LIMIT 1;
    
    -- If no template found for specific locale, try default locale
    IF NOT FOUND THEN
        RETURN QUERY
        SELECT 
            et.id,
            et.name,
            et.subject_template,
            et.html_template,
            et.text_template,
            et.variables
        FROM email_templates et
        WHERE et.template_type = template_type_param
        AND et.locale = 'en-NA'
        AND et.is_active = true
        ORDER BY et.is_default DESC, et.created_at DESC
        LIMIT 1;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to get email configuration
CREATE OR REPLACE FUNCTION get_email_config(key VARCHAR)
RETURNS JSONB AS $$
DECLARE
    config_value JSONB;
BEGIN
    SELECT esc.config_value INTO config_value
    FROM email_system_config esc
    WHERE esc.config_key = key
    AND esc.is_active = true;
    
    RETURN COALESCE(config_value, '{}'::jsonb);
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- EMAIL QUEUE FUNCTIONS
-- ============================================================================

-- Function to enqueue email
CREATE OR REPLACE FUNCTION enqueue_email(
    email_json JSONB,
    priority_level INTEGER DEFAULT 5,
    schedule_time TIMESTAMPTZ DEFAULT NOW()
)
RETURNS UUID AS $$
DECLARE
    queue_id UUID;
BEGIN
    INSERT INTO email_queue (
        email_data,
        priority,
        scheduled_for
    ) VALUES (
        email_json,
        priority_level,
        schedule_time
    ) RETURNING id INTO queue_id;
    
    RETURN queue_id;
END;
$$ LANGUAGE plpgsql;

-- Function to process email queue
CREATE OR REPLACE FUNCTION process_email_queue(batch_size INTEGER DEFAULT 10)
RETURNS TABLE(
    id UUID,
    email_type VARCHAR,
    recipient_email VARCHAR,
    subject TEXT,
    content JSONB,
    priority INTEGER,
    attempts INTEGER,
    document_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eq.id,
        eq.email_type,
        eq.recipient_email,
        eq.subject,
        eq.content,
        eq.priority,
        eq.attempts,
        eq.document_id
    FROM email_queue eq
    WHERE eq.status = 'queued'
    AND eq.scheduled_for <= NOW()
    AND eq.attempts < 3
    ORDER BY eq.priority ASC, eq.created_at ASC
    LIMIT batch_size;
END;
$$ LANGUAGE plpgsql;

-- Function to complete email queue item
CREATE OR REPLACE FUNCTION complete_email_queue_item(
    queue_id UUID,
    success BOOLEAN,
    error_msg TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    IF success THEN
        UPDATE email_queue 
        SET 
            status = 'sent',
            processed_at = NOW(),
            updated_at = NOW()
        WHERE id = queue_id;
    ELSE
        UPDATE email_queue 
        SET 
            status = CASE 
                WHEN attempts + 1 >= max_attempts THEN 'failed'
                ELSE 'queued'
            END,
            attempts = attempts + 1,
            error_message = error_msg,
            scheduled_for = CASE 
                WHEN attempts + 1 < max_attempts THEN NOW() + INTERVAL '5 minutes' * POWER(2, attempts)
                ELSE scheduled_for
            END,
            updated_at = NOW()
        WHERE id = queue_id;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Function to update email queue status
CREATE OR REPLACE FUNCTION update_email_queue_status(
    queue_id UUID,
    new_status VARCHAR,
    error_msg TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE email_queue 
    SET 
        status = new_status,
        attempts = attempts + 1,
        processed_at = NOW(),
        error_message = error_msg,
        updated_at = NOW()
    WHERE id = queue_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- EMAIL NOTIFICATION FUNCTIONS
-- ============================================================================

-- Function to send document invitation email
CREATE OR REPLACE FUNCTION send_document_invitation(
    p_document_id UUID,
    p_recipient_email VARCHAR,
    p_recipient_name VARCHAR,
    p_document_title VARCHAR,
    p_sender_name VARCHAR
)
RETURNS UUID AS $$
DECLARE
    email_data JSONB;
    queue_id UUID;
BEGIN
    email_data := jsonb_build_object(
        'email_type', 'document_invitation',
        'recipient_email', p_recipient_email,
        'recipient_name', p_recipient_name,
        'document_id', p_document_id,
        'document_title', p_document_title,
        'sender_name', p_sender_name,
        'subject', 'Document Invitation: ' || p_document_title,
        'priority', 3
    );
    
    SELECT enqueue_email(email_data, 3) INTO queue_id;
    
    RETURN queue_id;
END;
$$ LANGUAGE plpgsql;

-- Function to send signature reminder email
CREATE OR REPLACE FUNCTION send_signature_reminder(
    p_document_id UUID,
    p_recipient_email VARCHAR,
    p_recipient_name VARCHAR,
    p_document_title VARCHAR,
    p_reminder_type VARCHAR DEFAULT 'signature_reminder'
)
RETURNS UUID AS $$
DECLARE
    email_data JSONB;
    queue_id UUID;
BEGIN
    email_data := jsonb_build_object(
        'email_type', p_reminder_type,
        'recipient_email', p_recipient_email,
        'recipient_name', p_recipient_name,
        'document_id', p_document_id,
        'document_title', p_document_title,
        'subject', 'Reminder: Please sign ' || p_document_title,
        'priority', 4
    );
    
    SELECT enqueue_email(email_data, 4) INTO queue_id;
    
    RETURN queue_id;
END;
$$ LANGUAGE plpgsql;

-- Function to send document completion notification
CREATE OR REPLACE FUNCTION send_document_completion(
    p_document_id UUID,
    p_recipient_email VARCHAR,
    p_recipient_name VARCHAR,
    p_document_title VARCHAR
)
RETURNS UUID AS $$
DECLARE
    email_data JSONB;
    queue_id UUID;
BEGIN
    email_data := jsonb_build_object(
        'email_type', 'document_completed',
        'recipient_email', p_recipient_email,
        'recipient_name', p_recipient_name,
        'document_id', p_document_id,
        'document_title', p_document_title,
        'subject', 'Document Completed: ' || p_document_title,
        'priority', 2
    );
    
    SELECT enqueue_email(email_data, 2) INTO queue_id;
    
    RETURN queue_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- EMAIL ANALYTICS FUNCTIONS
-- ============================================================================

-- Function to update daily email analytics
CREATE OR REPLACE FUNCTION update_daily_email_analytics()
RETURNS VOID AS $$
DECLARE
    analytics_date DATE;
    email_type_record RECORD;
BEGIN
    analytics_date := CURRENT_DATE - INTERVAL '1 day';
    
    -- Loop through each email type
    FOR email_type_record IN 
        SELECT DISTINCT email_type FROM email_notifications 
        WHERE sent_at::date = analytics_date
    LOOP
        INSERT INTO email_analytics (
            date, email_type, total_sent, total_delivered, 
            total_opened, total_clicked, total_bounced, total_failed,
            delivery_rate, open_rate, click_rate, bounce_rate
        )
        SELECT 
            analytics_date,
            email_type_record.email_type,
            COUNT(*) as total_sent,
            COUNT(*) FILTER (WHERE status = 'delivered') as total_delivered,
            COUNT(*) FILTER (WHERE status = 'opened') as total_opened,
            COUNT(*) FILTER (WHERE status = 'clicked') as total_clicked,
            COUNT(*) FILTER (WHERE status = 'bounced') as total_bounced,
            COUNT(*) FILTER (WHERE status = 'failed') as total_failed,
            CASE WHEN COUNT(*) > 0 THEN 
                ROUND((COUNT(*) FILTER (WHERE status = 'delivered') * 100.0 / COUNT(*)), 2)
                ELSE 0 
            END as delivery_rate,
            CASE WHEN COUNT(*) FILTER (WHERE status = 'delivered') > 0 THEN
                ROUND((COUNT(*) FILTER (WHERE status = 'opened') * 100.0 / COUNT(*) FILTER (WHERE status = 'delivered')), 2)
                ELSE 0
            END as open_rate,
            CASE WHEN COUNT(*) FILTER (WHERE status = 'opened') > 0 THEN
                ROUND((COUNT(*) FILTER (WHERE status = 'clicked') * 100.0 / COUNT(*) FILTER (WHERE status = 'opened')), 2)
                ELSE 0
            END as click_rate,
            CASE WHEN COUNT(*) > 0 THEN
                ROUND((COUNT(*) FILTER (WHERE status = 'bounced') * 100.0 / COUNT(*)), 2)
                ELSE 0
            END as bounce_rate
        FROM email_notifications 
        WHERE sent_at::date = analytics_date 
        AND email_type = email_type_record.email_type
        ON CONFLICT (date, email_type) 
        DO UPDATE SET
            total_sent = EXCLUDED.total_sent,
            total_delivered = EXCLUDED.total_delivered,
            total_opened = EXCLUDED.total_opened,
            total_clicked = EXCLUDED.total_clicked,
            total_bounced = EXCLUDED.total_bounced,
            total_failed = EXCLUDED.total_failed,
            delivery_rate = EXCLUDED.delivery_rate,
            open_rate = EXCLUDED.open_rate,
            click_rate = EXCLUDED.click_rate,
            bounce_rate = EXCLUDED.bounce_rate,
            updated_at = NOW();
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SCHEDULED REMINDERS FUNCTIONS
-- ============================================================================

-- Function to process scheduled reminders
CREATE OR REPLACE FUNCTION process_scheduled_reminders()
RETURNS VOID AS $$
DECLARE
    reminder_record RECORD;
BEGIN
    -- Get all pending reminders that are due
    FOR reminder_record IN 
        SELECT * FROM scheduled_reminders 
        WHERE status = 'pending' 
        AND scheduled_for <= NOW()
        AND attempts < 3
    LOOP
        -- Update reminder status to indicate processing
        UPDATE scheduled_reminders 
        SET 
            status = 'sent',
            attempts = attempts + 1,
            last_attempt_at = NOW(),
            updated_at = NOW()
        WHERE id = reminder_record.id;
        
        -- The actual email sending would be handled by the application
        -- This function just marks reminders as ready for processing
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- EMAIL CONFLICT DETECTION FUNCTIONS
-- ============================================================================

-- Function to check document email conflicts
CREATE OR REPLACE FUNCTION check_document_email_conflicts(
    document_id UUID,
    email_type VARCHAR
)
RETURNS TABLE(
    conflict_type VARCHAR,
    severity VARCHAR,
    message TEXT,
    recommendation TEXT,
    document_status VARCHAR
) AS $$
BEGIN
    -- Check document status conflicts
    RETURN QUERY
    SELECT 
        'document_status'::VARCHAR(50) as conflict_type,
        CASE 
            WHEN d.status = 'completed' AND email_type = 'document_invitation' THEN 'high'::VARCHAR(20)
            WHEN d.status = 'draft' AND email_type = 'signature_reminder' THEN 'high'::VARCHAR(20)
            WHEN d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'critical'::VARCHAR(20)
            ELSE 'low'::VARCHAR(20)
        END as severity,
        ('Document status: ' || d.status || ' conflicts with email type: ' || email_type)::TEXT as message,
        CASE 
            WHEN d.status = 'completed' AND email_type = 'document_invitation' THEN 'Consider sending completion notification instead'::TEXT
            WHEN d.status = 'draft' AND email_type = 'signature_reminder' THEN 'Wait for document to be sent before sending reminders'::TEXT
            WHEN d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'Send document expired notification instead'::TEXT
            ELSE 'No specific recommendation'::TEXT
        END as recommendation,
        d.status as document_status
    FROM documents d
    WHERE d.id = document_id
    AND (
        (d.status = 'completed' AND email_type = 'document_invitation') OR
        (d.status = 'draft' AND email_type = 'signature_reminder') OR
        (d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder'))
    );
END;
$$ LANGUAGE plpgsql;

-- Function to check signature workflow conflicts
CREATE OR REPLACE FUNCTION check_signature_workflow_conflicts(
    recipient_emails TEXT[],
    email_type VARCHAR
)
RETURNS TABLE(
    conflict_type VARCHAR,
    severity VARCHAR,
    message TEXT,
    recommendation TEXT,
    affected_email VARCHAR,
    document_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'signature_workflow'::VARCHAR(50) as conflict_type,
        CASE 
            WHEN ds.signature_data IS NOT NULL AND email_type = 'signature_reminder' THEN 'medium'::VARCHAR(20)
            WHEN ds.signature_data IS NULL AND email_type IN ('document_invitation', 'signature_reminder') THEN 'low'::VARCHAR(20)
            ELSE 'low'::VARCHAR(20)
        END as severity,
        ('Recipient has ' || CASE WHEN ds.signature_data IS NOT NULL THEN 'signed' ELSE 'not signed' END || ' the document')::TEXT as message,
        CASE 
            WHEN ds.signature_data IS NOT NULL AND email_type = 'signature_reminder' THEN 'Remove signed recipients from reminder list'::TEXT
            ELSE 'No specific recommendation'::TEXT
        END as recommendation,
        r.email as affected_email,
        ds.document_id
    FROM signatures ds
    JOIN recipients r ON r.id = ds.recipient_id
    WHERE r.email = ANY(recipient_emails)
    AND (
        (ds.signature_data IS NOT NULL AND email_type = 'signature_reminder')
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION get_email_template(VARCHAR, VARCHAR) IS 'Retrieves email template by type and locale';
COMMENT ON FUNCTION get_email_config(VARCHAR) IS 'Retrieves email system configuration by key';
COMMENT ON FUNCTION enqueue_email(JSONB, INTEGER, TIMESTAMPTZ) IS 'Adds email to processing queue';
COMMENT ON FUNCTION process_email_queue(INTEGER) IS 'Processes queued emails in batches';
COMMENT ON FUNCTION complete_email_queue_item(UUID, BOOLEAN, TEXT) IS 'Marks email queue item as completed or failed';
COMMENT ON FUNCTION send_document_invitation(UUID, VARCHAR, VARCHAR, VARCHAR, VARCHAR) IS 'Sends document invitation email';
COMMENT ON FUNCTION send_signature_reminder(UUID, VARCHAR, VARCHAR, VARCHAR, VARCHAR) IS 'Sends signature reminder email';
COMMENT ON FUNCTION send_document_completion(UUID, VARCHAR, VARCHAR, VARCHAR) IS 'Sends document completion notification';
COMMENT ON FUNCTION update_daily_email_analytics() IS 'Updates daily email analytics';
COMMENT ON FUNCTION process_scheduled_reminders() IS 'Processes scheduled email reminders';
COMMENT ON FUNCTION check_document_email_conflicts(UUID, VARCHAR) IS 'Checks for document status conflicts with email types';
COMMENT ON FUNCTION check_signature_workflow_conflicts(TEXT[], VARCHAR) IS 'Checks for signature workflow conflicts with email types';
\n-- End of buffrsign-starter/sql/5-email_system.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- ============================================================================
-- Documents and Signatures Management
-- ============================================================================
-- This file contains document management, signature processing, and related functions
-- for the BuffrSign platform
-- ============================================================================

-- ============================================================================
-- DOCUMENT MANAGEMENT FUNCTIONS
-- ============================================================================

-- Function to get document audit trail
CREATE OR REPLACE FUNCTION get_document_audit_trail(doc_uuid UUID)
RETURNS TABLE(
    action VARCHAR,
    details JSONB,
    user_name VARCHAR,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        at.action,
        at.details,
        u.full_name as user_name,
        at.created_at
    FROM audit_trail at
    LEFT JOIN profiles u ON at.user_id = u.id
    WHERE at.document_id = doc_uuid
    ORDER BY at.created_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to get document processing summary
CREATE OR REPLACE FUNCTION get_document_processing_summary(doc_uuid UUID)
RETURNS TABLE(
    processing_type VARCHAR,
    status VARCHAR,
    progress INTEGER,
    started_at TIMESTAMP,
    completed_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dps.processing_type,
        dps.status,
        dps.progress,
        dps.started_at,
        dps.completed_at
    FROM document_processing_status dps
    WHERE dps.document_id = doc_uuid
    ORDER BY dps.started_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to update document processing status
CREATE OR REPLACE FUNCTION update_document_processing_status(
    p_document_id UUID,
    p_processing_type VARCHAR,
    p_status VARCHAR,
    p_progress INTEGER DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL,
    p_error_message TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    status_id UUID;
BEGIN
    INSERT INTO document_processing_status (
        document_id,
        processing_type,
        status,
        progress,
        metadata,
        error_message,
        completed_at
    ) VALUES (
        p_document_id,
        p_processing_type,
        p_status,
        p_progress,
        p_metadata,
        p_error_message,
        CASE WHEN p_status = 'completed' OR p_status = 'failed' THEN CURRENT_TIMESTAMP ELSE NULL END
    )
    ON CONFLICT (document_id, processing_type) 
    DO UPDATE SET
        status = EXCLUDED.status,
        progress = EXCLUDED.progress,
        metadata = EXCLUDED.metadata,
        error_message = EXCLUDED.error_message,
        completed_at = EXCLUDED.completed_at,
        updated_at = CURRENT_TIMESTAMP
    RETURNING id INTO status_id;
    
    RETURN status_id;
END;
$$ LANGUAGE plpgsql;

-- Function to trigger document activity logging
CREATE OR REPLACE FUNCTION trigger_log_document_activity()
RETURNS TRIGGER AS $$
BEGIN
    -- Log document creation
    IF TG_OP = 'INSERT' THEN
        PERFORM log_user_activity(
            NEW.created_by,
            'document_created',
            jsonb_build_object(
                'document_id', NEW.id,
                'document_title', NEW.title,
                'file_size', NEW.file_size,
                'mime_type', NEW.mime_type
            )
        );
    END IF;
    
    -- Log document updates
    IF TG_OP = 'UPDATE' THEN
        PERFORM log_user_activity(
            NEW.created_by,
            'document_updated',
            jsonb_build_object(
                'document_id', NEW.id,
                'document_title', NEW.title,
                'status', NEW.status
            )
        );
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Function to trigger signature activity logging
CREATE OR REPLACE FUNCTION trigger_log_signature_activity()
RETURNS TRIGGER AS $$
DECLARE
    user_id UUID;
BEGIN
    -- Get user_id from recipient
    SELECT r.document_id INTO user_id
    FROM recipients r
    WHERE r.id = NEW.recipient_id;
    
    -- Log signature activity
    IF TG_OP = 'INSERT' THEN
        PERFORM log_user_activity(
            user_id,
            'signature_created',
            jsonb_build_object(
                'signature_id', NEW.id,
                'document_id', NEW.document_id,
                'signature_type', NEW.signature_type
            )
        );
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SIGNATURE VALIDATION FUNCTIONS
-- ============================================================================

-- Function to validate signature data
CREATE OR REPLACE FUNCTION validate_signature_data(
    p_signature_data TEXT,
    p_signature_type VARCHAR
)
RETURNS BOOLEAN AS $$
BEGIN
    -- Basic validation based on signature type
    CASE p_signature_type
        WHEN 'digital' THEN
            -- Digital signatures should have valid certificate data
            RETURN p_signature_data IS NOT NULL AND LENGTH(p_signature_data) > 100;
        WHEN 'biometric' THEN
            -- Biometric signatures should have biometric data
            RETURN p_signature_data IS NOT NULL AND LENGTH(p_signature_data) > 50;
        WHEN 'drawn' THEN
            -- Drawn signatures should have drawing data
            RETURN p_signature_data IS NOT NULL AND LENGTH(p_signature_data) > 20;
        ELSE
            RETURN FALSE;
    END CASE;
END;
$$ LANGUAGE plpgsql;

-- Function to check signature compliance
CREATE OR REPLACE FUNCTION check_signature_compliance(
    p_signature_id UUID
)
RETURNS TABLE(
    is_compliant BOOLEAN,
    compliance_score INTEGER,
    issues JSONB
) AS $$
DECLARE
    sig_record RECORD;
    compliance_score INTEGER := 100;
    issues JSONB := '[]'::JSONB;
BEGIN
    -- Get signature details
    SELECT * INTO sig_record
    FROM signatures
    WHERE id = p_signature_id;
    
    -- Check if signature exists
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 0, '["Signature not found"]'::JSONB;
        RETURN;
    END IF;
    
    -- Check signature data validity
    IF NOT validate_signature_data(sig_record.signature_data, sig_record.signature_type) THEN
        compliance_score := compliance_score - 30;
        issues := issues || '["Invalid signature data"]'::JSONB;
    END IF;
    
    -- Check if signature has certificate (for digital signatures)
    IF sig_record.signature_type = 'digital' AND sig_record.certificate_id IS NULL THEN
        compliance_score := compliance_score - 20;
        issues := issues || '["Missing certificate for digital signature"]'::JSONB;
    END IF;
    
    -- Check IP address and user agent (security requirements)
    IF sig_record.ip_address IS NULL OR sig_record.user_agent IS NULL THEN
        compliance_score := compliance_score - 10;
        issues := issues || '["Missing security information"]'::JSONB;
    END IF;
    
    -- Check timestamp token
    IF sig_record.timestamp_token IS NULL THEN
        compliance_score := compliance_score - 15;
        issues := issues || '["Missing timestamp token"]'::JSONB;
    END IF;
    
    -- Ensure compliance score doesn't go below 0
    compliance_score := GREATEST(compliance_score, 0);
    
    RETURN QUERY SELECT 
        compliance_score >= 70,
        compliance_score,
        issues;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- DOCUMENT WORKFLOW FUNCTIONS
-- ============================================================================

-- Function to get document workflow status
CREATE OR REPLACE FUNCTION get_document_workflow_status(p_document_id UUID)
RETURNS TABLE(
    workflow_type VARCHAR,
    status VARCHAR,
    progress INTEGER,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    error_message TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dps.processing_type as workflow_type,
        dps.status,
        dps.progress,
        dps.started_at,
        dps.completed_at,
        dps.error_message
    FROM document_processing_status dps
    WHERE dps.document_id = p_document_id
    ORDER BY dps.started_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Function to update document status
CREATE OR REPLACE FUNCTION update_document_status(
    p_document_id UUID,
    p_new_status VARCHAR,
    p_updated_by UUID
)
RETURNS BOOLEAN AS $$
DECLARE
    old_status VARCHAR;
BEGIN
    -- Get current status
    SELECT status INTO old_status
    FROM documents
    WHERE id = p_document_id;
    
    -- Update document status
    UPDATE documents
    SET 
        status = p_new_status,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_document_id;
    
    -- Log the status change
    INSERT INTO audit_trail (
        document_id,
        user_id,
        action,
        details
    ) VALUES (
        p_document_id,
        p_updated_by,
        'status_changed',
        jsonb_build_object(
            'old_status', old_status,
            'new_status', p_new_status,
            'changed_at', CURRENT_TIMESTAMP
        )
    );
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- SIGNATURE WORKFLOW FUNCTIONS
-- ============================================================================

-- Function to get signature workflow status
CREATE OR REPLACE FUNCTION get_signature_workflow_status(p_document_id UUID)
RETURNS TABLE(
    recipient_email VARCHAR,
    recipient_name VARCHAR,
    status VARCHAR,
    signed_at TIMESTAMP,
    signature_type VARCHAR,
    compliance_verified BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.email as recipient_email,
        r.full_name as recipient_name,
        r.status,
        s.signed_at,
        s.signature_type,
        s.compliance_verified
    FROM recipients r
    LEFT JOIN signatures s ON s.recipient_id = r.id
    WHERE r.document_id = p_document_id
    ORDER BY r.signing_order, r.created_at;
END;
$$ LANGUAGE plpgsql;

-- Function to complete signature workflow
CREATE OR REPLACE FUNCTION complete_signature_workflow(
    p_document_id UUID,
    p_recipient_id UUID,
    p_signature_data TEXT,
    p_signature_type VARCHAR,
    p_ip_address INET,
    p_user_agent TEXT
)
RETURNS UUID AS $$
DECLARE
    signature_id UUID;
    recipient_record RECORD;
BEGIN
    -- Get recipient details
    SELECT * INTO recipient_record
    FROM recipients
    WHERE id = p_recipient_id AND document_id = p_document_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Recipient not found for document';
    END IF;
    
    -- Create signature record
    INSERT INTO signatures (
        document_id,
        recipient_id,
        signature_type,
        signature_data,
        ip_address,
        user_agent,
        timestamp_token,
        signed_at
    ) VALUES (
        p_document_id,
        p_recipient_id,
        p_signature_type,
        p_signature_data,
        p_ip_address,
        p_user_agent,
        encode(gen_random_bytes(32), 'hex'),
        CURRENT_TIMESTAMP
    ) RETURNING id INTO signature_id;
    
    -- Update recipient status
    UPDATE recipients
    SET 
        status = 'signed',
        signed_at = CURRENT_TIMESTAMP
    WHERE id = p_recipient_id;
    
    -- Log signature activity
    PERFORM log_user_activity(
        recipient_record.document_id,
        'signature_completed',
        jsonb_build_object(
            'signature_id', signature_id,
            'document_id', p_document_id,
            'recipient_id', p_recipient_id,
            'signature_type', p_signature_type
        )
    );
    
    RETURN signature_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Trigger for document activity logging
DROP TRIGGER IF EXISTS on_document_change ON documents;
CREATE TRIGGER on_document_change
    AFTER INSERT OR UPDATE ON documents
    FOR EACH ROW
    EXECUTE FUNCTION trigger_log_document_activity();

-- Trigger for signature activity logging
DROP TRIGGER IF EXISTS on_signature_change ON signatures;
CREATE TRIGGER on_signature_change
    AFTER INSERT ON signatures
    FOR EACH ROW
    EXECUTE FUNCTION trigger_log_signature_activity();

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON FUNCTION get_document_audit_trail(UUID) IS 'Returns complete audit trail for a document';
COMMENT ON FUNCTION get_document_processing_summary(UUID) IS 'Returns processing status summary for a document';
COMMENT ON FUNCTION update_document_processing_status(UUID, VARCHAR, VARCHAR, INTEGER, JSONB, TEXT) IS 'Updates document processing status with metadata';
COMMENT ON FUNCTION validate_signature_data(TEXT, VARCHAR) IS 'Validates signature data based on signature type';
COMMENT ON FUNCTION check_signature_compliance(UUID) IS 'Checks signature compliance and returns score';
COMMENT ON FUNCTION get_document_workflow_status(UUID) IS 'Returns workflow status for a document';
COMMENT ON FUNCTION update_document_status(UUID, VARCHAR, UUID) IS 'Updates document status and logs change';
COMMENT ON FUNCTION get_signature_workflow_status(UUID) IS 'Returns signature workflow status for all recipients';
COMMENT ON FUNCTION complete_signature_workflow(UUID, UUID, TEXT, VARCHAR, INET, TEXT) IS 'Completes signature workflow and updates status';
\n-- End of buffrsign-starter/sql/3-documents_signatures.sql --\n
-- ============================================================================
-- RAG Pipeline State Management
-- ============================================================================
-- This file contains RAG (Retrieval-Augmented Generation) pipeline state management
-- for the BuffrSign platform's AI document analysis capabilities
-- ============================================================================

-- ============================================================================
-- RAG PIPELINE STATE TABLES
-- ============================================================================

-- RAG pipeline state tracking
CREATE TABLE IF NOT EXISTS rag_pipeline_state (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    pipeline_type VARCHAR NOT NULL,
    current_stage VARCHAR NOT NULL,
    stage_progress INTEGER DEFAULT 0 CHECK (stage_progress >= 0 AND stage_progress <= 100),
    total_stages INTEGER NOT NULL,
    current_stage_index INTEGER DEFAULT 0,
    pipeline_config JSONB DEFAULT '{}',
    stage_results JSONB DEFAULT '{}',
    error_details JSONB DEFAULT '{}',
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    status VARCHAR DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled'))
);

-- RAG document chunks for vector search
CREATE TABLE IF NOT EXISTS rag_document_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,
    chunk_text TEXT NOT NULL,
    chunk_metadata JSONB DEFAULT '{}',
    embedding_vector VECTOR(1536), -- OpenAI embedding dimension
    chunk_hash VARCHAR NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- RAG knowledge base entries
CREATE TABLE IF NOT EXISTS rag_knowledge_base (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR NOT NULL,
    content TEXT NOT NULL,
    category VARCHAR,
    tags TEXT[],
    source_url VARCHAR,
    embedding_vector VECTOR(1536),
    metadata JSONB DEFAULT '{}',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- RAG query history for analytics
CREATE TABLE IF NOT EXISTS rag_query_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    document_id UUID REFERENCES documents(id),
    query_text TEXT NOT NULL,
    query_type VARCHAR NOT NULL,
    retrieved_chunks JSONB DEFAULT '[]',
    generated_response TEXT,
    confidence_score NUMERIC,
    processing_time_ms INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ============================================================================
-- RAG PIPELINE FUNCTIONS
-- ============================================================================

-- Function to create RAG pipeline
CREATE OR REPLACE FUNCTION create_rag_pipeline(
    p_document_id UUID,
    p_pipeline_type VARCHAR,
    p_total_stages INTEGER,
    p_pipeline_config JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    pipeline_id UUID;
BEGIN
    INSERT INTO rag_pipeline_state (
        document_id,
        pipeline_type,
        current_stage,
        total_stages,
        pipeline_config
    ) VALUES (
        p_document_id,
        p_pipeline_type,
        'initialization',
        p_total_stages,
        p_pipeline_config
    ) RETURNING id INTO pipeline_id;
    
    RETURN pipeline_id;
END;
$$ LANGUAGE plpgsql;

-- Function to update RAG pipeline stage
CREATE OR REPLACE FUNCTION update_rag_pipeline_stage(
    p_pipeline_id UUID,
    p_stage_name VARCHAR,
    p_stage_progress INTEGER,
    p_stage_results JSONB DEFAULT '{}',
    p_error_details JSONB DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE rag_pipeline_state
    SET 
        current_stage = p_stage_name,
        stage_progress = p_stage_progress,
        stage_results = COALESCE(p_stage_results, stage_results),
        error_details = COALESCE(p_error_details, error_details),
        updated_at = CURRENT_TIMESTAMP,
        status = CASE 
            WHEN p_error_details IS NOT NULL THEN 'failed'
            WHEN p_stage_progress = 100 AND current_stage_index + 1 >= total_stages THEN 'completed'
            ELSE 'processing'
        END,
        completed_at = CASE 
            WHEN p_stage_progress = 100 AND current_stage_index + 1 >= total_stages THEN CURRENT_TIMESTAMP
            ELSE completed_at
        END
    WHERE id = p_pipeline_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to get RAG pipeline status
CREATE OR REPLACE FUNCTION get_rag_pipeline_status(p_pipeline_id UUID)
RETURNS TABLE(
    pipeline_id UUID,
    document_id UUID,
    pipeline_type VARCHAR,
    current_stage VARCHAR,
    stage_progress INTEGER,
    total_stages INTEGER,
    current_stage_index INTEGER,
    status VARCHAR,
    started_at TIMESTAMP,
    updated_at TIMESTAMP,
    completed_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rps.id,
        rps.document_id,
        rps.pipeline_type,
        rps.current_stage,
        rps.stage_progress,
        rps.total_stages,
        rps.current_stage_index,
        rps.status,
        rps.started_at,
        rps.updated_at,
        rps.completed_at
    FROM rag_pipeline_state rps
    WHERE rps.id = p_pipeline_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- DOCUMENT CHUNKING FUNCTIONS
-- ============================================================================

-- Function to create document chunks
CREATE OR REPLACE FUNCTION create_document_chunks(
    p_document_id UUID,
    p_chunks_data JSONB
)
RETURNS INTEGER AS $$
DECLARE
    chunk_record JSONB;
    chunk_count INTEGER := 0;
BEGIN
    -- Process each chunk in the data
    FOR chunk_record IN SELECT * FROM jsonb_array_elements(p_chunks_data)
    LOOP
        INSERT INTO rag_document_chunks (
            document_id,
            chunk_index,
            chunk_text,
            chunk_metadata,
            chunk_hash
        ) VALUES (
            p_document_id,
            (chunk_record->>'index')::INTEGER,
            chunk_record->>'text',
            COALESCE(chunk_record->'metadata', '{}'::JSONB),
            encode(sha256((chunk_record->>'text')::BYTEA), 'hex')
        );
        
        chunk_count := chunk_count + 1;
    END LOOP;
    
    RETURN chunk_count;
END;
$$ LANGUAGE plpgsql;

-- Function to get document chunks
CREATE OR REPLACE FUNCTION get_document_chunks(
    p_document_id UUID,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE(
    chunk_id UUID,
    chunk_index INTEGER,
    chunk_text TEXT,
    chunk_metadata JSONB,
    chunk_hash VARCHAR,
    created_at TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rdc.id,
        rdc.chunk_index,
        rdc.chunk_text,
        rdc.chunk_metadata,
        rdc.chunk_hash,
        rdc.created_at
    FROM rag_document_chunks rdc
    WHERE rdc.document_id = p_document_id
    ORDER BY rdc.chunk_index
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- KNOWLEDGE BASE FUNCTIONS
-- ============================================================================

-- Function to add knowledge base entry
CREATE OR REPLACE FUNCTION add_knowledge_base_entry(
    p_title VARCHAR,
    p_content TEXT,
    p_category VARCHAR DEFAULT NULL,
    p_tags TEXT[] DEFAULT NULL,
    p_source_url VARCHAR DEFAULT NULL,
    p_metadata JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    entry_id UUID;
BEGIN
    INSERT INTO rag_knowledge_base (
        title,
        content,
        category,
        tags,
        source_url,
        metadata
    ) VALUES (
        p_title,
        p_content,
        p_category,
        p_tags,
        p_source_url,
        p_metadata
    ) RETURNING id INTO entry_id;
    
    RETURN entry_id;
END;
$$ LANGUAGE plpgsql;

-- Function to search knowledge base
CREATE OR REPLACE FUNCTION search_knowledge_base(
    p_query_text TEXT,
    p_category VARCHAR DEFAULT NULL,
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE(
    entry_id UUID,
    title VARCHAR,
    content TEXT,
    category VARCHAR,
    tags TEXT[],
    source_url VARCHAR,
    relevance_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rkb.id,
        rkb.title,
        rkb.content,
        rkb.category,
        rkb.tags,
        rkb.source_url,
        -- Simple text similarity for now (in production, use vector similarity)
        similarity(rkb.content, p_query_text) as relevance_score
    FROM rag_knowledge_base rkb
    WHERE rkb.is_active = TRUE
    AND (p_category IS NULL OR rkb.category = p_category)
    AND (rkb.content ILIKE '%' || p_query_text || '%' OR rkb.title ILIKE '%' || p_query_text || '%')
    ORDER BY relevance_score DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- QUERY PROCESSING FUNCTIONS
-- ============================================================================

-- Function to log RAG query
CREATE OR REPLACE FUNCTION log_rag_query(
    p_user_id UUID,
    p_document_id UUID,
    p_query_text TEXT,
    p_query_type VARCHAR,
    p_retrieved_chunks JSONB,
    p_generated_response TEXT,
    p_confidence_score NUMERIC,
    p_processing_time_ms INTEGER
)
RETURNS UUID AS $$
DECLARE
    query_id UUID;
BEGIN
    INSERT INTO rag_query_history (
        user_id,
        document_id,
        query_text,
        query_type,
        retrieved_chunks,
        generated_response,
        confidence_score,
        processing_time_ms
    ) VALUES (
        p_user_id,
        p_document_id,
        p_query_text,
        p_query_type,
        p_retrieved_chunks,
        p_generated_response,
        p_confidence_score,
        p_processing_time_ms
    ) RETURNING id INTO query_id;
    
    RETURN query_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get RAG query analytics
CREATE OR REPLACE FUNCTION get_rag_query_analytics(
    p_user_id UUID DEFAULT NULL,
    p_days_back INTEGER DEFAULT 30
)
RETURNS TABLE(
    total_queries BIGINT,
    unique_users BIGINT,
    avg_confidence_score NUMERIC,
    avg_processing_time_ms NUMERIC,
    most_common_query_type VARCHAR,
    most_active_user UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_queries,
        COUNT(DISTINCT rqh.user_id) as unique_users,
        AVG(rqh.confidence_score) as avg_confidence_score,
        AVG(rqh.processing_time_ms) as avg_processing_time_ms,
        (SELECT query_type FROM rag_query_history 
         WHERE (p_user_id IS NULL OR user_id = p_user_id)
         AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_back
         GROUP BY query_type 
         ORDER BY COUNT(*) DESC 
         LIMIT 1) as most_common_query_type,
        (SELECT user_id FROM rag_query_history 
         WHERE (p_user_id IS NULL OR user_id = p_user_id)
         AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_back
         GROUP BY user_id 
         ORDER BY COUNT(*) DESC 
         LIMIT 1) as most_active_user
    FROM rag_query_history rqh
    WHERE (p_user_id IS NULL OR rqh.user_id = p_user_id)
    AND rqh.created_at >= CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_back;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- VECTOR SEARCH FUNCTIONS (requires pgvector extension)
-- ============================================================================

-- Function to update document chunk embeddings
CREATE OR REPLACE FUNCTION update_chunk_embeddings(
    p_chunk_id UUID,
    p_embedding_vector VECTOR(1536)
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE rag_document_chunks
    SET 
        embedding_vector = p_embedding_vector,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_chunk_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function to find similar chunks
CREATE OR REPLACE FUNCTION find_similar_chunks(
    p_query_embedding VECTOR(1536),
    p_document_id UUID DEFAULT NULL,
    p_limit INTEGER DEFAULT 10,
    p_similarity_threshold NUMERIC DEFAULT 0.7
)
RETURNS TABLE(
    chunk_id UUID,
    document_id UUID,
    chunk_text TEXT,
    similarity_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rdc.id,
        rdc.document_id,
        rdc.chunk_text,
        1 - (rdc.embedding_vector <=> p_query_embedding) as similarity_score
    FROM rag_document_chunks rdc
    WHERE (p_document_id IS NULL OR rdc.document_id = p_document_id)
    AND rdc.embedding_vector IS NOT NULL
    AND 1 - (rdc.embedding_vector <=> p_query_embedding) > p_similarity_threshold
    ORDER BY rdc.embedding_vector <=> p_query_embedding
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PIPELINE CLEANUP FUNCTIONS
-- ============================================================================

-- Function to cleanup completed pipelines
CREATE OR REPLACE FUNCTION cleanup_completed_pipelines(
    p_days_old INTEGER DEFAULT 30
)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM rag_pipeline_state
    WHERE status = 'completed'
    AND completed_at < CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_old;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup old query history
CREATE OR REPLACE FUNCTION cleanup_old_query_history(
    p_days_old INTEGER DEFAULT 90
)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM rag_query_history
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 day' * p_days_old;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- INDEXES FOR PERFORMANCE
-- ============================================================================

-- Indexes for RAG pipeline state
CREATE INDEX IF NOT EXISTS idx_rag_pipeline_state_document_id ON rag_pipeline_state(document_id);
CREATE INDEX IF NOT EXISTS idx_rag_pipeline_state_status ON rag_pipeline_state(status);
CREATE INDEX IF NOT EXISTS idx_rag_pipeline_state_created_at ON rag_pipeline_state(created_at);

-- Indexes for document chunks
CREATE INDEX IF NOT EXISTS idx_rag_document_chunks_document_id ON rag_document_chunks(document_id);
CREATE INDEX IF NOT EXISTS idx_rag_document_chunks_chunk_index ON rag_document_chunks(document_id, chunk_index);

-- Indexes for knowledge base
CREATE INDEX IF NOT EXISTS idx_rag_knowledge_base_category ON rag_knowledge_base(category);
CREATE INDEX IF NOT EXISTS idx_rag_knowledge_base_is_active ON rag_knowledge_base(is_active);

-- Indexes for query history
CREATE INDEX IF NOT EXISTS idx_rag_query_history_user_id ON rag_query_history(user_id);
CREATE INDEX IF NOT EXISTS idx_rag_query_history_document_id ON rag_query_history(document_id);
CREATE INDEX IF NOT EXISTS idx_rag_query_history_created_at ON rag_query_history(created_at);

-- ============================================================================
-- COMMENTS
-- ============================================================================

COMMENT ON TABLE rag_pipeline_state IS 'Tracks RAG pipeline execution state and progress';
COMMENT ON TABLE rag_document_chunks IS 'Stores document chunks with embeddings for vector search';
COMMENT ON TABLE rag_knowledge_base IS 'Knowledge base entries for RAG context';
COMMENT ON TABLE rag_query_history IS 'Logs RAG queries for analytics and improvement';

COMMENT ON FUNCTION create_rag_pipeline(UUID, VARCHAR, INTEGER, JSONB) IS 'Creates new RAG pipeline for document processing';
COMMENT ON FUNCTION update_rag_pipeline_stage(UUID, VARCHAR, INTEGER, JSONB, JSONB) IS 'Updates RAG pipeline stage progress';
COMMENT ON FUNCTION get_rag_pipeline_status(UUID) IS 'Gets RAG pipeline status and progress';
COMMENT ON FUNCTION create_document_chunks(UUID, JSONB) IS 'Creates document chunks from processed text';
COMMENT ON FUNCTION get_document_chunks(UUID, INTEGER) IS 'Retrieves document chunks for processing';
COMMENT ON FUNCTION add_knowledge_base_entry(VARCHAR, TEXT, VARCHAR, TEXT[], VARCHAR, JSONB) IS 'Adds entry to knowledge base';
COMMENT ON FUNCTION search_knowledge_base(TEXT, VARCHAR, INTEGER) IS 'Searches knowledge base with text similarity';
COMMENT ON FUNCTION log_rag_query(UUID, UUID, TEXT, VARCHAR, JSONB, TEXT, NUMERIC, INTEGER) IS 'Logs RAG query for analytics';
COMMENT ON FUNCTION get_rag_query_analytics(UUID, INTEGER) IS 'Gets RAG query analytics and statistics';
COMMENT ON FUNCTION update_chunk_embeddings(UUID, VECTOR) IS 'Updates document chunk embeddings';
COMMENT ON FUNCTION find_similar_chunks(VECTOR, UUID, INTEGER, NUMERIC) IS 'Finds similar chunks using vector similarity';
COMMENT ON FUNCTION cleanup_completed_pipelines(INTEGER) IS 'Cleans up completed RAG pipelines';
COMMENT ON FUNCTION cleanup_old_query_history(INTEGER) IS 'Cleans up old query history';
\n-- End of buffrsign-starter/sql/9-rag_pipeline_state.sql --\n
-- =====================================================
-- BuffrSign SendGrid Configuration and Services
-- =====================================================
-- Description: SendGrid API configuration, templates, and email services
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrSign Development Team
-- =====================================================

-- =====================================================
-- SENDGRID CONFIGURATION TABLES
-- =====================================================

-- SendGrid API Configuration
CREATE TABLE IF NOT EXISTS public.sendgrid_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    api_key_encrypted TEXT NOT NULL,
    api_key_hash TEXT NOT NULL, -- For verification without decryption
    from_email TEXT NOT NULL,
    from_name TEXT NOT NULL,
    reply_to_email TEXT,
    reply_to_name TEXT,
    webhook_public_key TEXT, -- For webhook signature verification
    webhook_url TEXT,
    is_active BOOLEAN DEFAULT true,
    environment TEXT DEFAULT 'production' CHECK (environment IN ('sandbox', 'production')),
    rate_limit_per_minute INTEGER DEFAULT 100,
    rate_limit_per_hour INTEGER DEFAULT 1000,
    rate_limit_per_day INTEGER DEFAULT 10000,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Template Management
CREATE TABLE IF NOT EXISTS public.sendgrid_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL UNIQUE, -- SendGrid template ID
    template_name TEXT NOT NULL,
    template_type TEXT NOT NULL CHECK (template_type IN ('transactional', 'marketing', 'automated')),
    category TEXT,
    subject TEXT,
    content_html TEXT,
    content_text TEXT,
    variables JSONB DEFAULT '[]'::jsonb,
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    last_used_at TIMESTAMP WITH TIME ZONE,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Sender Authentication
CREATE TABLE IF NOT EXISTS public.sendgrid_senders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    address TEXT,
    city TEXT,
    state TEXT,
    zip TEXT,
    country TEXT,
    is_verified BOOLEAN DEFAULT false,
    verification_status TEXT DEFAULT 'pending',
    verification_date TIMESTAMP WITH TIME ZONE,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Domain Authentication
CREATE TABLE IF NOT EXISTS public.sendgrid_domains (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL UNIQUE,
    is_verified BOOLEAN DEFAULT false,
    verification_status TEXT DEFAULT 'pending',
    verification_date TIMESTAMP WITH TIME ZONE,
    dns_records JSONB DEFAULT '[]'::jsonb,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid IP Pools
CREATE TABLE IF NOT EXISTS public.sendgrid_ip_pools (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pool_name TEXT NOT NULL UNIQUE,
    pool_id TEXT NOT NULL UNIQUE, -- SendGrid pool ID
    is_active BOOLEAN DEFAULT true,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid IP Addresses
CREATE TABLE IF NOT EXISTS public.sendgrid_ips (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    pool_id UUID REFERENCES public.sendgrid_ip_pools(id),
    is_active BOOLEAN DEFAULT true,
    is_warmup BOOLEAN DEFAULT false,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    last_used_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Settings and Preferences
CREATE TABLE IF NOT EXISTS public.sendgrid_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    setting_key TEXT NOT NULL UNIQUE,
    setting_value JSONB NOT NULL,
    setting_type TEXT NOT NULL CHECK (setting_type IN ('string', 'number', 'boolean', 'object', 'array')),
    category TEXT NOT NULL,
    description TEXT,
    is_encrypted BOOLEAN DEFAULT false,
    is_sensitive BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Email Analytics
CREATE TABLE IF NOT EXISTS public.sendgrid_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    event_type VARCHAR(50) NOT NULL CHECK (event_type IN ('delivered', 'opened', 'clicked', 'bounced', 'dropped', 'spam_report', 'unsubscribe')),
    recipient_email TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    url TEXT, -- For click events
    reason TEXT, -- For bounce/drop events
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- =====================================================
-- SENDGRID FUNCTIONS
-- =====================================================

-- Function to get SendGrid configuration
CREATE OR REPLACE FUNCTION public.get_sendgrid_config()
RETURNS TABLE (
    api_key_encrypted TEXT,
    from_email TEXT,
    from_name TEXT,
    reply_to_email TEXT,
    reply_to_name TEXT,
    webhook_public_key TEXT,
    webhook_url TEXT,
    environment TEXT,
    rate_limit_per_minute INTEGER,
    rate_limit_per_hour INTEGER,
    rate_limit_per_day INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sc.api_key_encrypted,
        sc.from_email,
        sc.from_name,
        sc.reply_to_email,
        sc.reply_to_name,
        sc.webhook_public_key,
        sc.webhook_url,
        sc.environment,
        sc.rate_limit_per_minute,
        sc.rate_limit_per_hour,
        sc.rate_limit_per_day
    FROM public.sendgrid_config sc
    WHERE sc.is_active = true
    ORDER BY sc.created_at DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Function to get SendGrid template by name
CREATE OR REPLACE FUNCTION public.get_sendgrid_template(template_name TEXT)
RETURNS TABLE (
    template_id TEXT,
    subject TEXT,
    content_html TEXT,
    content_text TEXT,
    variables JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        st.template_id,
        st.subject,
        st.content_html,
        st.content_text,
        st.variables
    FROM public.sendgrid_templates st
    WHERE st.template_name = get_sendgrid_template.template_name
      AND st.is_active = true
      AND st.is_verified = true;
END;
$$ LANGUAGE plpgsql;

-- Function to update template usage
CREATE OR REPLACE FUNCTION public.update_template_usage(template_id TEXT)
RETURNS VOID AS $$
BEGIN
    UPDATE public.sendgrid_templates 
    SET 
        usage_count = usage_count + 1,
        last_used_at = CURRENT_TIMESTAMP
    WHERE sendgrid_templates.template_id = update_template_usage.template_id;
END;
$$ LANGUAGE plpgsql;

-- Function to log email analytics
CREATE OR REPLACE FUNCTION public.log_email_analytics(
    p_email_id TEXT,
    p_event_type VARCHAR(50),
    p_recipient_email TEXT,
    p_timestamp TIMESTAMP WITH TIME ZONE,
    p_user_agent TEXT DEFAULT NULL,
    p_ip_address INET DEFAULT NULL,
    p_url TEXT DEFAULT NULL,
    p_reason TEXT DEFAULT NULL,
    p_metadata JSONB DEFAULT '{}'
)
RETURNS UUID AS $$
DECLARE
    analytics_id UUID;
BEGIN
    INSERT INTO public.sendgrid_analytics (
        email_id, event_type, recipient_email, timestamp,
        user_agent, ip_address, url, reason, metadata
    ) VALUES (
        p_email_id, p_event_type, p_recipient_email, p_timestamp,
        p_user_agent, p_ip_address, p_url, p_reason, p_metadata
    ) RETURNING id INTO analytics_id;
    
    RETURN analytics_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get email analytics
CREATE OR REPLACE FUNCTION public.get_email_analytics(
    p_email_id TEXT DEFAULT NULL,
    p_recipient_email TEXT DEFAULT NULL,
    p_event_type VARCHAR(50) DEFAULT NULL,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    id UUID,
    email_id TEXT,
    event_type VARCHAR(50),
    recipient_email TEXT,
    timestamp TIMESTAMP WITH TIME ZONE,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    reason TEXT,
    metadata JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sa.id,
        sa.email_id,
        sa.event_type,
        sa.recipient_email,
        sa.timestamp,
        sa.user_agent,
        sa.ip_address,
        sa.url,
        sa.reason,
        sa.metadata
    FROM public.sendgrid_analytics sa
    WHERE (p_email_id IS NULL OR sa.email_id = p_email_id)
      AND (p_recipient_email IS NULL OR sa.recipient_email = p_recipient_email)
      AND (p_event_type IS NULL OR sa.event_type = p_event_type)
      AND (p_start_date IS NULL OR sa.timestamp >= p_start_date)
      AND (p_end_date IS NULL OR sa.timestamp <= p_end_date)
    ORDER BY sa.timestamp DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to get email delivery statistics
CREATE OR REPLACE FUNCTION public.get_email_delivery_stats(
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS TABLE (
    total_emails BIGINT,
    delivered_count BIGINT,
    opened_count BIGINT,
    clicked_count BIGINT,
    bounced_count BIGINT,
    dropped_count BIGINT,
    spam_reports BIGINT,
    unsubscribes BIGINT,
    delivery_rate NUMERIC(5,2),
    open_rate NUMERIC(5,2),
    click_rate NUMERIC(5,2)
) AS $$
BEGIN
    RETURN QUERY
    WITH email_stats AS (
        SELECT 
            COUNT(*) as total_emails,
            COUNT(CASE WHEN event_type = 'delivered' THEN 1 END) as delivered_count,
            COUNT(CASE WHEN event_type = 'opened' THEN 1 END) as opened_count,
            COUNT(CASE WHEN event_type = 'clicked' THEN 1 END) as clicked_count,
            COUNT(CASE WHEN event_type = 'bounced' THEN 1 END) as bounced_count,
            COUNT(CASE WHEN event_type = 'dropped' THEN 1 END) as dropped_count,
            COUNT(CASE WHEN event_type = 'spam_report' THEN 1 END) as spam_reports,
            COUNT(CASE WHEN event_type = 'unsubscribe' THEN 1 END) as unsubscribes
        FROM public.sendgrid_analytics sa
        WHERE (p_start_date IS NULL OR sa.timestamp >= p_start_date)
          AND (p_end_date IS NULL OR sa.timestamp <= p_end_date)
    )
    SELECT 
        es.total_emails,
        es.delivered_count,
        es.opened_count,
        es.clicked_count,
        es.bounced_count,
        es.dropped_count,
        es.spam_reports,
        es.unsubscribes,
        CASE 
            WHEN es.total_emails > 0 THEN ROUND((es.delivered_count::NUMERIC / es.total_emails::NUMERIC) * 100, 2)
            ELSE 0
        END as delivery_rate,
        CASE 
            WHEN es.delivered_count > 0 THEN ROUND((es.opened_count::NUMERIC / es.delivered_count::NUMERIC) * 100, 2)
            ELSE 0
        END as open_rate,
        CASE 
            WHEN es.delivered_count > 0 THEN ROUND((es.clicked_count::NUMERIC / es.delivered_count::NUMERIC) * 100, 2)
            ELSE 0
        END as click_rate
    FROM email_stats es;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- SENDGRID TRIGGERS
-- =====================================================

-- Trigger function for updated_at
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
CREATE TRIGGER update_sendgrid_config_updated_at 
    BEFORE UPDATE ON public.sendgrid_config 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_templates_updated_at 
    BEFORE UPDATE ON public.sendgrid_templates 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_senders_updated_at 
    BEFORE UPDATE ON public.sendgrid_senders 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_domains_updated_at 
    BEFORE UPDATE ON public.sendgrid_domains 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_ip_pools_updated_at 
    BEFORE UPDATE ON public.sendgrid_ip_pools 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_ips_updated_at 
    BEFORE UPDATE ON public.sendgrid_ips 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_sendgrid_settings_updated_at 
    BEFORE UPDATE ON public.sendgrid_settings 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- =====================================================
-- DEFAULT SENDGRID SETTINGS
-- =====================================================

-- Insert default SendGrid settings for BuffrSign
INSERT INTO public.sendgrid_settings (setting_key, setting_value, setting_type, category, description) VALUES
('sendgrid_api_key', '{"encrypted": true, "value": ""}', 'object', 'api', 'SendGrid API Key for authentication'),
('sendgrid_webhook_public_key', '{"encrypted": true, "value": ""}', 'object', 'webhook', 'SendGrid webhook public key for signature verification'),
('sendgrid_from_email', '{"value": "noreply@sign.buffr.ai"}', 'object', 'sender', 'Default from email address'),
('sendgrid_from_name', '{"value": "BuffrSign"}', 'object', 'sender', 'Default from name'),
('sendgrid_reply_to', '{"value": "support@sign.buffr.ai"}', 'object', 'sender', 'Default reply-to email address'),
('sendgrid_rate_limit_per_minute', '{"value": 100}', 'object', 'rate_limits', 'Rate limit per minute'),
('sendgrid_rate_limit_per_hour', '{"value": 1000}', 'object', 'rate_limits', 'Rate limit per hour'),
('sendgrid_rate_limit_per_day', '{"value": 10000}', 'object', 'rate_limits', 'Rate limit per day'),
('sendgrid_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable email tracking'),
('sendgrid_click_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable click tracking'),
('sendgrid_open_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable open tracking'),
('sendgrid_subscription_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable subscription tracking'),
('sendgrid_sandbox_mode', '{"value": false}', 'object', 'environment', 'Enable sandbox mode for testing')
ON CONFLICT (setting_key) DO NOTHING;

-- Insert default email templates for BuffrSign
INSERT INTO public.sendgrid_templates (template_id, template_name, template_type, category, subject, content_html, content_text, variables, is_active, is_verified) VALUES
('signup_confirmation', 'signup_confirmation', 'transactional', 'authentication', 'Welcome to BuffrSign - Confirm Your Account', 
'<h1>Welcome to BuffrSign!</h1><p>Please confirm your email address by clicking the link below:</p><p><a href="{{confirmation_url}}">Confirm Email</a></p>',
'Welcome to BuffrSign! Please confirm your email address by visiting: {{confirmation_url}}',
'["confirmation_url", "user_name"]', true, true),
('password_reset', 'password_reset', 'transactional', 'authentication', 'Reset Your BuffrSign Password',
'<h1>Password Reset Request</h1><p>Click the link below to reset your password:</p><p><a href="{{reset_url}}">Reset Password</a></p>',
'Password Reset Request. Visit this link to reset your password: {{reset_url}}',
'["reset_url", "user_name"]', true, true),
('document_signed', 'document_signed', 'transactional', 'notifications', 'Document Signed - {{document_title}}',
'<h1>Document Signed</h1><p>Your document "{{document_title}}" has been signed by {{signer_name}}.</p>',
'Document "{{document_title}}" has been signed by {{signer_name}}.',
'["document_title", "signer_name", "signature_date"]', true, true),
('signature_request', 'signature_request', 'transactional', 'notifications', 'Signature Request - {{document_title}}',
'<h1>Signature Request</h1><p>You have been requested to sign the document "{{document_title}}".</p><p><a href="{{signature_url}}">Sign Document</a></p>',
'You have been requested to sign the document "{{document_title}}". Visit: {{signature_url}}',
'["document_title", "requester_name", "signature_url", "due_date"]', true, true)
ON CONFLICT (template_id) DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR SENDGRID TABLES
-- =====================================================

-- Enable RLS on SendGrid tables
ALTER TABLE public.sendgrid_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_senders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_domains ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_ip_pools ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_ips ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sendgrid_analytics ENABLE ROW LEVEL SECURITY;

-- SendGrid config policies
CREATE POLICY "Admin users can view SendGrid config" ON public.sendgrid_config
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "Admin users can modify SendGrid config" ON public.sendgrid_config
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- SendGrid templates policies
CREATE POLICY "All users can view SendGrid templates" ON public.sendgrid_templates
    FOR SELECT USING (is_active = true);

CREATE POLICY "Admin users can modify SendGrid templates" ON public.sendgrid_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

-- SendGrid analytics policies
CREATE POLICY "Users can view own email analytics" ON public.sendgrid_analytics
    FOR SELECT USING (
        recipient_email = (
            SELECT email FROM public.profiles WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can view all email analytics" ON public.sendgrid_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles 
            WHERE id = auth.uid()::text AND role IN ('admin', 'super_admin')
        )
    );

CREATE POLICY "System can insert email analytics" ON public.sendgrid_analytics
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- INDEXES FOR SENDGRID TABLES
-- =====================================================

-- SendGrid config indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_config_active ON public.sendgrid_config(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_config_environment ON public.sendgrid_config(environment);

-- SendGrid templates indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_templates_active ON public.sendgrid_templates(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_templates_type ON public.sendgrid_templates(template_type);
CREATE INDEX IF NOT EXISTS idx_sendgrid_templates_category ON public.sendgrid_templates(category);

-- SendGrid senders indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_senders_verified ON public.sendgrid_senders(is_verified);
CREATE INDEX IF NOT EXISTS idx_sendgrid_senders_default ON public.sendgrid_senders(is_default);

-- SendGrid domains indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_domains_verified ON public.sendgrid_domains(is_verified);
CREATE INDEX IF NOT EXISTS idx_sendgrid_domains_default ON public.sendgrid_domains(is_default);

-- SendGrid IPs indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_ips_active ON public.sendgrid_ips(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_ips_pool ON public.sendgrid_ips(pool_id);

-- SendGrid settings indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_settings_category ON public.sendgrid_settings(category);
CREATE INDEX IF NOT EXISTS idx_sendgrid_settings_encrypted ON public.sendgrid_settings(is_encrypted);

-- SendGrid analytics indexes
CREATE INDEX IF NOT EXISTS idx_sendgrid_analytics_email_id ON public.sendgrid_analytics(email_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_analytics_recipient ON public.sendgrid_analytics(recipient_email);
CREATE INDEX IF NOT EXISTS idx_sendgrid_analytics_event_type ON public.sendgrid_analytics(event_type);
CREATE INDEX IF NOT EXISTS idx_sendgrid_analytics_timestamp ON public.sendgrid_analytics(timestamp);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.sendgrid_config IS 'SendGrid API configuration and settings';
COMMENT ON TABLE public.sendgrid_templates IS 'SendGrid email templates management';
COMMENT ON TABLE public.sendgrid_senders IS 'SendGrid sender authentication';
COMMENT ON TABLE public.sendgrid_domains IS 'SendGrid domain authentication';
COMMENT ON TABLE public.sendgrid_ip_pools IS 'SendGrid IP pools configuration';
COMMENT ON TABLE public.sendgrid_ips IS 'SendGrid IP addresses and reputation';
COMMENT ON TABLE public.sendgrid_settings IS 'SendGrid settings and preferences';
COMMENT ON TABLE public.sendgrid_analytics IS 'SendGrid email analytics and tracking';
COMMENT ON FUNCTION public.get_sendgrid_config() IS 'Gets active SendGrid configuration';
COMMENT ON FUNCTION public.get_sendgrid_template(TEXT) IS 'Gets SendGrid template by name';
COMMENT ON FUNCTION public.update_template_usage(TEXT) IS 'Updates template usage statistics';
COMMENT ON FUNCTION public.log_email_analytics(TEXT, VARCHAR, TEXT, TIMESTAMP WITH TIME ZONE, TEXT, INET, TEXT, TEXT, JSONB) IS 'Logs email analytics events';
COMMENT ON FUNCTION public.get_email_analytics(TEXT, TEXT, VARCHAR, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE, INTEGER) IS 'Gets email analytics with filtering';
COMMENT ON FUNCTION public.get_email_delivery_stats(TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH TIME ZONE) IS 'Gets email delivery statistics and rates';
\n-- End of buffrsign-starter/sql/13-sendgrid_configuration.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrsign-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrsign-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrsign-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrsign-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrsign-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrsign-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrsign-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrsign-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrsign-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrsign-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrsign-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrsign-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrsign-starter/sql/08_unified_workflows.sql --\n
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS pg_trgm;

DROP TABLE IF EXISTS messages CASCADE;
DROP TABLE IF EXISTS sessions CASCADE;
DROP TABLE IF EXISTS chunks CASCADE;
DROP TABLE IF EXISTS documents CASCADE;
DROP INDEX IF EXISTS idx_chunks_embedding;
DROP INDEX IF EXISTS idx_chunks_document_id;
DROP INDEX IF EXISTS idx_documents_metadata;
DROP INDEX IF EXISTS idx_chunks_content_trgm;

CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    source TEXT NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_documents_metadata ON documents USING GIN (metadata);
CREATE INDEX idx_documents_created_at ON documents (created_at DESC);

CREATE TABLE chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    embedding vector(1536),
    chunk_index INTEGER NOT NULL,
    metadata JSONB DEFAULT '{}',
    token_count INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_chunks_embedding ON chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists = 1);
CREATE INDEX idx_chunks_document_id ON chunks (document_id);
CREATE INDEX idx_chunks_chunk_index ON chunks (document_id, chunk_index);
CREATE INDEX idx_chunks_content_trgm ON chunks USING GIN (content gin_trgm_ops);

CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_sessions_user_id ON sessions (user_id);
CREATE INDEX idx_sessions_expires_at ON sessions (expires_at);

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_session_id ON messages (session_id, created_at);

CREATE OR REPLACE FUNCTION match_chunks(
    query_embedding vector(1536),
    match_count INT DEFAULT 10
)
RETURNS TABLE (
    chunk_id UUID,
    document_id UUID,
    content TEXT,
    similarity FLOAT,
    metadata JSONB,
    document_title TEXT,
    document_source TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id AS chunk_id,
        c.document_id,
        c.content,
        1 - (c.embedding <=> query_embedding) AS similarity,
        c.metadata,
        d.title AS document_title,
        d.source AS document_source
    FROM chunks c
    JOIN documents d ON c.document_id = d.id
    WHERE c.embedding IS NOT NULL
    ORDER BY c.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION hybrid_search(
    query_embedding vector(1536),
    query_text TEXT,
    match_count INT DEFAULT 10,
    text_weight FLOAT DEFAULT 0.3
)
RETURNS TABLE (
    chunk_id UUID,
    document_id UUID,
    content TEXT,
    combined_score FLOAT,
    vector_similarity FLOAT,
    text_similarity FLOAT,
    metadata JSONB,
    document_title TEXT,
    document_source TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT 
            c.id AS chunk_id,
            c.document_id,
            c.content,
            1 - (c.embedding <=> query_embedding) AS vector_sim,
            c.metadata,
            d.title AS doc_title,
            d.source AS doc_source
        FROM chunks c
        JOIN documents d ON c.document_id = d.id
        WHERE c.embedding IS NOT NULL
    ),
    text_results AS (
        SELECT 
            c.id AS chunk_id,
            c.document_id,
            c.content,
            ts_rank_cd(to_tsvector('english', c.content), plainto_tsquery('english', query_text)) AS text_sim,
            c.metadata,
            d.title AS doc_title,
            d.source AS doc_source
        FROM chunks c
        JOIN documents d ON c.document_id = d.id
        WHERE to_tsvector('english', c.content) @@ plainto_tsquery('english', query_text)
    )
    SELECT 
        COALESCE(v.chunk_id, t.chunk_id) AS chunk_id,
        COALESCE(v.document_id, t.document_id) AS document_id,
        COALESCE(v.content, t.content) AS content,
        (COALESCE(v.vector_sim, 0) * (1 - text_weight) + COALESCE(t.text_sim, 0) * text_weight) AS combined_score,
        COALESCE(v.vector_sim, 0) AS vector_similarity,
        COALESCE(t.text_sim, 0) AS text_similarity,
        COALESCE(v.metadata, t.metadata) AS metadata,
        COALESCE(v.doc_title, t.doc_title) AS document_title,
        COALESCE(v.doc_source, t.doc_source) AS document_source
    FROM vector_results v
    FULL OUTER JOIN text_results t ON v.chunk_id = t.chunk_id
    ORDER BY combined_score DESC
    LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION get_document_chunks(doc_id UUID)
RETURNS TABLE (
    chunk_id UUID,
    content TEXT,
    chunk_index INTEGER,
    metadata JSONB
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        id AS chunk_id,
        chunks.content,
        chunks.chunk_index,
        chunks.metadata
    FROM chunks
    WHERE document_id = doc_id
    ORDER BY chunk_index;
END;
$$;

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_documents_updated_at BEFORE UPDATE ON documents
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_sessions_updated_at BEFORE UPDATE ON sessions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE VIEW document_summaries AS
SELECT 
    d.id,
    d.title,
    d.source,
    d.created_at,
    d.updated_at,
    d.metadata,
    COUNT(c.id) AS chunk_count,
    AVG(c.token_count) AS avg_tokens_per_chunk,
    SUM(c.token_count) AS total_tokens
FROM documents d
LEFT JOIN chunks c ON d.id = c.document_id
GROUP BY d.id, d.title, d.source, d.created_at, d.updated_at, d.metadata;\n-- End of buffrsign-starter/sql/hero_setup.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Admin Email Controls Migration for BuffrSign
-- Founder: George Nekwaya (george@buffr.ai +12065308433)

-- Create manual email requests table
CREATE TABLE IF NOT EXISTS manual_email_requests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    admin_id VARCHAR(255) NOT NULL,
    admin_name VARCHAR(255) NOT NULL,
    email_type VARCHAR(50) NOT NULL,
    recipients JSONB NOT NULL,
    subject TEXT NOT NULL,
    content JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ,
    priority VARCHAR(20) DEFAULT 'normal',
    reason TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    conflicts JSONB DEFAULT '[]',
    approver_id VARCHAR(255),
    approver_name VARCHAR(255),
    approved_at TIMESTAMPTZ,
    rejected_at TIMESTAMPTZ,
    rejection_reason TEXT,
    cancelled_at TIMESTAMPTZ,
    cancellation_reason TEXT,
    cancelled_by VARCHAR(255),
    sent_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create admin email activity log table
CREATE TABLE IF NOT EXISTS admin_email_activity (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    admin_id VARCHAR(255) NOT NULL,
    action VARCHAR(100) NOT NULL,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create email queue table (if not exists)
CREATE TABLE IF NOT EXISTS email_queue (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    email_type VARCHAR(50) NOT NULL,
    recipient_email VARCHAR(255) NOT NULL,
    subject TEXT NOT NULL,
    content JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ NOT NULL,
    priority INTEGER DEFAULT 3,
    status VARCHAR(20) DEFAULT 'queued',
    attempts INTEGER DEFAULT 0,
    last_attempt TIMESTAMPTZ,
    error_message TEXT,
    is_manual BOOLEAN DEFAULT FALSE,
    manual_request_id UUID REFERENCES manual_email_requests(id),
    admin_id VARCHAR(255),
    document_id UUID REFERENCES documents(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_status ON manual_email_requests(status);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_admin_id ON manual_email_requests(admin_id);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_created_at ON manual_email_requests(created_at);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_scheduled_for ON manual_email_requests(scheduled_for);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_email_type ON manual_email_requests(email_type);

CREATE INDEX IF NOT EXISTS idx_admin_email_activity_admin_id ON admin_email_activity(admin_id);
CREATE INDEX IF NOT EXISTS idx_admin_email_activity_created_at ON admin_email_activity(created_at);
CREATE INDEX IF NOT EXISTS idx_admin_email_activity_action ON admin_email_activity(action);

CREATE INDEX IF NOT EXISTS idx_email_queue_status ON email_queue(status);
CREATE INDEX IF NOT EXISTS idx_email_queue_scheduled_for ON email_queue(scheduled_for);
CREATE INDEX IF NOT EXISTS idx_email_queue_priority ON email_queue(priority);
CREATE INDEX IF NOT EXISTS idx_email_queue_is_manual ON email_queue(is_manual);
CREATE INDEX IF NOT EXISTS idx_email_queue_manual_request_id ON email_queue(manual_request_id);
CREATE INDEX IF NOT EXISTS idx_email_queue_document_id ON email_queue(document_id);

-- Create updated_at trigger function (if not exists)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_manual_email_requests_updated_at ON manual_email_requests;
CREATE TRIGGER update_manual_email_requests_updated_at
    BEFORE UPDATE ON manual_email_requests
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_email_queue_updated_at ON email_queue;
CREATE TRIGGER update_email_queue_updated_at
    BEFORE UPDATE ON email_queue
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create RLS policies
ALTER TABLE manual_email_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_email_activity ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_queue ENABLE ROW LEVEL SECURITY;

-- Manual email requests policies
CREATE POLICY "Admins can view all manual email requests" ON manual_email_requests
    FOR SELECT USING (true);

CREATE POLICY "Admins can insert manual email requests" ON manual_email_requests
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Admins can update manual email requests" ON manual_email_requests
    FOR UPDATE USING (true);

-- Admin email activity policies
CREATE POLICY "Admins can view all admin email activity" ON admin_email_activity
    FOR SELECT USING (true);

CREATE POLICY "System can insert admin email activity" ON admin_email_activity
    FOR INSERT WITH CHECK (true);

-- Email queue policies
CREATE POLICY "Admins can view all email queue items" ON email_queue
    FOR SELECT USING (true);

CREATE POLICY "System can insert email queue items" ON email_queue
    FOR INSERT WITH CHECK (true);

CREATE POLICY "System can update email queue items" ON email_queue
    FOR UPDATE USING (true);

-- Create function to check document-specific email conflicts
CREATE OR REPLACE FUNCTION check_document_email_conflicts(
    document_id UUID,
    email_type VARCHAR(50),
    recipient_emails TEXT[]
)
RETURNS TABLE (
    conflict_type VARCHAR(50),
    severity VARCHAR(20),
    message TEXT,
    recommendation TEXT,
    document_status VARCHAR(50)
) AS $$
BEGIN
    -- Check document status conflicts
    RETURN QUERY
    SELECT 
        'document_status'::VARCHAR(50) as conflict_type,
        CASE 
            WHEN d.status = 'completed' AND email_type = 'document_invitation' THEN 'high'::VARCHAR(20)
            WHEN d.status = 'draft' AND email_type = 'signature_reminder' THEN 'high'::VARCHAR(20)
            WHEN d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'critical'::VARCHAR(20)
            ELSE 'low'::VARCHAR(20)
        END as severity,
        ('Document status: ' || d.status || ' conflicts with email type: ' || email_type)::TEXT as message,
        CASE 
            WHEN d.status = 'completed' AND email_type = 'document_invitation' THEN 'Consider sending completion notification instead'::TEXT
            WHEN d.status = 'draft' AND email_type = 'signature_reminder' THEN 'Wait for document to be sent before sending reminders'::TEXT
            WHEN d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'Send document expired notification instead'::TEXT
            ELSE 'No specific recommendation'::TEXT
        END as recommendation,
        d.status as document_status
    FROM documents d
    WHERE d.id = document_id
    AND (
        (d.status = 'completed' AND email_type = 'document_invitation') OR
        (d.status = 'draft' AND email_type = 'signature_reminder') OR
        (d.status = 'expired' AND email_type IN ('document_invitation', 'signature_reminder'))
    );
END;
$$ LANGUAGE plpgsql;

-- Create function to check signature workflow conflicts
CREATE OR REPLACE FUNCTION check_signature_workflow_conflicts(
    recipient_emails TEXT[],
    email_type VARCHAR(50)
)
RETURNS TABLE (
    conflict_type VARCHAR(50),
    severity VARCHAR(20),
    message TEXT,
    recommendation TEXT,
    affected_email VARCHAR(255),
    document_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'signature_workflow'::VARCHAR(50) as conflict_type,
        CASE 
            WHEN ds.status = 'signed' AND email_type = 'signature_reminder' THEN 'medium'::VARCHAR(20)
            WHEN ds.status = 'declined' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'high'::VARCHAR(20)
            ELSE 'low'::VARCHAR(20)
        END as severity,
        ('Recipient ' || ds.signer_email || ' has ' || ds.status || ' the document')::TEXT as message,
        CASE 
            WHEN ds.status = 'signed' AND email_type = 'signature_reminder' THEN 'Remove signed recipients from reminder list'::TEXT
            WHEN ds.status = 'declined' AND email_type IN ('document_invitation', 'signature_reminder') THEN 'Do not send invitation or reminder to declined signers'::TEXT
            ELSE 'No specific recommendation'::TEXT
        END as recommendation,
        ds.signer_email as affected_email,
        ds.document_id
    FROM document_signatures ds
    WHERE ds.signer_email = ANY(recipient_emails)
    AND (
        (ds.status = 'signed' AND email_type = 'signature_reminder') OR
        (ds.status = 'declined' AND email_type IN ('document_invitation', 'signature_reminder'))
    );
END;
$$ LANGUAGE plpgsql;

-- Create function to process email queue
CREATE OR REPLACE FUNCTION process_email_queue(batch_size INTEGER DEFAULT 10)
RETURNS TABLE (
    id UUID,
    email_type VARCHAR(50),
    recipient_email VARCHAR(255),
    subject TEXT,
    content JSONB,
    priority INTEGER,
    attempts INTEGER,
    document_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        eq.id,
        eq.email_type,
        eq.recipient_email,
        eq.subject,
        eq.content,
        eq.priority,
        eq.attempts,
        eq.document_id
    FROM email_queue eq
    WHERE eq.status = 'queued'
    AND eq.scheduled_for <= NOW()
    AND eq.attempts < 3
    ORDER BY eq.priority ASC, eq.created_at ASC
    LIMIT batch_size;
END;
$$ LANGUAGE plpgsql;

-- Create function to update email queue item status
CREATE OR REPLACE FUNCTION update_email_queue_status(
    queue_id UUID,
    new_status VARCHAR(20),
    error_msg TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE email_queue 
    SET 
        status = new_status,
        attempts = attempts + 1,
        last_attempt = NOW(),
        error_message = error_msg,
        updated_at = NOW()
    WHERE id = queue_id;
END;
$$ LANGUAGE plpgsql;

-- Create view for document email conflict monitoring
CREATE OR REPLACE VIEW document_email_conflict_monitoring AS
SELECT 
    mer.id,
    mer.admin_name,
    mer.email_type,
    mer.subject,
    mer.status,
    mer.created_at,
    jsonb_array_length(mer.conflicts) as conflict_count,
    CASE 
        WHEN jsonb_array_length(mer.conflicts) = 0 THEN 'none'
        WHEN jsonb_array_length(mer.conflicts) <= 2 THEN 'low'
        WHEN jsonb_array_length(mer.conflicts) <= 5 THEN 'medium'
        ELSE 'high'
    END as conflict_severity,
    mer.recipients->>'documentId' as document_id
FROM manual_email_requests mer
WHERE mer.status IN ('pending', 'approved')
AND mer.recipients ? 'documentId'
ORDER BY mer.created_at DESC;

-- Create view for email queue monitoring
CREATE OR REPLACE VIEW email_queue_monitoring AS
SELECT 
    status,
    is_manual,
    COUNT(*) as count,
    AVG(EXTRACT(EPOCH FROM (NOW() - created_at))/60) as avg_wait_minutes
FROM email_queue
GROUP BY status, is_manual
ORDER BY status, is_manual;

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON manual_email_requests TO authenticated;
GRANT SELECT, INSERT ON admin_email_activity TO authenticated;
GRANT SELECT, INSERT, UPDATE ON email_queue TO authenticated;
GRANT SELECT ON document_email_conflict_monitoring TO authenticated;
GRANT SELECT ON email_queue_monitoring TO authenticated;
GRANT EXECUTE ON FUNCTION check_document_email_conflicts TO authenticated;
GRANT EXECUTE ON FUNCTION check_signature_workflow_conflicts TO authenticated;
GRANT EXECUTE ON FUNCTION process_email_queue TO authenticated;
GRANT EXECUTE ON FUNCTION update_email_queue_status TO authenticated;

-- Add comments
COMMENT ON TABLE manual_email_requests IS 'Stores manual email requests submitted by admins with document-specific conflict detection';
COMMENT ON TABLE admin_email_activity IS 'Logs all admin email-related actions for audit purposes';
COMMENT ON TABLE email_queue IS 'Queue for both manual and automated emails with priority and retry logic';
COMMENT ON VIEW document_email_conflict_monitoring IS 'Monitoring view for document-specific email conflicts in manual requests';
COMMENT ON VIEW email_queue_monitoring IS 'Monitoring view for email queue status and performance';
\n-- End of buffrsign-starter/sql/20241201000000_admin_email_controls.sql --\n
-- BuffrSign Production Database Schema
-- This file creates all required tables for the production platform

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Users table (extends Supabase auth.users)
CREATE TABLE IF NOT EXISTS public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(20),
    company_name VARCHAR(255),
    account_type VARCHAR(50) DEFAULT 'individual' CHECK (account_type IN ('individual', 'business', 'enterprise', 'government')),
    namibian_id VARCHAR(20),
    is_verified BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    subscription_plan VARCHAR(50) DEFAULT 'free' CHECK (subscription_plan IN ('free', 'basic', 'premium', 'enterprise')),
    subscription_expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    last_login_at TIMESTAMP WITH TIME ZONE
);

-- Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(255) NOT NULL,
    content TEXT,
    document_type VARCHAR(100) NOT NULL,
    file_path VARCHAR(500),
    file_size BIGINT,
    mime_type VARCHAR(100),
    initiator_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    status VARCHAR(50) DEFAULT 'draft' CHECK (status IN ('draft', 'pending', 'in_progress', 'completed', 'cancelled', 'expired')),
    compliance_score DECIMAL(3,2) DEFAULT 0.0,
    risk_level VARCHAR(20) DEFAULT 'low' CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
    eta_compliant BOOLEAN DEFAULT FALSE,
    cran_accredited BOOLEAN DEFAULT FALSE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    -- Enhanced fields for comprehensive implementation
    file_url VARCHAR(500),
    ai_analysis JSONB,
    analysis_status VARCHAR(20) DEFAULT 'pending',
    category VARCHAR(100),
    description TEXT
);

-- Document fields table
CREATE TABLE IF NOT EXISTS public.document_fields (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    field_type VARCHAR(50) NOT NULL CHECK (field_type IN ('signature', 'text', 'date', 'checkbox', 'dropdown')),
    position_x INTEGER,
    position_y INTEGER,
    width INTEGER,
    height INTEGER,
    page_number INTEGER DEFAULT 1,
    is_required BOOLEAN DEFAULT TRUE,
    default_value TEXT,
    validation_rules JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Signatures table
CREATE TABLE IF NOT EXISTS public.signatures (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    field_id UUID NOT NULL REFERENCES public.document_fields(id) ON DELETE CASCADE,
    signer_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    signature_data TEXT NOT NULL, -- Base64 encoded signature image or data
    signature_type VARCHAR(50) DEFAULT 'electronic' CHECK (signature_type IN ('electronic', 'advanced', 'qualified')),
    signature_method VARCHAR(50) DEFAULT 'draw' CHECK (signature_method IN ('draw', 'type', 'upload', 'biometric')),
    ip_address INET,
    user_agent TEXT,
    location_data JSONB, -- GPS coordinates if available
    device_info JSONB,
    verification_status VARCHAR(50) DEFAULT 'pending' CHECK (verification_status IN ('pending', 'verified', 'failed', 'expired')),
    verification_score DECIMAL(3,2) DEFAULT 0.0,
    signed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE
);

-- Document recipients table
CREATE TABLE IF NOT EXISTS public.document_recipients (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    role VARCHAR(50) DEFAULT 'signer' CHECK (role IN ('signer', 'witness', 'approver', 'viewer')),
    signing_order INTEGER DEFAULT 1,
    status VARCHAR(50) DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'viewed', 'signed', 'declined', 'expired')),
    invitation_sent_at TIMESTAMP WITH TIME ZONE,
    viewed_at TIMESTAMP WITH TIME ZONE,
    signed_at TIMESTAMP WITH TIME ZONE,
    declined_at TIMESTAMP WITH TIME ZONE,
    decline_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Signature Requests table
CREATE TABLE IF NOT EXISTS public.signature_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    requester_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    signer_email VARCHAR(255) NOT NULL,
    signature_type VARCHAR(20) DEFAULT 'simple' CHECK (signature_type IN ('simple', 'advanced', 'qualified')),
    message TEXT,
    redirect_url VARCHAR(500),
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'signed', 'verified', 'revoked', 'expired')),
    signature_data TEXT,
    signed_at TIMESTAMP WITH TIME ZONE,
    notification_sent BOOLEAN DEFAULT FALSE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Audit Trail table
CREATE TABLE IF NOT EXISTS public.audit_trail (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signature_id UUID REFERENCES public.signature_requests(id) ON DELETE CASCADE,
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    action VARCHAR(100) NOT NULL,
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Templates table
CREATE TABLE IF NOT EXISTS public.templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100),
    content TEXT NOT NULL,
    ai_generated BOOLEAN DEFAULT FALSE,
    public BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Compliance Reports table
CREATE TABLE IF NOT EXISTS public.compliance_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    signature_id UUID REFERENCES public.signature_requests(id) ON DELETE CASCADE,
    report_type VARCHAR(50) NOT NULL CHECK (report_type IN ('eta_2019', 'eidas', 'esign_act', 'comprehensive')),
    compliance_data JSONB NOT NULL,
    generated_by UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    valid_until TIMESTAMP WITH TIME ZONE
);

-- Enhanced Biometric Data table
CREATE TABLE IF NOT EXISTS public.biometric_data (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    biometric_type VARCHAR(50) NOT NULL CHECK (biometric_type IN ('fingerprint', 'face', 'iris', 'voice', 'keystroke')),
    template_data TEXT NOT NULL,
    confidence_score DECIMAL(3,2),
    liveness_score DECIMAL(3,2),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Behavioral Metrics table
CREATE TABLE IF NOT EXISTS public.behavioral_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    session_id VARCHAR(255),
    keystroke_dynamics JSONB,
    mouse_patterns JSONB,
    interaction_timing JSONB,
    session_duration DECIMAL(10,2),
    risk_score DECIMAL(3,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Fraud Detection table
CREATE TABLE IF NOT EXISTS public.fraud_detection (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signature_id UUID REFERENCES public.signature_requests(id) ON DELETE CASCADE,
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE,
    fraud_type VARCHAR(50) NOT NULL CHECK (fraud_type IN ('anomaly', 'behavioral', 'biometric', 'network', 'device')),
    risk_score DECIMAL(3,2) NOT NULL,
    confidence_score DECIMAL(3,2),
    detection_data JSONB,
    is_false_positive BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Certificate Management table
CREATE TABLE IF NOT EXISTS public.certificates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    certificate_type VARCHAR(50) NOT NULL CHECK (certificate_type IN ('self_signed', 'ca_issued', 'qualified')),
    certificate_data TEXT NOT NULL,
    private_key_encrypted TEXT,
    hsm_protected BOOLEAN DEFAULT FALSE,
    valid_from TIMESTAMP WITH TIME ZONE NOT NULL,
    valid_until TIMESTAMP WITH TIME ZONE NOT NULL,
    is_revoked BOOLEAN DEFAULT FALSE,
    revocation_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Time Stamps table
CREATE TABLE IF NOT EXISTS public.time_stamps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signature_id UUID REFERENCES public.signature_requests(id) ON DELETE CASCADE,
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    timestamp_data TEXT NOT NULL,
    tsa_url VARCHAR(500),
    tsa_certificate TEXT,
    is_qualified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Enhanced Long-term Validation (LTV) table
CREATE TABLE IF NOT EXISTS public.ltv_validation (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signature_id UUID REFERENCES public.signature_requests(id) ON DELETE CASCADE,
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    archive_timestamp TEXT NOT NULL,
    hash_tree_data JSONB,
    validation_status VARCHAR(50) DEFAULT 'pending' CHECK (validation_status IN ('pending', 'valid', 'invalid', 'expired')),
    validated_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_documents_initiator_id ON public.documents(initiator_id);
CREATE INDEX IF NOT EXISTS idx_documents_status ON public.documents(status);
CREATE INDEX IF NOT EXISTS idx_document_fields_document_id ON public.document_fields(document_id);
CREATE INDEX IF NOT EXISTS idx_signatures_document_id ON public.signatures(document_id);
CREATE INDEX IF NOT EXISTS idx_signatures_signer_id ON public.signatures(signer_id);
CREATE INDEX IF NOT EXISTS idx_signature_requests_document_id ON public.signature_requests(document_id);
CREATE INDEX IF NOT EXISTS idx_signature_requests_requester_id ON public.signature_requests(requester_id);
CREATE INDEX IF NOT EXISTS idx_signature_requests_signer_email ON public.signature_requests(signer_email);
CREATE INDEX IF NOT EXISTS idx_audit_trail_signature_id ON public.audit_trail(signature_id);
CREATE INDEX IF NOT EXISTS idx_audit_trail_document_id ON public.audit_trail(document_id);
CREATE INDEX IF NOT EXISTS idx_audit_trail_user_id ON public.audit_trail(user_id);
CREATE INDEX IF NOT EXISTS idx_templates_user_id ON public.templates(user_id);
CREATE INDEX IF NOT EXISTS idx_templates_category ON public.templates(category);
CREATE INDEX IF NOT EXISTS idx_compliance_reports_document_id ON public.compliance_reports(document_id);
CREATE INDEX IF NOT EXISTS idx_biometric_data_user_id ON public.biometric_data(user_id);
CREATE INDEX IF NOT EXISTS idx_behavioral_metrics_user_id ON public.behavioral_metrics(user_id);
CREATE INDEX IF NOT EXISTS idx_fraud_detection_signature_id ON public.fraud_detection(signature_id);
CREATE INDEX IF NOT EXISTS idx_certificates_user_id ON public.certificates(user_id);
CREATE INDEX IF NOT EXISTS idx_time_stamps_signature_id ON public.time_stamps(signature_id);
CREATE INDEX IF NOT EXISTS idx_ltv_validation_signature_id ON public.ltv_validation(signature_id);

-- Create triggers for updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON public.users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_documents_updated_at BEFORE UPDATE ON public.documents FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_signature_requests_updated_at BEFORE UPDATE ON public.signature_requests FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON public.templates FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_biometric_data_updated_at BEFORE UPDATE ON public.biometric_data FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_certificates_updated_at BEFORE UPDATE ON public.certificates FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Enable Row Level Security (RLS)
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_fields ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.signatures ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_recipients ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.signature_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_trail ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.compliance_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.biometric_data ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.behavioral_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fraud_detection ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.certificates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.time_stamps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ltv_validation ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
-- Users policies
CREATE POLICY "Users can view own profile" ON public.users
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.users
    FOR UPDATE USING (auth.uid() = id);

-- Documents policies
CREATE POLICY "Users can view own documents" ON public.documents
    FOR SELECT USING (auth.uid() = initiator_id);

CREATE POLICY "Users can create documents" ON public.documents
    FOR INSERT WITH CHECK (auth.uid() = initiator_id);

CREATE POLICY "Users can update own documents" ON public.documents
    FOR UPDATE USING (auth.uid() = initiator_id);

-- Document fields policies
CREATE POLICY "Users can view document fields" ON public.document_fields
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.documents 
            WHERE documents.id = document_fields.document_id 
            AND documents.initiator_id = auth.uid()
        )
    );

CREATE POLICY "Users can create document fields" ON public.document_fields
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.documents 
            WHERE documents.id = document_fields.document_id 
            AND documents.initiator_id = auth.uid()
        )
    );

-- Signatures policies
CREATE POLICY "Users can view signatures" ON public.signatures
    FOR SELECT USING (
        auth.uid() = signer_id OR
        EXISTS (
            SELECT 1 FROM public.documents 
            WHERE documents.id = signatures.document_id 
            AND documents.initiator_id = auth.uid()
        )
    );

CREATE POLICY "Users can create signatures" ON public.signatures
    FOR INSERT WITH CHECK (auth.uid() = signer_id);

-- Document recipients policies
CREATE POLICY "Users can view document recipients" ON public.document_recipients
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.documents 
            WHERE documents.id = document_recipients.document_id 
            AND documents.initiator_id = auth.uid()
        )
    );

CREATE POLICY "Users can create document recipients" ON public.document_recipients
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.documents 
            WHERE documents.id = document_recipients.document_id 
            AND documents.initiator_id = auth.uid()
        )
    );

-- Signature Requests policies
CREATE POLICY "Users can view own signature requests" ON public.signature_requests
    FOR SELECT USING (auth.uid() = requester_id);

CREATE POLICY "Users can create signature requests" ON public.signature_requests
    FOR INSERT WITH CHECK (auth.uid() = requester_id);

CREATE POLICY "Users can update own signature requests" ON public.signature_requests
    FOR UPDATE USING (auth.uid() = requester_id);

-- Audit Trail policies
CREATE POLICY "Users can view own audit trails" ON public.audit_trail
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can create audit trails" ON public.audit_trail
    FOR INSERT WITH CHECK (true);

-- Templates policies
CREATE POLICY "Users can view templates" ON public.templates
    FOR SELECT USING (public = true OR auth.uid() = user_id);

CREATE POLICY "Users can create templates" ON public.templates
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own templates" ON public.templates
    FOR UPDATE USING (auth.uid() = user_id);

-- Compliance Reports policies
CREATE POLICY "Users can view compliance reports" ON public.compliance_reports
    FOR SELECT USING (auth.uid() = generated_by);

CREATE POLICY "Users can create compliance reports" ON public.compliance_reports
    FOR INSERT WITH CHECK (auth.uid() = generated_by);

-- Biometric Data policies
CREATE POLICY "Users can view own biometric data" ON public.biometric_data
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create biometric data" ON public.biometric_data
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own biometric data" ON public.biometric_data
    FOR UPDATE USING (auth.uid() = user_id);

-- Behavioral Metrics policies
CREATE POLICY "Users can view own behavioral metrics" ON public.behavioral_metrics
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create behavioral metrics" ON public.behavioral_metrics
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Fraud Detection policies
CREATE POLICY "Users can view fraud detection" ON public.fraud_detection
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can create fraud detection" ON public.fraud_detection
    FOR INSERT WITH CHECK (true);

-- Certificates policies
CREATE POLICY "Users can view own certificates" ON public.certificates
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can create certificates" ON public.certificates
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own certificates" ON public.certificates
    FOR UPDATE USING (auth.uid() = user_id);

-- Time Stamps policies
CREATE POLICY "Users can view time stamps" ON public.time_stamps
    FOR SELECT USING (
        auth.uid() = (
            SELECT requester_id FROM public.signature_requests 
            WHERE signature_requests.id = time_stamps.signature_id
        )
    );

CREATE POLICY "System can create time stamps" ON public.time_stamps
    FOR INSERT WITH CHECK (true);

-- LTV Validation policies
CREATE POLICY "Users can view LTV validation" ON public.ltv_validation
    FOR SELECT USING (
        auth.uid() = (
            SELECT requester_id FROM public.signature_requests 
            WHERE signature_requests.id = ltv_validation.signature_id
        )
    );

CREATE POLICY "System can create LTV validation" ON public.ltv_validation
    FOR INSERT WITH CHECK (true);
\n-- End of buffrsign-starter/sql/create_production_tables.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Adumo Online Payment Gateway Integrations
-- Tables for managing Adumo Online configurations, transactions, and tokenized cards.

-- Adumo Configuration Table
CREATE TABLE adumo_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    merchant_id VARCHAR(255) NOT NULL,
    application_id VARCHAR(255) NOT NULL,
    jwt_secret TEXT NOT NULL,
    test_mode BOOLEAN DEFAULT TRUE,
    live_url TEXT,
    test_url TEXT,
    webhook_secret TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Transactions Table
CREATE TABLE adumo_transactions (
    transaction_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    merchant_reference VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'NAD',
    transaction_index UUID, -- Adumo's unique transaction identifier
    status VARCHAR(50) NOT NULL, -- e.g., 'APPROVED', 'DECLINED', 'PENDING'
    result INTEGER, -- Adumo's _RESULT code (0=success, -1=failed, 1=warning)
    error_code VARCHAR(10),
    error_message TEXT,
    bank_error_code VARCHAR(10),
    bank_error_message TEXT,
    payment_method VARCHAR(50),
    acquirer_datetime TIMESTAMP WITH TIME ZONE,
    redirect_successful_url TEXT,
    redirect_failed_url TEXT,
    request_payload JSONB,
    response_payload JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Tokenized Cards (for 1Click payments)
CREATE TABLE adumo_tokenized_cards (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    puid UUID NOT NULL UNIQUE, -- Adumo's Profile Unique Identifier
    card_type VARCHAR(50),
    pan_hashed VARCHAR(16), -- First six and last four digits
    card_country VARCHAR(50),
    expiry_date DATE, -- Stored as month/year, but can be parsed to date
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Webhook Logs
CREATE TABLE adumo_webhook_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    transaction_id UUID REFERENCES adumo_transactions(transaction_id),
    event_type VARCHAR(100) NOT NULL,
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- Indexes for performance
CREATE INDEX idx_adumo_transactions_user ON adumo_transactions(user_id);
CREATE INDEX idx_adumo_transactions_merchant_ref ON adumo_transactions(merchant_reference);
CREATE INDEX idx_adumo_transactions_status ON adumo_transactions(status);
CREATE INDEX idx_adumo_tokenized_cards_user ON adumo_tokenized_cards(user_id);
CREATE INDEX idx_adumo_webhook_logs_transaction ON adumo_webhook_logs(transaction_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_adumo_configs_updated_at
BEFORE UPDATE ON adumo_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_transactions_updated_at
BEFORE UPDATE ON adumo_transactions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_tokenized_cards_updated_at
BEFORE UPDATE ON adumo_tokenized_cards
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/18_adumo_integrations.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- RealPay Payment Gateway Integrations
-- Tables for managing RealPay configurations, mandates, instalments, and callbacks.

-- RealPay Configuration Table
CREATE TABLE realpay_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    api_key TEXT NOT NULL,
    hmac_secret TEXT NOT NULL,
    beneficiary_user VARCHAR(255),
    test_mode BOOLEAN DEFAULT TRUE,
    live_callback_url TEXT,
    test_callback_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Mandates Table (for Debicheck products)
CREATE TABLE realpay_mandates (
    mandate_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    customer_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    mandate_reference VARCHAR(255) UNIQUE NOT NULL,
    bank_account_id UUID REFERENCES banking_details(id), -- Link to unified banking_details
    mandate_status VARCHAR(50) NOT NULL, -- e.g., 'ACTIVE', 'CANCELLED', 'PENDING'
    mandate_type VARCHAR(50), -- e.g., 'DEBICHECK', 'EFT'
    start_date DATE,
    end_date DATE,
    amount DECIMAL(10,2), -- Max amount for variable mandates
    frequency VARCHAR(50), -- e.g., 'MONTHLY', 'WEEKLY'
    realpay_mandate_id VARCHAR(255), -- RealPay's internal mandate ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Instalments Table
CREATE TABLE realpay_instalments (
    instalment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_reference VARCHAR(255) UNIQUE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    collection_date DATE NOT NULL,
    instalment_status VARCHAR(50) NOT NULL, -- e.g., 'SUCCESS', 'FAILED', 'PENDING'
    realpay_instalment_id VARCHAR(255), -- RealPay's internal instalment ID
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Callback Logs (Webhooks)
CREATE TABLE realpay_callbacks (
    callback_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_id UUID REFERENCES realpay_instalments(instalment_id),
    x_callback_header VARCHAR(100) NOT NULL, -- e.g., 'MANDATE', 'INSTALMENT'
    x_hmac_header TEXT NOT NULL,
    x_beneficiary_user_header VARCHAR(255),
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- RealPay Pricing Configuration Table
CREATE TABLE realpay_pricing_configs (
    pricing_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    service_type VARCHAR(100) NOT NULL, -- e.g., 'EnDO', 'Payouts', 'VAS'
    fee_type VARCHAR(100) NOT NULL, -- e.g., 'monthly_fee', 'transaction_fee', 'once_off_fee'
    min_transactions INTEGER,
    max_transactions INTEGER,
    amount DECIMAL(10,2),
    percentage DECIMAL(5,4),
    unit_cost DECIMAL(10,2),
    description TEXT,
    effective_date DATE NOT NULL,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_realpay_mandates_customer ON realpay_mandates(customer_id);
CREATE INDEX idx_realpay_mandates_reference ON realpay_mandates(mandate_reference);
CREATE INDEX idx_realpay_instalments_mandate ON realpay_instalments(mandate_id);
CREATE INDEX idx_realpay_instalments_reference ON realpay_instalments(instalment_reference);
CREATE INDEX idx_realpay_callbacks_mandate ON realpay_callbacks(mandate_id);
CREATE INDEX idx_realpay_callbacks_instalment ON realpay_callbacks(instalment_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_realpay_configs_updated_at
BEFORE UPDATE ON realpay_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_mandates_updated_at
BEFORE UPDATE ON realpay_mandates
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_instalments_updated_at
BEFORE UPDATE ON realpay_instalments
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_pricing_configs_updated_at
BEFORE UPDATE ON realpay_pricing_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/19_realpay_integrations.sql --\n
-- Buffr API Integrations
-- Tables for managing cross-project API integrations and configurations.

-- Buffr API Integration Configurations
CREATE TABLE buffr_api_integrations (
    integration_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    target_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    integration_name VARCHAR(255) NOT NULL, -- e.g., 'BuffrLend_to_BuffrSign_LoanSigning'
    api_base_url TEXT NOT NULL,
    api_key_encrypted TEXT, -- Encrypted API key for authentication
    api_key_hash TEXT, -- Hash of the API key for verification
    is_active BOOLEAN DEFAULT TRUE,
    configuration JSONB, -- JSONB field for flexible configuration parameters
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(source_project, target_project, integration_name)
);

-- Buffr API Integration Logs (for auditing cross-project calls)
CREATE TABLE buffr_api_integration_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    integration_id UUID REFERENCES buffr_api_integrations(integration_id),
    request_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    request_method VARCHAR(10) NOT NULL, -- e.g., 'GET', 'POST'
    request_endpoint TEXT NOT NULL,
    request_payload JSONB,
    response_timestamp TIMESTAMP WITH TIME ZONE,
    response_status_code INTEGER,
    response_payload JSONB,
    error_message TEXT,
    user_id UUID REFERENCES profiles(id), -- User who initiated the action, if applicable
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_buffr_api_integrations_source_target ON buffr_api_integrations(source_project, target_project);
CREATE INDEX idx_buffr_api_integration_logs_integration ON buffr_api_integration_logs(integration_id);
CREATE INDEX idx_buffr_api_integration_logs_user ON buffr_api_integration_logs(user_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_buffr_api_integrations_updated_at
BEFORE UPDATE ON buffr_api_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/20_buffr_api_integrations.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Adumo Online Payment Gateway Integrations
-- Tables for managing Adumo Online configurations, transactions, and tokenized cards.

-- Adumo Configuration Table
CREATE TABLE adumo_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    merchant_id VARCHAR(255) NOT NULL,
    application_id VARCHAR(255) NOT NULL,
    jwt_secret TEXT NOT NULL,
    test_mode BOOLEAN DEFAULT TRUE,
    live_url TEXT,
    test_url TEXT,
    webhook_secret TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Transactions Table
CREATE TABLE adumo_transactions (
    transaction_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    merchant_reference VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'NAD',
    transaction_index UUID, -- Adumo's unique transaction identifier
    status VARCHAR(50) NOT NULL, -- e.g., 'APPROVED', 'DECLINED', 'PENDING'
    result INTEGER, -- Adumo's _RESULT code (0=success, -1=failed, 1=warning)
    error_code VARCHAR(10),
    error_message TEXT,
    bank_error_code VARCHAR(10),
    bank_error_message TEXT,
    payment_method VARCHAR(50),
    acquirer_datetime TIMESTAMP WITH TIME ZONE,
    redirect_successful_url TEXT,
    redirect_failed_url TEXT,
    request_payload JSONB,
    response_payload JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Tokenized Cards (for 1Click payments)
CREATE TABLE adumo_tokenized_cards (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    puid UUID NOT NULL UNIQUE, -- Adumo's Profile Unique Identifier
    card_type VARCHAR(50),
    pan_hashed VARCHAR(16), -- First six and last four digits
    card_country VARCHAR(50),
    expiry_date DATE, -- Stored as month/year, but can be parsed to date
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Webhook Logs
CREATE TABLE adumo_webhook_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    transaction_id UUID REFERENCES adumo_transactions(transaction_id),
    event_type VARCHAR(100) NOT NULL,
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- Indexes for performance
CREATE INDEX idx_adumo_transactions_user ON adumo_transactions(user_id);
CREATE INDEX idx_adumo_transactions_merchant_ref ON adumo_transactions(merchant_reference);
CREATE INDEX idx_adumo_transactions_status ON adumo_transactions(status);
CREATE INDEX idx_adumo_tokenized_cards_user ON adumo_tokenized_cards(user_id);
CREATE INDEX idx_adumo_webhook_logs_transaction ON adumo_webhook_logs(transaction_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_adumo_configs_updated_at
BEFORE UPDATE ON adumo_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_transactions_updated_at
BEFORE UPDATE ON adumo_transactions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_tokenized_cards_updated_at
BEFORE UPDATE ON adumo_tokenized_cards
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/18_adumo_integrations.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrsign-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrsign-starter/sql/002_create_unified_audit_logging.sql --\n
-- RealPay Payment Gateway Integrations
-- Tables for managing RealPay configurations, mandates, instalments, and callbacks.

-- RealPay Configuration Table
CREATE TABLE realpay_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    api_key TEXT NOT NULL,
    hmac_secret TEXT NOT NULL,
    beneficiary_user VARCHAR(255),
    test_mode BOOLEAN DEFAULT TRUE,
    live_callback_url TEXT,
    test_callback_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Mandates Table (for Debicheck products)
CREATE TABLE realpay_mandates (
    mandate_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    customer_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    mandate_reference VARCHAR(255) UNIQUE NOT NULL,
    bank_account_id UUID REFERENCES banking_details(id), -- Link to unified banking_details
    mandate_status VARCHAR(50) NOT NULL, -- e.g., 'ACTIVE', 'CANCELLED', 'PENDING'
    mandate_type VARCHAR(50), -- e.g., 'DEBICHECK', 'EFT'
    start_date DATE,
    end_date DATE,
    amount DECIMAL(10,2), -- Max amount for variable mandates
    frequency VARCHAR(50), -- e.g., 'MONTHLY', 'WEEKLY'
    realpay_mandate_id VARCHAR(255), -- RealPay's internal mandate ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Instalments Table
CREATE TABLE realpay_instalments (
    instalment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_reference VARCHAR(255) UNIQUE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    collection_date DATE NOT NULL,
    instalment_status VARCHAR(50) NOT NULL, -- e.g., 'SUCCESS', 'FAILED', 'PENDING'
    realpay_instalment_id VARCHAR(255), -- RealPay's internal instalment ID
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Callback Logs (Webhooks)
CREATE TABLE realpay_callbacks (
    callback_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_id UUID REFERENCES realpay_instalments(instalment_id),
    x_callback_header VARCHAR(100) NOT NULL, -- e.g., 'MANDATE', 'INSTALMENT'
    x_hmac_header TEXT NOT NULL,
    x_beneficiary_user_header VARCHAR(255),
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- RealPay Pricing Configuration Table
CREATE TABLE realpay_pricing_configs (
    pricing_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    service_type VARCHAR(100) NOT NULL, -- e.g., 'EnDO', 'Payouts', 'VAS'
    fee_type VARCHAR(100) NOT NULL, -- e.g., 'monthly_fee', 'transaction_fee', 'once_off_fee'
    min_transactions INTEGER,
    max_transactions INTEGER,
    amount DECIMAL(10,2),
    percentage DECIMAL(5,4),
    unit_cost DECIMAL(10,2),
    description TEXT,
    effective_date DATE NOT NULL,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_realpay_mandates_customer ON realpay_mandates(customer_id);
CREATE INDEX idx_realpay_mandates_reference ON realpay_mandates(mandate_reference);
CREATE INDEX idx_realpay_instalments_mandate ON realpay_instalments(mandate_id);
CREATE INDEX idx_realpay_instalments_reference ON realpay_instalments(instalment_reference);
CREATE INDEX idx_realpay_callbacks_mandate ON realpay_callbacks(mandate_id);
CREATE INDEX idx_realpay_callbacks_instalment ON realpay_callbacks(instalment_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_realpay_configs_updated_at
BEFORE UPDATE ON realpay_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_mandates_updated_at
BEFORE UPDATE ON realpay_mandates
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_instalments_updated_at
BEFORE UPDATE ON realpay_instalments
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_pricing_configs_updated_at
BEFORE UPDATE ON realpay_pricing_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/19_realpay_integrations.sql --\n
-- Buffr API Integrations
-- Tables for managing cross-project API integrations and configurations.

-- Buffr API Integration Configurations
CREATE TABLE buffr_api_integrations (
    integration_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    target_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    integration_name VARCHAR(255) NOT NULL, -- e.g., 'BuffrLend_to_BuffrSign_LoanSigning'
    api_base_url TEXT NOT NULL,
    api_key_encrypted TEXT, -- Encrypted API key for authentication
    api_key_hash TEXT, -- Hash of the API key for verification
    is_active BOOLEAN DEFAULT TRUE,
    configuration JSONB, -- JSONB field for flexible configuration parameters
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(source_project, target_project, integration_name)
);

-- Buffr API Integration Logs (for auditing cross-project calls)
CREATE TABLE buffr_api_integration_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    integration_id UUID REFERENCES buffr_api_integrations(integration_id),
    request_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    request_method VARCHAR(10) NOT NULL, -- e.g., 'GET', 'POST'
    request_endpoint TEXT NOT NULL,
    request_payload JSONB,
    response_timestamp TIMESTAMP WITH TIME ZONE,
    response_status_code INTEGER,
    response_payload JSONB,
    error_message TEXT,
    user_id UUID REFERENCES profiles(id), -- User who initiated the action, if applicable
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_buffr_api_integrations_source_target ON buffr_api_integrations(source_project, target_project);
CREATE INDEX idx_buffr_api_integration_logs_integration ON buffr_api_integration_logs(integration_id);
CREATE INDEX idx_buffr_api_integration_logs_user ON buffr_api_integration_logs(user_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_buffr_api_integrations_updated_at
BEFORE UPDATE ON buffr_api_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrsign-starter/sql/20_buffr_api_integrations.sql --\n
